{
  "config": "CODEGEN_COMPLETE_CODEFORM_COMMENTFORM_NOCOMMENT",
  "model": "codegen-6B-multi",
  "data": {
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);",
      "output": [
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!this.seriesVisibleList.equals(that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend, that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!this.seriesVisibleInLegendList.equals(that.seriesVisibleInLegendList)) {\n      return false;\n    }\n    if (this.baseSeriesVisibleInLegend!= that.baseSeriesVisibleInLegend) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false;\n    }\n    ",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList,\n            that.seriesVisibleList)) {\n      return false;\n    }\n    if (this.baseSeriesVisible!= that.baseSeriesVisible) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend,\n            that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegendList,\n            that.seriesVisibleInLegendList)) {\n      return false;\n    }\n    if (this.baseSeriesVisibleInLegend!= that.baseSeriesVisibleInLegend) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList,\n            that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible,\n            that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend,\n            that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend,\n            that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.paintList, that.p",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!this.seriesVisibleList.equals(that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend, that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!this.seriesVisibleInLegendList.equals(that.seriesVisibleInLegendList)) {\n      return false;\n    }\n    if (this.baseSeriesVisibleInLegend!= that.baseSeriesVisibleInLegend) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!this.seriesVisibleList.equals(that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend, that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!this.seriesVisibleInLegendList.equals(that.seriesVisibleInLegendList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend, that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList,\n            that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend,\n            that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend,\n            that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList, that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend, that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend, that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.paintList",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList, that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend, that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegendList, that.seriesVisibleInLegendList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend, that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!PaintUtilities.equal(this.paint, that.paint",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList,\n            that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible,\n            that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend,\n            that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend,\n            that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.paintScale, that.paintScale)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.paintScaleList, that",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer,\n\t\tboolean notify) {\n    ArrayList markers;\n    if (layer == Layer.FOREGROUND) {\n        markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer(\n                index));\n    }\n    else {\n        markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer(\n                index));\n    }\n// buggy line:    boolean removed = markers.remove(marker);\n    boolean removed = markers.remove(marker);\n    if (removed && notify) {\n        notifyListeners(new RendererChangeEvent(this));\n    }\n    return removed;\n  }\n\n  /**\n   * Tests this renderer for equality with an arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return <code>true</code> or <code>false</code>.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    }\n    if (!(obj instanceof AbstractRenderer)) {\n      return false;\n    }\n    AbstractRenderer that = (AbstractRenderer) obj;\n    if (!ObjectUtilities.equal(this.seriesVisible, that.seriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleList,\n            that.seriesVisibleList)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisible, that.baseSeriesVisible)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.seriesVisibleInLegend,\n            that.seriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.baseSeriesVisibleInLegend,\n            that.baseSeriesVisibleInLegend)) {\n      return false;\n    }\n    if (!ObjectUtilities.equal(this.paintScale, that.paintScale)) {\n      return false;\n    }\n    if (!ObjectUtilities."
      ],
      "function range": "2155,5-2171,5"
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns != null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns != null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns != null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);",
      "output": [
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      recordCall(name, n);\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    ",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      recordCall(name, n);\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getLastChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    ",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        recordCall(name, n);\n      }\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = create",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        name.recordCall(n);\n      }\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = create",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        recordCall(name, n);\n      }\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getLastChild();\n    NameInformation ns = create",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        name.recordCall(n);\n      }\n    }\n  } else if (n.isGetProp()) {\n    Node nameNode = n.getLastChild();\n    NameInformation ns = create",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        recordCall(name, n);\n      }\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a name.\n   *\n   * @param name name being",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        recordCall(name, n);\n      }\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a global name.\n   *\n   * @param name A",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      recordCall(name, n);\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a name.\n   *\n   * @param name name being assigned to\n   * @param n node containing the assignment",
        "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    if (NodeUtil.isVarDeclaration(n)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      Preconditions.checkNotNull(ns);\n      recordSet(ns.name, n);\n    } else if (NodeUtil.isFunctionDeclaration(n)) {\n      Node nameNode = n.getFirstChild();\n      NameInformation ns = createNameInformation(t, nameNode, n);\n      if (ns!= null) {\n        JsName nameInfo = getName(nameNode.getString(), true);\n        recordSet(nameInfo.name, nameNode);\n      }\n    } else if (NodeUtil.isObjectLitKey(n, parent)) {\n      NameInformation ns = createNameInformation(t, n, parent);\n      if (ns!= null) {\n        recordSet(ns.name, n);\n      }\n    }\n  }\n  if (n.isAssign()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null) {\n      if (ns.isPrototype) {\n        recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n      } else {\n        recordSet(ns.name, nameNode);\n      }\n    }\n  } else if (n.isCall()) {\n    Node nameNode = n.getFirstChild();\n    NameInformation ns = createNameInformation(t, nameNode, n);\n    if (ns!= null && ns.onlyAffectsClassDef) {\n// buggy line:      JsName name = getName(ns.name, false);\n// fixed line:     JsName name = getName(ns.name, true);\n      JsName name = getName(ns.name, true);\n      if (name!= null) {\n        recordCall(name, n);\n      }\n    }\n  }\n}\n\n  /**\n   * Records the assignment of a value to a name.\n   *\n   * @param name A name"
      ],
      "function range": "595,5-642,5"
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }",
      "output": [
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtype(that);\n// buggy line:  }\n  return super.isSubtype(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic <T> T visit(Visitor<T>",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic JSType unionWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.unionWith(that);\n// buggy line:  }\n  return super.unionWith(that);\n}\n\n@Override\npublic JSType intersectWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.intersectWith(that);\n// buggy line:  }\n  return super.intersectWith(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n//",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType meet(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.meet(that);\n// buggy line:  }\n  return super.meet(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic int hashCode() {\n// buggy line:  return super.hash",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtype(that);\n// buggy line:  }\n  return super.isSubtype(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic int hashCode() {\n// buggy line:  return super.hashCode();\n  return super.hashCode();\n}\n\n@Override\npublic boolean equals(Object that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.equals(that);\n// buggy line:  }\n  return super.",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic JSType unionWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.unionWith(that);\n// buggy line:  }\n  return super.unionWith(that);\n}\n\n@Override\npublic JSType intersectWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.intersectWith(that);\n// buggy line:  }\n  return super.intersectWith(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean canBeCalled() {\n// buggy line:  return",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtype(that);\n// buggy line:  }\n  return super.isSubtype(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic <R> R visit(Visitor<R>",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic JSType unionWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.unionWith(that);\n// buggy line:  }\n  return super.unionWith(that);\n}\n\n@Override\npublic JSType intersectWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.intersectWith(that);\n// buggy line:  }\n  return super.intersectWith(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean canBeCalled() {\n// buggy line:  if",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtype(that);\n// buggy line:  }\n  return super.isSubtype(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean canBeCalled() {\n// buggy line",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic JSType unionWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.unionWith(that);\n// buggy line:  }\n  return super.unionWith(that);\n}\n\n@Override\npublic JSType intersectWith(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.intersectWith(that);\n// buggy line:  }\n  return super.intersectWith(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic boolean isEnumElement() {\n// buggy line:  return",
        "@Override\npublic JSType getLeastSupertype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getLeastSupertype(that);\n// buggy line:  }\n  return super.getLeastSupertype(that);\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getGreatestSubtype(that);\n// buggy line:  }\n  return super.getGreatestSubtype(that);\n}\n\n@Override\npublic JSType collapseUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.collapseUnion(that);\n// buggy line:  }\n  return super.collapseUnion(that);\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.getRestrictedUnion(that);\n// buggy line:  }\n  return super.getRestrictedUnion(that);\n}\n\n@Override\npublic boolean isSubtype(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtype(that);\n// buggy line:  }\n  return super.isSubtype(that);\n}\n\n@Override\npublic boolean isEquivalentTo(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isEquivalentTo(that);\n// buggy line:  }\n  return super.isEquivalentTo(that);\n}\n\n@Override\npublic boolean isSubtypeOf(JSType that) {\n// buggy line:  if (!that.isRecordType()) {\n// buggy line:    return super.isSubtypeOf(that);\n// buggy line:  }\n  return super.isSubtypeOf(that);\n}\n\n@Override\npublic RecordType toMaybeRecordType() {\n// buggy"
      ],
      "function range": "140,3-155,3"
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n      case '\\n': sb.append(\"\\\\n\"); break;\n// buggy line:      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\\"': sb.append(doublequoteEscape); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      default:\n        if (outputCharsetEncoder!= null && outputCharsetEncoder.canEncode(c)) {\n          sb.append(c);\n        } else {\n          sb.append(String.format(\"\\\\u%04x\", (int) c));\n        }\n        break;\n    }\n  }\n  sb.append(quote);\n  return sb.toString();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in"
      ],
      "function range": "956,3-1025,3"
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:",
      "output": [
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n// buggy line:          case Token.DEC:\n//",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n// buggy line:          case Token.DEC:\n          ",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n//                      case Token.DEC:\n//                          {\n",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n// buggy line:          case Token.DEC:\n        ",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n//      isSet = true;\n//      type =",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n// buggy line:          case Token.DEC:\n            ",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n//     case Token.DEC:\n//     case Token",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n//                      case Token.DEC:\n//                          isSet",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n// case Token.DEC:\n//   if (parent",
        "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      name = null;\n      if (parent!= null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      if (parent!= null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node gramps = parent.getParent();\n            if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n// buggy line:          case Token.INC:\n//                     case Token.DEC:\n//                     isSet"
      ],
      "function range": "306,5-430,5"
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }",
      "output": [
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            default:\n                if(unquote",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case'':\n                regex.append(\"\\\\s\");\n                break;\n            case '\\t':\n                ",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case'':\n                if(unquote) {\n                    regex.append(\"\\\\ \");\n                } else {",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case '-':\n                regex.append(\"\\\\-\");\n                break;\n            case '_':\n                re",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case'':\n                regex",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case '-':\n                regex.append(\"\\\\-\");\n                break;\n            case'':\n                re",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case'':\n                regex.append(\"\\\\s\");\n                break;\n            default:\n                if(c",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case ',':\n                regex.append(\"\\\\,\");\n                break;\n            case'':\n                re",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n    boolean wasWhite= false;\n    for(int i= 0; i<value.length(); ++i) {\n        char c= value.charAt(i);\n// buggy line:        if(Character.isWhitespace(c)) {\n// buggy line:            if(!wasWhite) {\n// buggy line:                wasWhite= true;\n// buggy line:                regex.append(\"\\\\s*+\");\n// buggy line:            }\n// buggy line:            continue;\n// buggy line:        }\n        if(Character.isWhitespace(c)) {\n            if(!wasWhite) {\n                wasWhite= true;\n                regex.append(\"\\\\s*+\");\n            }\n            continue;\n        }\n        wasWhite= false;\n        switch(c) {\n            case '\\\\':\n                regex.append(\"\\\\\\\\\");\n                break;\n            case '^':\n                regex.append(\"\\\\^\");\n                break;\n            case '$':\n                regex.append(\"\\\\$\");\n                break;\n            case '.':\n                regex.append(\"\\\\.\");\n                break;\n            case '*':\n                regex.append(\"\\\\*\");\n                break;\n            case '+':\n                regex.append(\"\\\\+\");\n                break;\n            case '?':\n                regex.append(\"\\\\?\");\n                break;\n            case '(':\n                regex.append(\"\\\\(\");\n                break;\n            case ')':\n                regex.append(\"\\\\)\");\n                break;\n            case '[':\n                regex.append(\"\\\\[\");\n                break;\n            case ']':\n                regex.append(\"\\\\]\");\n                break;\n            case '{':\n                regex.append(\"\\\\{\");\n                break;\n            case '}':\n                regex.append(\"\\\\}\");\n                break;\n            case '|':\n                regex.append(\"\\\\|\");\n                break;\n            case'':\n                regex.append(\"\\\\s\");\n                break;\n            default:\n                if(un"
      ],
      "function range": "303,5-343,5"
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();",
      "output": [
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.DOW, Calendar.SUNDAY);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.H",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 0);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.DOW, Calendar.SUNDAY);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 0);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 0);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 0);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 1);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.DOW, Calendar.SUNDAY);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 1);\n        calendar.set(Calendar.MILLISECONDS_IN_DAY, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) {\n    if (mTimeZoneForced) {\n// buggy line:        calendar = (Calendar) calendar.clone();\n        calendar = (Calendar) calendar.clone();\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.YEAR, 1970);\n        calendar.set(Calendar.MONTH, 0);\n        calendar.set(Calendar.DAY_OF_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_WEEK, Calendar.SUNDAY);\n        calendar.set(Calendar.DAY_OF_WEEK_IN_MONTH, 1);\n        calendar.set(Calendar.DAY_OF_YEAR, 1);\n        calendar.set(Calendar.WEEK_OF_MONTH, 0);\n        calendar.set(Calendar.WEEK_OF_YEAR, 0);\n        calendar.set(Calendar.AM_PM, Calendar.AM);\n        calendar.set(Calendar.HOUR, 0);\n        calendar.set(Calendar.HOUR_OF_DAY, 0);\n        calendar.set(Calendar.MINUTE, 0);\n        calendar.set(Calendar.SECOND, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar.set(Calendar.ZONE_OFFSET, 0);\n        calendar.set(Calendar.DST_OFFSET, 0);\n        calendar.set(Calendar.YEAR_WOY, 1970);\n        calendar.set(Calendar.DOW_LOCAL, Calendar.SUNDAY);\n        calendar.set(Calendar.EXTENDED_YEAR, 1970);\n        calendar.set(Calendar.JULIAN_DAY, 1);\n        calendar.set(Calendar.MILLISECOND, 0);\n        calendar."
      ],
      "function range": "870,5-876,5"
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];",
      "output": [
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algeb",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "public double getChiSquare() {\n    double chiSquare = 0;\n    for (int i = 0; i < rows; ++i) {\n        final double residual = residuals[i];\n// buggy line:        chiSquare += residual * residual / residualsWeights[i];\n        chiSquare += residual * residual / (residualsWeights[i] * residualsWeights[i]);\n    }\n    return chiSquare;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators"
      ],
      "function range": "254,5-261,5"
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;",
      "output": [
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.h",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.al",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOper",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimization",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.h",
        "public static double distance(int[] p1, int[] p2) {\n// buggy line:  int sum = 0;\n//            for (int i = 0; i < p1.length; i++) {\n//                sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n//            }\n//            return Math.sqrt(sum);\n        int sum = 0;\n        for (int i = 0; i < p1.length; i++) {\n            sum += (p1[i] - p2[i]) * (p1[i] - p2[i]);\n        }\n        return Math.sqrt(sum);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;"
      ],
      "function range": "1623,5-1630,5"
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length != this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];",
      "output": [
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[][] operate(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n    final BigDecimal[][] out = new BigDecimal[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            out[i][j] = this.getEntry(i, j).multiply(v[i][0]);\n            for (int k = 1; k < nCols; k++) {\n                out[i][j] = out[i][j].add(this.getEntry(i, k).multiply(v[i][k]));\n            }\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDim",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = getRowDimension();\n    final int",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = getRowDimension();\n    final int",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[][] operate(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[][] out = new BigDecimal[v.length][v[0].length];\n    final BigDecimal[][] out = new BigDecimal[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            out[i][j] = this.getEntry(i, j).multiply(v[i][0]);\n            for (int k = 1; k < nCols; k++) {\n                out[i][j] = out[i][j].add(this.getEntry(i, k).multiply(v[i][k]));\n            }\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[]",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this.getRowDimension();\n    ",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[][] operate(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[][] out = new BigDecimal[v.length][v[0].length];\n    final BigDecimal[][] out = new BigDecimal[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            out[i][j] = this.getEntry(i, j).multiply(v[i][0]);\n            for (int k = 1; k < nCols; k++) {\n                out[i][j] = out[i][j].add(this.getEntry(i, k).multiply(v[i][k]));\n            }\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this.getRowDimension();\n    ",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = get",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public BigDecimal[] preMultiply(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nCols];\n    for (int j = 0; j < nCols; j++) {\n        out[j] = v[0].multiply(this.getEntry(0, j));\n        for (int i = 1; i < nRows; i++) {\n            out[j] = out[j].add(v[i].multiply(this.getEntry(i, j)));\n        }\n    }\n    return out;\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  public FieldMatrix<BigDecimal> transpose() {\n    final int nRows = this",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException {\n    if (v.length!= this.getColumnDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[] out = new BigDecimal[v.length];\n    final BigDecimal[] out = new BigDecimal[nRows];\n    for (int i = 0; i < nRows; i++) {\n        out[i] = this.getEntry(i, 0).multiply(v[0]);\n        for (int j = 1; j < nCols; j++) {\n            out[i] = out[i].add(this.getEntry(i, j).multiply(v[j]));\n        }\n    }\n    return out;\n  }\n\n  public BigDecimal[][] operate(BigDecimal[][] v) throws IllegalArgumentException {\n    if (v.length!= this.getRowDimension()) {\n        throw new IllegalArgumentException(\"vector has wrong length\");\n    }\n    final int nRows = this.getRowDimension();\n    final int nCols = this.getColumnDimension();\n// buggy line:    final BigDecimal[][] out = new BigDecimal[v.length][v[0].length];\n    final BigDecimal[][] out = new BigDecimal[nRows][nCols];\n    for (int i = 0; i < nRows; i++) {\n        for (int j = 0; j < nCols; j++) {\n            out[i][j] = this.getEntry(i, j).multiply(v[i][0]);\n            for (int k = 1; k < nCols; k++) {\n                out[i][j] = out[i][j].add(this.getEntry(i, k).multiply(v[i][k]));\n            }\n        }\n    }\n    return out;\n  }\n}\n<|java"
      ],
      "function range": "985,5-1000,5"
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset != null) {",
      "output": [
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getRowKey(i));\n            item.setSeriesIndex(index);\n            item.setDataset(dataset);\n            item.setDatasetIndex(i);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getItemCount() > 0) {\n        int seriesCount = dataset.getSeriesCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getSeriesKey(i));\n            item.setSeriesIndex(i);\n            item.setDataset(dataset);\n            item.setDatasetIndex(index);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendGraphic</code> instance for equality with an\n   * arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getRowKey(i));\n            item.setSeriesIndex(index);\n            item.setDataset(dataset);\n            item.setDatasetIndex(i);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendGraphic</code> instance for equality with an\n   * arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getRowKey(i));\n            item.setSeriesIndex(index);\n            item.setDataset(dataset);\n            item.setDatasetIndex(i);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    ",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getItemCount() > 0) {\n        int seriesCount = dataset.getSeriesCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getSeriesKey(i));\n            item.setSeriesIndex(i);\n            item.setDataset(dataset);\n            item.setDatasetIndex(index);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true;\n    ",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getRowKey(i));\n            item.setSeriesIndex(index);\n            item.setDataset(dataset);\n            item.setDatasetIndex(i);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is not <code>null</code>;</li>\n   * <li><code>obj</code> is an",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getItemCount() > 0) {\n        int seriesCount = dataset.getSeriesCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getSeriesKey(i));\n            item.setSeriesIndex(i);\n            item.setDataset(dataset);\n            item.setDatasetIndex(index);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendTitle</code> for equality with an arbitrary\n   * object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is not <code>null</code>;</li>\n   * <li><code>obj</code> is an",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            Paint outlinePaint = this.plot.getLegendItemOutlinePaint();\n            Stroke outlineStroke = this.plot.getLegendItemOutlineStroke();\n            LegendItem resultItem = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint, outlineStroke, outlinePaint);\n            result.add(resultItem);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendGraphic</code> instance for equality with an\n   * arbitrary object.\n   *\n   * @param obj  the object (<code>null</code> permitted).\n   *\n   * @return A boolean.\n   */\n  public boolean equals(Object obj) {\n    if (obj == this) {\n      return true",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getItemCount() > 0) {\n        int seriesCount = dataset.getSeriesCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getSeriesKey(i));\n            item.setSeriesIndex(i);\n            item.setDataset(dataset);\n            item.setDatasetIndex(index);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendGraphic</code> instance for equality with an\n   * arbitrary object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is an instance of <code>LegendGraphic</code> (not\n   *     <code>null</code",
        "public LegendItemCollection getLegendItems() {\n    LegendItemCollection result = new LegendItemCollection();\n    if (this.plot == null) {\n        return result;\n    }\n    int index = this.plot.getIndexOf(this);\n    CategoryDataset dataset = this.plot.getDataset(index);\n// buggy line:    if (dataset!= null) {\n    if (dataset!= null && dataset.getRowCount() > 0) {\n        int seriesCount = dataset.getRowCount();\n        for (int i = 0; i < seriesCount; i++) {\n            String label = this.plot.getLegendItemLabelGenerator().generateLabel(\n                    dataset, i);\n            String description = label;\n            String toolTipText = null;\n            if (this.plot.getLegendItemToolTipGenerator()!= null) {\n                toolTipText = this.plot.getLegendItemToolTipGenerator().generateLabel(\n                        dataset, i);\n            }\n            String urlText = null;\n            if (this.plot.getLegendItemURLGenerator()!= null) {\n                urlText = this.plot.getLegendItemURLGenerator().generateLabel(\n                        dataset, i);\n            }\n            Shape shape = this.plot.getLegendItemShape();\n            Paint paint = this.plot.getLegendItemPaint();\n            LegendItem item = new LegendItem(label, description, toolTipText,\n                    urlText, shape, paint);\n            item.setSeriesKey(dataset.getRowKey(i));\n            item.setSeriesIndex(index);\n            item.setDataset(dataset);\n            item.setDatasetIndex(i);\n            result.add(item);\n        }\n    }\n    return result;\n  }\n\n  /**\n   * Tests this <code>LegendGraphic</code> instance for equality with an\n   * arbitrary object.  This method returns <code>true</code> if and only if:\n   * <ul>\n   * <li><code>obj</code> is an instance of <code>LegendGraphic</code> (not\n   *     <code>null</code"
      ],
      "function range": "1790,5-1822,5"
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();",
      "output": [
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (!this.getClass().equals(that.getClass())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count!= that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            Number v1 = getY(i);\n            Number v2 = that.getY(i);\n            if (v1 == null) {\n                if (v2!= null) {",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (!this.getClass().equals(that.getClass())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count!= that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            Number v1 = getDataItem(i);\n            Number v2 = that.getDataItem(i);\n            if (v1 == null) {\n                if (v2!=",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests the series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (this.autoSort!= that.autoSort) {\n            return false;\n        }\n        if (this.maximumItemCount!= that.maximumItemCount) {\n            return false;\n        }\n        if (!this.data.equals(that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (!this.getClass().equals(that.getClass())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count!= that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), that.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    ",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (this.autoSort!= that.autoSort) {\n            return false;\n        }\n        if (this.maximumItemCount!= that.maximumItemCount) {\n            return false;\n        }\n        if (!this.data.equals(that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        ",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (!this.getClass().equals(that.getClass())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count!= that.getItemCount()) {\n            return false;\n        }\n        for (int i = 0; i < count; i++) {\n            if (!ObjectUtilities.equal(getDataItem(i), that.getDataItem(i))) {\n                return false;\n            }\n        }\n        return true;\n    ",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (!this.key.equals(that.key)) {\n            return false;\n        }\n        if (!this.getClass().equals(that.getClass())) {\n            return false;\n        }\n        int count = getItemCount();\n        if (count!= that.getItemCount()) {\n            return false;\n        }\n\n        for (int i = 0; i < count; i++) {\n            Number x1 = getX(i);\n            Number x2 = that.getX(i);\n            if (x1 == null) {\n                if (x2!= null)",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (this.maximumItemCount!= that.maximumItemCount) {\n            return false;\n        }\n        if (this.maximumItemAge!= that.maximumItemAge) {\n            return false;\n        }\n        if (!ObjectUtilities.equal(this.data, that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = (this.data!= null? this.data.hash",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (this.maximumItemCount!= that.maximumItemCount) {\n            return false;\n        }\n        if (this.maximumItemAge!= that.maximumItemAge) {\n            return false;\n        }\n        if (!this.data.equals(that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = this.data.hashCode();\n        result = 29 * result +",
        "public TimeSeries createCopy(int start, int end)\n        throws CloneNotSupportedException {\n    if (start < 0) {\n        throw new IllegalArgumentException(\"Requires start >= 0.\");\n    }\n    if (end < start) {\n        throw new IllegalArgumentException(\"Requires start <= end.\");\n    }\n    TimeSeries copy = (TimeSeries) super.clone();\n// buggy line:    copy.data = new java.util.ArrayList();\n    copy.data = new ArrayList();\n    for (int i = start; i <= end; i++) {\n        copy.data.add(this.data.get(i));\n    }\n    return copy;\n    }\n\n    /**\n     * Returns a clone of the time series.\n     *\n     * @return A clone.\n     *\n     * @throws CloneNotSupportedException  this class will not throw this\n     *         exception, but subclasses (if any) might.\n     */\n    public Object clone() throws CloneNotSupportedException {\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n\n    /**\n     * Tests this time series for equality with an arbitrary object.\n     *\n     * @param obj  the object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof TimeSeries)) {\n            return false;\n        }\n        TimeSeries that = (TimeSeries) obj;\n        if (this.maximumItemCount!= that.maximumItemCount) {\n            return false;\n        }\n        if (this.maximumItemAge!= that.maximumItemAge) {\n            return false;\n        }\n        if (!this.data.equals(that.data)) {\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Returns a hash code.\n     *\n     * @return A hash code.\n     */\n    public int hashCode() {\n        int result;\n        result = (this.data!= null? this.data.hashCode() :"
      ],
      "function range": "1048,5-1072,5"
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);",
      "output": [
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algeb",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algeb",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.al",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IO",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList other = (ShapeList) obj;\n    if (this.size()!= other.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(other.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IO",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.alge",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOpt",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.",
        "public boolean equals(Object obj) {\n    if (obj == this) {\n        return true;\n    }\n    if (!(obj instanceof ShapeList)) {\n        return false;\n    }\n// buggy line:    return super.equals(obj);\n    ShapeList that = (ShapeList) obj;\n    if (this.size()!= that.size()) {\n        return false;\n    }\n    for (int i = 0; i < this.size(); i++) {\n        if (!this.get(i).equals(that.get(i))) {\n            return false;\n        }\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache"
      ],
      "function range": "103,5-113,5"
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());",
      "output": [
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time.\n     *\n     * @return The date/time.\n     */\n    public Date getTime() {\n        return this.time;\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone.\n     */\n    public TimeZone getZone() {\n        return this.zone;\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale.\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this) {\n            return true;\n        }\n        if (!(obj instanceof Week)) {\n            return false;\n        }\n        Week that = (Week",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time.\n     *\n     * @return The date/time.\n     */\n    public Date getTime() {\n        return this.time;\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone.\n     */\n    public TimeZone getZone() {\n        return this.zone;\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale.\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Week)) {\n            return false;\n        }\n        Week that = (Week",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time.\n     *\n     * @return The date/time.\n     */\n    public Date getTime() {\n        return this.time;\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone.\n     */\n    public TimeZone getZone() {\n        return this.zone;\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale.\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n\n    /**\n     * Returns the first millisecond of the week.  This will be determined relative\n     * to the time zone specified in the constructor, or in the calendar instance\n     * if a different time zone was specified.\n     *\n     * @return The first millisecond of the week.\n     *\n     * @see #getLastMillisecond()\n     */\n    public long getFirstMillisecond() {\n        return this.firstMillisecond;\n",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time used to generate the time period.\n     *\n     * @return The date/time (never <code>null</code>).\n     */\n    public Date getTime() {\n        return (this.time!= null? (Date) this.time.clone() : null);\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone (never <code>null</code>).\n     */\n    public TimeZone getZone() {\n        return (this.zone!= null? (TimeZone) this.zone.clone() : null);\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale (never <code>null</code>).\n     */\n    public Locale getLocale() {\n        return (this.locale!= null? (Locale) this.locale.clone() : null);\n    }\n\n    /**\n     * Returns a string representing the week.\n     *\n     * @return The string.",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time used to generate the time period.\n     *\n     * @return The date/time (never <code>null</code>).\n     */\n    public Date getTime() {\n        return (this.time!= null? (Date) this.time.clone() : null);\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone (never <code>null</code>).\n     */\n    public TimeZone getZone() {\n        return (this.zone!= null? (TimeZone) this.zone.clone() : null);\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale (never <code>null</code>).\n     */\n    public Locale getLocale() {\n        return (this.locale!= null? (Locale) this.locale.clone() : null);\n    }\n\n    /**\n     * Returns the first millisecond of the week.  This will be determined relative\n     *",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time.\n     *\n     * @return The date/time.\n     */\n    public Date getTime() {\n        return this.time;\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone.\n     */\n    public TimeZone getZone() {\n        return this.zone;\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale.\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n\n    /**\n     * Returns the first millisecond of the week.  This will be determined relative\n     * to the time zone specified in the constructor, or in the calendar instance\n     * if one was specified.\n     *\n     * @return The first millisecond of the week.\n     *\n     * @see #getLastMillisecond()\n     */\n    public long getFirstMillisecond() {\n        return this.firstMillisecond;\n    }\n\n",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time used to generate the time period.\n     *\n     * @return The date/time (never <code>null</code>).\n     */\n    public Date getTime() {\n        return (this.time!= null? (Date) this.time.clone() : null);\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone (never <code>null</code>).\n     */\n    public TimeZone getZone() {\n        return (this.zone!= null? (TimeZone) this.zone.clone() : null);\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale (never <code>null</code>).\n     */\n    public Locale getLocale() {\n        return (this.locale!= null? (Locale) this.locale.clone() : null);\n    }\n\n    /**\n     * Returns a string representation of this object.\n     *\n     * @return A string",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time used to generate the time period.\n     *\n     * @return The date/time (never <code>null</code>).\n     */\n    public Date getTime() {\n        return (this.time!= null? (Date) this.time.clone() : null);\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone (never <code>null</code>).\n     */\n    public TimeZone getZone() {\n        return (this.zone!= null? (TimeZone) this.zone.clone() : null);\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale (never <code>null</code>).\n     */\n    public Locale getLocale() {\n        return (this.locale!= null? (Locale) this.locale.clone() : null);\n    }\n\n    /**\n     * Returns a string representation of the week.\n     *\n     * @return The string",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time.\n     *\n     * @return The date/time.\n     */\n    public Date getTime() {\n        return this.time;\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone.\n     */\n    public TimeZone getZone() {\n        return this.zone;\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale.\n     */\n    public Locale getLocale() {\n        return this.locale;\n    }\n\n    /**\n     * Tests this object for equality with an arbitrary object.\n     *\n     * @param obj  the other object (<code>null</code> permitted).\n     *\n     * @return A boolean.\n     */\n    public boolean equals(Object obj) {\n        if (this == obj) {\n            return true;\n        }\n        if (!(obj instanceof Week)) {\n            return false;\n        }\n        Week w = (Week",
        "public Week(Date time, TimeZone zone) {\n// buggy line:    this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault());\n        this(time, zone, Locale.getDefault());\n    }\n\n    /**\n     * Creates a new time period for the specified time and zone.\n     *\n     * @param time  the time (<code>null</code> not permitted).\n     * @param zone  the time zone (<code>null</code> not permitted).\n     * @param locale  the locale (<code>null</code> not permitted).\n     */\n    public Week(Date time, TimeZone zone, Locale locale) {\n        if (time == null) {\n            throw new IllegalArgumentException(\"Null 'time' argument.\");\n        }\n        if (zone == null) {\n            throw new IllegalArgumentException(\"Null 'zone' argument.\");\n        }\n        if (locale == null) {\n            throw new IllegalArgumentException(\"Null 'locale' argument.\");\n        }\n        this.time = time;\n        this.zone = zone;\n        this.locale = locale;\n    }\n\n    /**\n     * Returns the date/time used to generate the time period.\n     *\n     * @return The date/time (never <code>null</code>).\n     */\n    public Date getTime() {\n        return (this.time!= null? (Date) this.time.clone() : null);\n    }\n\n    /**\n     * Returns the time zone.\n     *\n     * @return The time zone (never <code>null</code>).\n     */\n    public TimeZone getZone() {\n        return (this.zone!= null? (TimeZone) this.zone.clone() : null);\n    }\n\n    /**\n     * Returns the locale.\n     *\n     * @return The locale (never <code>null</code>).\n     */\n    public Locale getLocale() {\n        return (this.locale!= null? (Locale) this.locale.clone() : null);\n    }\n\n    /**\n     * Returns the first millisecond of the time period.  This will be\n     * determined"
      ],
      "function range": "173,5-176,5"
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null 'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {",
      "output": [
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n//",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeries copy = new TimeSeries(",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (startIndex > endIndex) {\n        emptyRange = true;\n    }\n    if (emptyRange) {\n        return new",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(getTimePeriodClass());\n    }\n    TimeSeriesDataItem[] copied",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(start, end);\n    }\n    TimeSeriesDataItem[] copyItems =",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(getTimePeriodClass());\n    }\n    TimeSeries copy = new Time",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (startIndex > endIndex) {\n        emptyRange = true;\n    }\n    TimeSeries copy = new TimeSeries(getKey",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        return new EmptyTimeSeries(getTimePeriodClass());\n    }\n    TimeSeriesDataItem[] copy",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end)\n    throws CloneNotSupportedException {\n    if (start == null) {\n        throw new IllegalArgumentException(\"Null'start' argument.\");\n    }\n    if (end == null) {\n        throw new IllegalArgumentException(\"Null 'end' argument.\");\n    }\n    if (start.compareTo(end) > 0) {\n        throw new IllegalArgumentException(\n                \"Requires start on or before end.\");\n    }\n    boolean emptyRange = false;\n    int startIndex = getIndex(start);\n    if (startIndex < 0) {\n        startIndex = -(startIndex + 1);\n        if (startIndex == this.data.size()) {\n            emptyRange = true;  \n        }\n    }\n    int endIndex = getIndex(end);\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (endIndex < 0) {             \n        endIndex = -(endIndex + 1); \n        endIndex = endIndex - 1;    \n    }\n// buggy line:    if (endIndex < 0) {             \n// buggy line:        endIndex = -(endIndex + 1); \n// buggy line:        endIndex = endIndex - 1;    \n// buggy line:    }\n    if (emptyRange) {\n        endIndex = startIndex;\n    }\n    TimeSeries copy = new TimeSeries(this.data."
      ],
      "function range": "918,5-956,5"
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText",
      "output": [
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.h",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator",
        "public String generateToolTipFragment(String toolTipText) {\n// buggy line:    return \" title=\\\"\" + toolTipText + \"\\\"\";\n        return \" title=\\\"\" + toolTipText + \"\\\"\";\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express"
      ],
      "function range": "64,5-67,5"
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);",
      "output": [
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (iterator2.isDone() &&!iterator1.isDone()) {\n        return false;\n    }\n    return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return (p2 == null);\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule()!= p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n// buggy line:    PathIterator iterator2 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] d1 = new double[6];\n    double[] d2 = new double[6];\n    while (!iterator1.isDone() &&!iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(d1);\n        int seg2 = iterator2.currentSegment(d2);\n        if (seg1!= seg2) {\n            return false;\n        }\n        for (int i = 0; i < d1.length; i++) {\n            if (d1[i]!= d2[i]) {\n                return false;\n            }\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    if (iterator1.isDone() &&!iterator2.isDone()) {\n        return false;\n    }\n    if (!iterator1.isDone() && iterator2.isDone()) {\n        return false;\n    }\n    return true;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on"
      ],
      "function range": "264,5-296,5"
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;",
      "output": [
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    if (info!= null) {\n      info.setPlotArea(area);\n    }\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (this.dataset == null) {\n      drawNoDataMessage(g2, area);\n      return;\n    }\n\n    int pieCount = 0;\n    if (this.dataset instanceof PieDataset) {\n      pieCount = ((PieDataset) this.dataset).getItemCount();\n    }\n    else if (this.dataset instanceof DefaultPieDataset) {\n      pieCount = ((DefaultPieDataset) this.dataset).getItemCount();\n    }\n",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    if (info!= null) {\n      info.setPlotArea(area);\n    }\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (this.dataset == null) {\n      drawNoDataMessage(g2, area);\n      return;\n    }\n\n    int pieCount = 0;\n    if (this.dataset instanceof PieDataset) {\n      pieCount = ((PieDataset) this.dataset).getItemCount();\n    }\n    else if (this.dataset instanceof MultiplePieDataset) {\n      MultiplePieDataset mpd = (MultiplePieDataset) this.dataset;\n      int",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    if (info!= null) {\n      info.setPlotArea(area);\n    }\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (this.dataset == null) {\n      drawNoDataMessage(g2, area);\n      return;\n    }\n\n    int pieCount = 0;\n    if (this.dataset instanceof PieDataset) {\n      pieCount = ((PieDataset) this.dataset).getItemCount();\n    }\n    else if (this.dataset instanceof DefaultPieDataset) {\n      pieCount = ((DefaultPieDataset) this.dataset).getItemCount();\n    }\n\n",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects info about the drawing.\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n      getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemRenderer renderer = getRenderer();\n      ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects information about the drawing.\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n      getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemRenderer renderer = getRenderer();\n      ",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n      getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemR",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects info about the drawing.\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n                                               getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemRenderer renderer = getRend",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n            getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemR",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    if (info!= null) {\n      info.setPlotArea(area);\n    }\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (this.dataset == null) {\n      drawNoDataMessage(g2, area);\n      return;\n    }\n\n    int pieCount = 0;\n    if (this.dataset instanceof PieDataset) {\n      pieCount = ((PieDataset) this.dataset).getItemCount();\n    }\n    else if (this.dataset instanceof MultiplePieDataset) {\n      MultiplePieDataset mpd = (MultiplePieDataset) this.dataset;\n      pie",
        "public MultiplePiePlot(CategoryDataset dataset) {\n    super();\n// buggy line:    this.dataset = dataset;\n    this.dataset = dataset;\n  }\n\n  /**\n   * Returns the dataset.\n   *\n   * @return The dataset (possibly <code>null</code>).\n   */\n  public CategoryDataset getDataset() {\n    return this.dataset;\n  }\n\n  /**\n   * Sets the dataset.\n   *\n   * @param dataset  the dataset (<code>null</code> permitted).\n   */\n  public void setDataset(CategoryDataset dataset) {\n    this.dataset = dataset;\n  }\n\n  /**\n   * Draws the plot on a Java 2D graphics device (such as the screen or a\n   * printer).\n   *\n   * @param g2  the graphics device.\n   * @param area  the area within which the plot should be drawn.\n   * @param anchor  the anchor point (<code>null</code> permitted).\n   * @param parentState  the state from the parent plot, if there is one.\n   * @param info  collects chart drawing information (<code>null</code>\n   *              permitted).\n   */\n  public void draw(Graphics2D g2, Rectangle2D area, Point2D anchor,\n                   PlotState parentState,\n                   PlotRenderingInfo info) {\n\n    // adjust for insets...\n    RectangleInsets insets = getInsets();\n    insets.trim(area);\n\n    if (info!= null) {\n      info.setPlotArea(area);\n      info.setDataArea(area);\n    }\n\n    drawBackground(g2, area);\n    drawOutline(g2, area);\n\n    Shape savedClip = g2.getClip();\n    g2.clip(area);\n\n    Composite originalComposite = g2.getComposite();\n    g2.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER,\n      getForegroundAlpha()));\n\n    if (this.dataset!= null) {\n      CategoryItemR"
      ],
      "function range": "143,5-158,5"
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock != null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock != null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock != null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock != null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),",
      "output": [
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                new Range(constraint.getWidth() - w",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                new Range(0.0, constraint.getWidth()",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]), \n                new Range(constraint.getWidth() -",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                new Range(0.0, w[0] -",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                        new Range(constraint.getWidth() - w",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                constraint.getWidth() - w[2],",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                new Range(w[2], constraint.getWidth()",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                        new Range(0.0, constraint.getWidth()",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]), \n                new Range(0.0, constraint.getWidth",
        "protected Size2D arrangeFF(BlockContainer container, Graphics2D g2,\n                           RectangleConstraint constraint) {\n    double[] w = new double[5];\n    double[] h = new double[5];\n    w[0] = constraint.getWidth();\n    if (this.topBlock!= null) {\n        RectangleConstraint c1 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0,\n                new Range(0.0, constraint.getHeight()),\n                LengthConstraintType.RANGE);\n        Size2D size = this.topBlock.arrange(g2, c1);\n        h[0] = size.height;\n    }\n    w[1] = w[0];\n    if (this.bottomBlock!= null) {\n        RectangleConstraint c2 = new RectangleConstraint(w[0], null,\n                LengthConstraintType.FIXED, 0.0, new Range(0.0,\n                constraint.getHeight() - h[0]), LengthConstraintType.RANGE);\n        Size2D size = this.bottomBlock.arrange(g2, c2);\n        h[1] = size.height;\n    }\n    h[2] = constraint.getHeight() - h[1] - h[0];\n    if (this.leftBlock!= null) {\n        RectangleConstraint c3 = new RectangleConstraint(0.0,\n                new Range(0.0, constraint.getWidth()),\n                LengthConstraintType.RANGE, h[2], null,\n                LengthConstraintType.FIXED);\n        Size2D size = this.leftBlock.arrange(g2, c3);\n        w[2] = size.width;\n    }\n    h[3] = h[2];\n    if (this.rightBlock!= null) {\n        RectangleConstraint c4 = new RectangleConstraint(0.0,\n// buggy line:                new Range(0.0, constraint.getWidth() - w[2]),\n                                                           new Range("
      ],
      "function range": "422,5-489,5"
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);",
      "output": [
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.al",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\n",
        "public Object clone() throws CloneNotSupportedException {\n// buggy line:    Object clone = createCopy(0, getItemCount() - 1);\n        Object clone = createCopy(0, getItemCount() - 1);\n        return clone;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUn"
      ],
      "function range": "856,5-859,5"
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);",
      "output": [
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;\n    }\n\n    /**",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the outline paint.\n     */\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint;\n    }\n\n    ",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n     */\n    public Paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint.\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint.\n     */\n    public void setPaint(Paint paint) {\n        this.paint = paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke.\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke.\n     */\n    public void setStroke(Stroke stroke) {\n        this.stroke = stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint.\n     */\n    public Paint getOutlinePaint() {\n        return this.outlinePaint;\n    }\n\n    /**\n     * Sets the outline paint.\n     *\n     * @param paint  the outline paint.\n     */\n    public void setOutlinePaint(Paint paint) {\n        this.outlinePaint = paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke and sends a {@link MarkerChangeEvent} to all registered\n     * listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n        notifyListeners(new MarkerChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (never <code>null</code>).\n     */\n    public Paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (never <code>null</code>).\n     */\n    public Paint",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke, alpha);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n    }\n\n    /**\n     * Returns the value.\n     *\n     * @return The value.\n     */\n    public double getValue() {\n        return this.value;\n    }\n\n    /**\n     * Sets the value.\n     *\n     * @param value  the value.\n     */\n    public void setValue(double value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n",
        "public ValueMarker(double value, Paint paint, Stroke stroke, \n                   Paint outlinePaint, Stroke outlineStroke, float alpha) {\n// buggy line:    super(paint, stroke, paint, stroke, alpha);\n        super(paint, stroke);\n        this.value = value;\n        this.paint = paint;\n        this.stroke = stroke;\n        this.outlinePaint = outlinePaint;\n        this.outlineStroke = outlineStroke;\n        this.alpha = alpha;\n    }\n\n    /**\n     * Returns the paint.\n     *\n     * @return The paint (never <code>null</code>).\n     */\n    public Paint getPaint() {\n        return this.paint;\n    }\n\n    /**\n     * Sets the paint and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param paint  the paint (<code>null</code> not permitted).\n     */\n    public void setPaint(Paint paint) {\n        if (paint == null) {\n            throw new IllegalArgumentException(\"Null 'paint' argument.\");\n        }\n        this.paint = paint;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the stroke.\n     *\n     * @return The stroke (never <code>null</code>).\n     */\n    public Stroke getStroke() {\n        return this.stroke;\n    }\n\n    /**\n     * Sets the stroke and sends a {@link RendererChangeEvent} to all\n     * registered listeners.\n     *\n     * @param stroke  the stroke (<code>null</code> not permitted).\n     */\n    public void setStroke(Stroke stroke) {\n        if (stroke == null) {\n            throw new IllegalArgumentException(\"Null'stroke' argument.\");\n        }\n        this.stroke = stroke;\n        notifyListeners(new RendererChangeEvent(this));\n    }\n\n    /**\n     * Returns the outline paint.\n     *\n     * @return The outline paint (possibly <code>null</code>).\n"
      ],
      "function range": "93,5-97,5"
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound ",
      "output": [
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelTest extends ContextTest",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTest",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecipientListTest extends ContextTest",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelUseOriginalInBody",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to verify that error",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to verify that red",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to verify that the",
        "public Paint getPaint(double value) {\n    double v = Math.max(value, this.lowerBound);\n    v = Math.min(v, this.upperBound);\n// buggy line:    int g = (int) ((value - this.lowerBound) / (this.upperBound \n// - this.lowerBound) * 255);\n    int g = (int) ((v - this.lowerBound) / (this.upperBound - this.lowerBound) * 255);\n    return new Color(g, g, g);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to verify that headers"
      ],
      "function range": "123,5-129,5"
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();",
      "output": [
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyr",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String)iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String)iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.h",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.al",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.Algebricks",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks",
        "private void checkRequiredOptions()\n    throws MissingOptionException\n{\n    if (requiredOptions.size() > 0)\n    {\n        Iterator iter = requiredOptions.iterator();\n// buggy line:        StringBuffer buff = new StringBuffer();\n// buggy line:        while (iter.hasNext())\n// buggy line:        {\n// buggy line:            String option = (String) iter.next();\n// buggy line:            buff.append(option);\n// buggy line:            if (iter.hasNext())\n// buggy line:            {\n// buggy line:                buff.append(\", \");\n// buggy line:            }\n// buggy line:        }\n// buggy line:        throw new MissingOptionException(buff.toString());\n        while (iter.hasNext())\n        {\n            String option = (String) iter.next();\n            throw new MissingOptionException(option);\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache"
      ],
      "function range": "290,5-309,5"
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text,",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, nextLineTabStop);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = find",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n\n}\n<",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n}\n<|",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        sb.append(rtrim(text",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n\nprotected String createP",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n\nprivate String createP",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n\n/**\n * R",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    final String padding = createPadding(nextLineTabStop);\n    while (true)\n    {\n        text = padding + text.substring(pos).trim();\n// buggy line:        pos = findWrapPos(text, width, nextLineTabStop);\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n        pos = findWrapPos(text, width, 0);\n        if (pos == -1)\n        {\n            sb.append(rtrim(text));\n            return sb;\n        }\n        sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n        text = text.substring(pos).trim();\n        if (text.length() == 0)\n        {\n            return sb;\n        }\n    }\n}\n\n/**\n * Find"
      ],
      "function range": "792,5-823,5"
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt() != null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName() != null))",
      "output": [
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.al",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.",
        "private static void appendOption(final StringBuffer buff, \n                                 final Option option, \n                                 final boolean required)\n{\n    if (!required)\n    {\n        buff.append(\"[\");\n    }\n    if (option.getOpt()!= null)\n    {\n        buff.append(\"-\").append(option.getOpt());\n    }\n    else\n    {\n        buff.append(\"--\").append(option.getLongOpt());\n    }\n// buggy line:    if (option.hasArg() && (option.getArgName()!= null))\n// buggy line:    {\n// buggy line:        buff.append(\" <\").append(option.getArgName()).append(\">\");\n// buggy line:    }\n    if (option.hasArg() && (option.getArgName()!= null))\n    {\n        buff.append(\" <\").append(option.getArgName()).append(\">\");\n    }\n    if (!required)\n    {\n        buff.append(\"]\");\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRow"
      ],
      "function range": "613,5-642,5"
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\n",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules.subplan;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyr",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \n// buggy line:                                        \"- no room for the description\");\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n    else\n    {\n        return renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Preconditions;\nimport com.google.common.primitives"
      ],
      "function range": "809,5-852,5"
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.al",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, \n                                         int nextLineTabStop, String text)\n{\n    int pos = findWrapPos(text, width, 0);\n    if (pos == -1)\n    {\n        sb.append(rtrim(text));\n        return sb;\n    }\n    sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine);\n    if (nextLineTabStop >= width)\n    {\n// buggy line:        nextLineTabStop = width - 1;\n        nextLineTabStop = width;\n    }\n    renderWrappedText(sb, width, nextLineTabStop, text.substring(pos));\n    return sb;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\n"
      ],
      "function range": "809,5-851,5"
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;",
      "output": [
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\n",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules.subplan;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.classification.Interface",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport java.io.IOException;\n\nimport org.apache.hadoop.classification.InterfaceAudience;\nimport org.apache.hadoop.hdfs.",
        "protected void processProperties(Properties properties)\n{\n    if (properties == null)\n    {\n        return;\n    }\n    for (Enumeration e = properties.propertyNames(); e.hasMoreElements();)\n    {\n        String option = e.nextElement().toString();\n        if (!cmd.hasOption(option))\n        {\n            Option opt = getOptions().getOption(option);\n            String value = properties.getProperty(option);\n            if (opt.hasArg())\n            {\n                if (opt.getValues() == null || opt.getValues().length == 0)\n                {\n                    try\n                    {\n                        opt.addValueForProcessing(value);\n                    }\n                    catch (RuntimeException exp)\n                    {\n                    }\n                }\n            }\n            else if (!(\"yes\".equalsIgnoreCase(value)\n                    || \"true\".equalsIgnoreCase(value)\n                    || \"1\".equalsIgnoreCase(value)))\n            {\n// buggy line:                break;\n            }\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.hadoop.hdfs.server.namenode;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\nimport java.io.IOException;\nimport"
      ],
      "function range": "252,5-296,5"
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ')\n            && (c != '\\n') && (c != '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ')\n// buggy line:           && (c != '\\n') && (c != '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        ",
      "output": [
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  ",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    else\n    {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www",
        "protected int findWrapPos(String text, int width, int startPos)\n{\n    int pos;\n    if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width)\n            || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width))\n    {\n        return pos + 1;\n    }\n    else if (startPos + width >= text.length())\n    {\n        return -1;\n    }\n    pos = startPos + width;\n    char c;\n    while ((pos >= startPos) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        --pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    pos = startPos + width;\n// buggy line:    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n// buggy line:           && (c!= '\\n') && (c!= '\\r'))\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }        \n// buggy line:    if (pos <= text.length())\n// buggy line:    {\n// buggy line:        ++pos;\n// buggy line:    }\n    while ((pos <= text.length()) && ((c = text.charAt(pos))!='')\n            && (c!= '\\n') && (c!= '\\r'))\n    {\n        ++pos;\n    }\n    if (pos > startPos)\n    {\n        return pos;\n    }\n    return -1;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *     "
      ],
      "function range": "902,5-943,5"
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;",
      "output": [
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == null)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == null)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == null)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == null)\n    ",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str) throws ParseException\n",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return (T) createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return (T) createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createNumber(final String str)\n{\n    return",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number num) throws ParseException\n",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number num) throws Par",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number number) throws ParseException\n",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Object obj) throws ParseException\n{\n    return createValue(obj.toString(), (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final Number number) throws Par",
        "@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str, final Class<T> clazz) throws ParseException\n{\n    if (PatternOptionBuilder.STRING_VALUE == clazz)\n    {\n        return (T) str;\n    }\n    else if (PatternOptionBuilder.OBJECT_VALUE == clazz)\n    {\n        return (T) createObject(str);\n    }\n    else if (PatternOptionBuilder.NUMBER_VALUE == clazz)\n    {\n        return (T) createNumber(str);\n    }\n    else if (PatternOptionBuilder.DATE_VALUE == clazz)\n    {\n        return (T) createDate(str);\n    }\n    else if (PatternOptionBuilder.CLASS_VALUE == clazz)\n    {\n        return (T) createClass(str);\n    }\n    else if (PatternOptionBuilder.FILE_VALUE == clazz)\n    {\n        return (T) createFile(str);\n    }\n    else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz)\n    {\n        return (T) openFile(str);\n    }\n    else if (PatternOptionBuilder.FILES_VALUE == clazz)\n    {\n        return (T) createFiles(str);\n    }\n    else if (PatternOptionBuilder.URL_VALUE == clazz)\n    {\n        return (T) createURL(str);\n    }\n    else\n    {\n// buggy line:        return null;\n        return null;\n    }\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createValue(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.STRING_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createObject(final String str) throws ParseException\n{\n    return createValue(str, (Class<T>) PatternOptionBuilder.OBJECT_VALUE);\n}\n\n@SuppressWarnings(\"unchecked\") \npublic static <T> T createDate(final String str) throws ParseException\n"
      ],
      "function range": "62,5-105,5"
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "private void removeUnreferencedFunctionArgs(Scope fnScope) {",
      "output": [
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent().getParent());\n      }\n      arg = next;",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      }\n      arg = next;\n    }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent());\n      }\n      arg = next;\n    }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent().getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next);\n      }\n      arg = next;\n    }\n  }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node args = function.getSecondChild();\n    Preconditions.checkNotNull(args);\n    Preconditions.checkState(args.isParamList());\n\n    Node body = function.getLastChild();\n    Preconditions.checkNotNull(body);\n    Preconditions.checkState(body.isNormalBlock());\n\n    Node arg = args.getFirstChild();\n    while (arg!= null) {\n      Preconditions.checkNotNull(arg);\n      Preconditions.checkNotNull(arg.getParent());\n      Node next = arg.getNext();\n      if (arg.getParent().isVar() &&!arg.isVarArgs()) {\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().isCall());\n        Preconditions.checkState(next.getParent().getParent().getParent().getLastChild() == next.getParent());\n      } else {\n        Preconditions.checkState(arg.getParent().isExprResult());\n        Preconditions.checkState(arg.getParent().getParent().isCall());\n        Preconditions.checkNotNull(next);\n        Preconditions.checkNotNull(next.getParent());\n        Preconditions.checkNotNull(next.getParent().getParent());\n        Preconditions.checkNotNull(next.getParent().getParent().getParent());\n        Preconditions.checkState(next.getParent().getParent().getParent().isExprResult());\n        Preconditions.checkState(next.getParent().getParent().getParent().getParent() == next.getParent().getParent());\n        Preconditions.checkState("
      ],
      "function range": "369,3-406,3"
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }",
      "output": [
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Precond",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"describe\"));\n  Preconditions",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  return ret",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions.checkState(validProperties.contains(\"afterAll\"));\n  Preconditions.checkState(validProperties.contains(\"describe\"));\n  Pre",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"test\"));\n  return ret;\n",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"setup\"));\n  Preconditions.checkState(validProperties.contains(\"teardown\"));\n  Preconditions.checkState(validProperties.contains(\"before\"));\n  Preconditions.checkState(validProperties.contains(\"after\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  return true",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"initialize\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"runTest\"));\n  Preconditions.checkState(validProperties.contains(\"shouldRunTests\")",
        "private boolean isInlinableObject(List<Reference> refs) {\n  boolean ret = false;\n  Set<String> validProperties = Sets.newHashSet();\n  for (Reference ref : refs) {\n    Node name = ref.getNode();\n    Node parent = ref.getParent();\n    Node gramps = ref.getGrandparent();\n    if (parent.isGetProp()) {\n      Preconditions.checkState(parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getString());\n    } else if (gramps.isGetProp()) {\n      Preconditions.checkState(gramps.getFirstChild() == name);\n      validProperties.add(gramps.getString());\n    } else {\n      Preconditions.checkState(parent.isAssign() && parent.getFirstChild() == name);\n      if (gramps.isCall()\n          && gramps.getFirstChild() == parent) {\n        return false;\n      }\n      validProperties.add(parent.getFirstChild().getQualifiedName());\n    }\n  }\n  Preconditions.checkState(validProperties.contains(\"exports\"));\n  Preconditions.checkState(validProperties.contains(\"module\"));\n  Preconditions.checkState(validProperties.contains(\"require\"));\n  Preconditions.checkState(validProperties.contains(\"setUp\"));\n  Preconditions.checkState(validProperties.contains(\"tearDown\"));\n  Preconditions.checkState(validProperties.contains(\"it\"));\n  Preconditions.checkState(validProperties.contains(\"beforeEach\"));\n  Preconditions.checkState(validProperties.contains(\"afterEach\"));\n  Preconditions.checkState(validProperties.contains(\"beforeAll\"));\n  Preconditions.checkState(validProperties.contains(\"afterAll\"));\n  Preconditions.checkState(validProperties.contains(\"test\"));\n  return ret"
      ],
      "function range": "155,5-253,5"
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);",
      "output": [
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.getParent())) {\n      int type",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.getParent())) {\n      int",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.getParent())) {\n      int type",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToBack(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.getParent())) {\n      int type",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    outer: while (null!= (ancestor = ancestor.getParent())) {\n      ",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n      compiler.reportCodeChange();\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n\n    loop: while (null!= (ancestor = ancestor.getParent())) {\n      ",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    boolean rootFound = false;\n    while (ancestor.getParent()!= null",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    boolean rootFound = false;\n    while (null!= (ancestor = ancestor.",
        "static boolean mayBeString(Node n, boolean recurse) {\n  if (recurse) {\n// buggy line:    return allResultsMatch(n, MAY_BE_STRING_PREDICATE);\n    return allResultsMatch(n, new Predicate<Node>() {\n      @Override\n      public boolean apply(Node input) {\n        return input.getType() == Token.STRING;\n      }\n    });\n  } else {\n    return n.getType() == Token.STRING;\n  }\n}\n\n  /**\n   * Given a node tree, finds all the VAR declarations in that tree that are\n   * not in an inner scope. Then adds a new VAR node at the top of the current\n   * scope that redeclares them, if necessary.\n   */\n  static void redeclareVarsInsideBranch(Node branch) {\n    Collection<Node> vars = getVarsDeclaredInBranch(branch);\n    if (vars.isEmpty()) {\n      return;\n    }\n\n    Node parent = getAddingRoot(branch);\n    for (Node nameNode : vars) {\n      Node var = IR.var(\n          IR.name(nameNode.getString())\n             .srcref(nameNode))\n         .srcref(nameNode);\n      copyNameAnnotations(nameNode, var.getFirstChild());\n      parent.addChildToFront(var);\n    }\n  }\n\n  /**\n   * Copy any annotations that follow a named value.\n   * @param source\n   * @param destination\n   */\n  static void copyNameAnnotations(Node source, Node destination) {\n    if (source.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n      destination.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n    }\n  }\n\n  /**\n   * Gets a Node at the top of the current scope where we can add new var\n   * declarations as children.\n   */\n  private static Node getAddingRoot(Node n) {\n    Node addingRoot = null;\n    Node ancestor = n;\n    while (null!= (ancestor = ancestor.getParent())) {\n     int type"
      ],
      "function range": "1415,3-1421,3"
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType() != null && parent.isAssign()) {\n// buggy line:    return;",
      "output": [
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArrayType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum element\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArray()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArray()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum\");\n// buggy line:  ",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isAllType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"type\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnum()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isAllType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"type\");\n// buggy line:  ",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArray()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum element\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum element\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isObject()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"object\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"enum\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isAllType()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"all\");\n// buggy line:",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArray()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"EnumElement\");\n// buggy line",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n  Node property = n.getLastChild();\n  Node objNode = n.getFirstChild();\n  JSType childType = getJSType(objNode);\n  if (childType.isDict()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isStruct()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"struct\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isUnion()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"union\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isInterface()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"interface\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isArray()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"array\");\n// buggy line:  } else if (n.getJSType()!= null && parent.isAssign()) {\n// buggy line:    return;\n    return;\n  } else if (childType.isEnumElement()) {\n    report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\",\n        \"enum element\");\n// buggy"
      ],
      "function range": "1303,3-1321,3"
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }",
      "output": [
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\n",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.al",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyr",
        "@Override\npublic boolean apply(Node n) {\n  if (n == null) {\n    return false;\n  }\n  if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n    return true;\n  }\n  if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n    return true;\n  }\n  for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) {\n    if (apply(c)) {\n      return true;\n    }\n  }\n  return false;\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache."
      ],
      "function range": "83,7-109,7"
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.clearAst();\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    ",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependency",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {\n// buggy line:    if (options.dependencyOptions.needsManagement()) {",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.setIsExtern(false);\n      }\n      staleInputs = true;\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        input.clearAst();\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        if (",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    hoistExterns(externsRoot);\n    boolean staleInputs = false;\n// buggy line:    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n    if (options.dependencyOptions.needsManagement() && options.closurePass) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        if (staleInputs) {\n"
      ],
      "function range": "1240,3-1362,3"
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value != null) {",
      "output": [
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Replace the EXPR_RESULT node with",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node that is not the direct child of\n * an EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryReplaceRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isEx",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryReplaceRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Precond",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the dead EXPR_RESULT node",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult2(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Precond",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node that is not the direct child of\n * an EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n  Preconditions",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of\n * an EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Replace the EXPR_RESULT node with",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that's a direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the dead EXPR_RESULT node.",
        "private Node tryFoldSimpleFunctionCall(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node callTarget = n.getFirstChild();\n  if (callTarget!= null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n    Node value = callTarget.getNext();\n// buggy line:    if (value!= null) {\n    if (value!= null && value.isFunction()) {\n      return tryFoldStringConcat(n, value);\n    }\n  }\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node parent = n.getParent();\n  Preconditions.checkArgument(parent.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Remove the parent EXPR_RESULT node.\n  parent.detachFromParent();\n\n  // Remove the dead EXPR_RESULT node.\n  child.detachFromParent();\n\n  // Replace the EXPR_RESULT node with its first operand.\n  n.replaceWith(child.getFirstChild());\n\n  reportCodeChange();\n  return n;\n}\n\n/**\n * Try to remove an EXPR_RESULT node containing an\n * EXPR_RESULT node that is not the direct child of an\n * EXPR_RESULT node.\n *\n * @return the replacement for n or the original if no replacement was\n *   possible.\n */\nprivate Node tryRemoveRedundantExprResult(Node n, Node parent) {\n  Preconditions.checkArgument(n.isExprResult());\n\n  Node child = n.getFirstChild();\n  Preconditions.checkArgument(child.isExprResult());\n\n  // Replace the EX"
      ],
      "function range": "208,3-230,3"
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "Node parseInputs() {\n  boolean devMode = options.devMode != DevMode.OFF;\n  if (externsRoot != null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot != null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:        !options.skipAllPasses &&",
      "output": [
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (hasErrors()) {\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        if (devMode) {\n          runValidityCheck();\n        }\n        if (staleInputs) {",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n        phaseOptimizer == null) {\n      phaseOptimizer = new PhaseOptimizer(this, tracker);\n      addChangeHandler(phaseOptimizer.getCodeChangeHandler());\n      staleInputs = true;\n    }\n    if (options.devMode == DevMode.START_AND_END) {\n      runValidityCheck();\n      if (hasErrors()) {\n        return null;\n      }\n    }\n    hotSwapScript(staleInputs);\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    ",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n      }\n    }\n    if (!staleInputs) {",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n        phaseOptimizer == null) {\n      phaseOptimizer = new PhaseOptimizer(this, tracker);\n      addChangeHandler(phaseOptimizer.getCodeChangeHandler());\n      staleInputs = true;\n    }\n    if (options.devMode == DevMode.START_AND_END) {\n      runSanityCheck();\n      if (hasErrors()) {\n        return null;\n      }\n    }\n    hotSwapScript(staleInputs);\n    if (hasErrors()) {\n      return null;\n    }\n    return externAndJsRoot;\n  } finally {\n    stopTracer(tracer",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n    }\n    if (hasErrors())",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n      }\n    }\n    if (staleInputs",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    }\n",
        "Node parseInputs() {\n  boolean devMode = options.devMode!= DevMode.OFF;\n  if (externsRoot!= null) {\n    externsRoot.detachChildren();\n  }\n  if (jsRoot!= null) {\n    jsRoot.detachChildren();\n  }\n  jsRoot = IR.block();\n  jsRoot.setIsSyntheticBlock(true);\n  externsRoot = IR.block();\n  externsRoot.setIsSyntheticBlock(true);\n  externAndJsRoot = IR.block(externsRoot, jsRoot);\n  externAndJsRoot.setIsSyntheticBlock(true);\n  if (options.tracer.isOn()) {\n    tracker = new PerformanceTracker(jsRoot, options.tracer);\n    addChangeHandler(tracker.getCodeChangeHandler());\n  }\n  Tracer tracer = newTracer(\"parseInputs\");\n  try {\n    for (CompilerInput input : externs) {\n      Node n = input.getAstRoot(this);\n      if (hasErrors()) {\n        return null;\n      }\n      externsRoot.addChildToBack(n);\n    }\n    if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n      processAMDAndCommonJSModules();\n    }\n    boolean staleInputs = false;\n    if (options.dependencyOptions.needsManagement() &&\n// buggy line:       !options.skipAllPasses &&\n       !options.onlyClosureDependencies) {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        jsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n    } else {\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (hasErrors()) {\n          return null;\n        }\n        externsRoot.addChildToBack(n);\n        staleInputs = true;\n      }\n      "
      ],
      "function range": "1236,3-1387,3"
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "@Override\npublic void matchConstraint(ObjectType constraintObj) {",
      "output": [
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyr",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.al",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.al",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;\nimport org.apache.hyracks.algeb",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Agg",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.In",
        "@Override\npublic void matchConstraint(ObjectType constraintObj) {\n\t// TODO Auto-generated method stub\n\t\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AggregateOperator;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "554,3-580,3"
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj != null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType != null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }",
      "output": [
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(\n              prop, typeToInfer, null);\n        }\n      }\n    }\n  ",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(\n              prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null && constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE)\n                   .getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n}\n<|",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n}\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj!= null) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer =\n                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(\n              prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n}\n",
        "private void inferPropertyTypesToMatchConstraint(\n    JSType type, JSType constraint) {\n  if (type == null || constraint == null) {\n    return;\n  }\n  ObjectType constraintObj =\n      ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n// buggy line:  if (constraintObj!= null && constraintObj.isRecordType()) {\n// buggy line:    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n// buggy line:    if (objType!= null) {\n// buggy line:      for (String prop : constraintObj.getOwnPropertyNames()) {\n// buggy line:        JSType propType = constraintObj.getPropertyType(prop);\n// buggy line:        if (!objType.isPropertyTypeDeclared(prop)) {\n// buggy line:          JSType typeToInfer = propType;\n// buggy line:          if (!objType.hasProperty(prop)) {\n// buggy line:            typeToInfer =\n// buggy line:                getNativeType(VOID_TYPE).getLeastSupertype(propType);\n// buggy line:          }\n// buggy line:          objType.defineInferredProperty(prop, typeToInfer, null);\n// buggy line:        }\n// buggy line:      }\n// buggy line:    }\n// buggy line:  }\n  if (constraintObj.isRecordType()) {\n    ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n    if (objType!= null) {\n      for (String prop : constraintObj.getOwnPropertyNames()) {\n        JSType propType = constraintObj.getPropertyType(prop);\n        if (!objType.isPropertyTypeDeclared(prop)) {\n          JSType typeToInfer = propType;\n          if (!objType.hasProperty(prop)) {\n            typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType);\n          }\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n}\n<|"
      ],
      "function range": "1113,3-1137,3"
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      || !isValidInitialization(initialization)\n      || !isValidReference(reference)) {\n    return false;\n  }\n  if (declaration != initialization &&\n      !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock() != initialization.getBasicBlock()\n      || declaration.getBasicBlock() != reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value != null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship != null) {\n        return false;\n      }\n// buggy line:    }",
      "output": [
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being read or read values",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return!NodeUtil.isImmutableValue(value);\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being read or read values that are modified.\n   */\n  private",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return!NodeUtil.isImmutableValue(value)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being read or read values that are",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being moved.\n   ",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that reads or\n   * writes that state.\n   */",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return!NodeUtil.isImmutableValue(value);\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being moved.\n   */\n  private boolean canMoveModerately",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return!NodeUtil.isImmutableValue(value)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * the value being moved.\n   */\n",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that can modify\n   * the value being read or read values",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that side-effects\n   * the value being moved.\n",
        "private boolean canInline(\n    Reference declaration,\n    Reference initialization,\n    Reference reference) {\n  if (!isValidDeclaration(declaration)\n      ||!isValidInitialization(initialization)\n      ||!isValidReference(reference)) {\n    return false;\n  }\n  if (declaration!= initialization &&\n     !initialization.getGrandparent().isExprResult()) {\n    return false;\n  }\n  if (declaration.getBasicBlock()!= initialization.getBasicBlock()\n      || declaration.getBasicBlock()!= reference.getBasicBlock()) {\n    return false;\n  }\n  Node value = initialization.getAssignedValue();\n  Preconditions.checkState(value!= null);\n  if (value.isGetProp()\n      && reference.getParent().isCall()\n      && reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n  if (value.isFunction()) {\n    Node callNode = reference.getParent();\n    if (reference.getParent().isCall()) {\n      CodingConvention convention = compiler.getCodingConvention();\n      SubclassRelationship relationship =\n          convention.getClassesDefinedByCall(callNode);\n      if (relationship!= null) {\n        return false;\n      }\n// buggy line:    } else if (callNode.isNew()) {\n      } else if (callNode.isNew()) {\n        return false;\n      }\n    }\n  }\n  return canMoveAggressively(value) || canMoveModerately(initialization, reference);\n}\n\n\n  /**\n   * If the value is a literal, we can cross more boundaries to inline it.\n   */\n  private boolean canMoveAggressively(Node value) {\n    // Function expressions and other mutable objects can move within\n    // the same basic block.\n    return NodeUtil.isLiteralValue(value, true)\n        || value.isFunction();\n  }\n\n  /**\n   * If the value of a variable is not constant, then it may read or modify\n   * state. Therefore it cannot be moved past anything else that may modify\n   * state.\n   */\n  "
      ],
      "function range": "519,5-580,5"
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {",
      "output": [
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x > 0 && prev == '-') {\n  if (x > 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x > 0 && prev == '-') {\n  if (x > 0 && (prev == '-' || prev == '+')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x > 0 && prev == '-') {\n  if (x > 0 && (prev == '-' || prev == '+')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+' || prev ==",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0) {\n  if (x < 0) {\n    negativeZero = true;\n  }\n// buggy line:  if (",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '+') {\n  if (x < 0 && (prev == '+' || prev == '-')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '+') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x > 0 && prev == '+') {\n  if (x > 0 && (prev == '+' || prev == '-')) {\n",
        "void addNumber(double x) {\n  char prev = getLastChar();\n  boolean negativeZero = isNegativeZero(x);\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && prev == '-') {\n  if (x < 0 && (prev == '-' || prev == '+')) {\n    negativeZero = true;\n  }\n// buggy line:  if (x < 0 && (prev == '-' || prev == '+')) {\n  if (x < 0 && (prev == '-' || prev"
      ],
      "function range": "240,3-267,3"
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;",
      "output": [
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.h",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.",
        "static boolean isSimpleNumber(String s) {\n  int len = s.length();\n  for (int index = 0; index < len; index++) {\n    char c = s.charAt(index);\n    if (c < '0' || c > '9') {\n      return false;\n    }\n  }\n// buggy line:  return len > 0;\n  return true;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log"
      ],
      "function range": "737,3-746,3"
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);",
      "output": [
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.alge",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.",
        "private static boolean isReduceableFunctionExpression(Node n) {\n// buggy line:  return NodeUtil.isFunctionExpression(n);\n// fixed line: return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n    return NodeUtil.isFunctionExpression(n) &&!n.isArrowFunction();\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator"
      ],
      "function range": "116,3-118,3"
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee != null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target != null) {",
      "output": [
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.h",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.IL",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IL",
        "private static String extractClassNameIfGoog(Node node, Node parent,\n    String functionName){\n  String className = null;\n  if (NodeUtil.isExprCall(parent)) {\n    Node callee = node.getFirstChild();\n    if (callee!= null && callee.getType() == Token.GETPROP) {\n      String qualifiedName = callee.getQualifiedName();\n      if (functionName.equals(qualifiedName)) {\n        Node target = callee.getNext();\n// buggy line:        if (target!= null) {\n        if (target!= null && target.getType() == Token.STRING) {\n          className = target.getString();\n        }\n      }\n    }\n  }\n  return className;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org."
      ],
      "function range": "188,3-204,3"
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {",
      "output": [
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.SUSPICI",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.WARNING);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.SUSPICIOUS_",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.enables(DiagnosticGroups.MISSING_PROPERTIES)) {\n    options.setWarningLevel(\n        DiagnosticGroups.MISSING_PROPERTIES,\n        ",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(DiagnosticGroups.SUSPICIOUS_",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.CHECK_SUSP",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.WARNING);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.CHECK_SUSPICI",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else if (options.enables(DiagnosticGroups.GLOBAL_THIS)) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.WARNING);\n// buggy line:  } else if (options.disables(DiagnosticGroups.GLOBAL_THIS)) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkSuspiciousCode) {\n    options.setWarningLevel(\n        DiagnosticGroups.SUSPICIOUS_CODE,\n        CheckLevel.WARNING);\n  }\n  if (options.checkControlStructures) {\n    options",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkCaja) {\n    options.setWarningLevel(\n        DiagnosticGroups.CAJA,\n        CheckLevel.WARNING);\n  }\n  if (options.aggressiveVarCheck) {\n",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkCaja) {\n    options.setWarningLevel(\n        DiagnosticGroups.CHECK_CAJA,\n        CheckLevel.WARNING);\n  }\n  if (options.aggressiveVarCheck)",
        "public void initOptions(CompilerOptions options) {\n  this.options = options;\n  if (errorManager == null) {\n    if (outStream == null) {\n      setErrorManager(\n          new LoggerErrorManager(createMessageFormatter(), logger));\n    } else {\n      PrintStreamErrorManager printer =\n          new PrintStreamErrorManager(createMessageFormatter(), outStream);\n      printer.setSummaryDetailLevel(options.summaryDetailLevel);\n      setErrorManager(printer);\n    }\n  }\n  if (options.enables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = true;\n  } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) {\n    options.checkTypes = false;\n  } else if (!options.checkTypes) {\n    options.setWarningLevel(\n        DiagnosticGroup.forType(\n            RhinoErrorReporter.TYPE_PARSE_ERROR),\n        CheckLevel.OFF);\n  }\n// buggy line:  if (options.checkGlobalThisLevel.isOn()) {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        options.checkGlobalThisLevel);\n// buggy line:  } else {\n// buggy line:    options.setWarningLevel(\n// buggy line:        DiagnosticGroups.GLOBAL_THIS,\n// buggy line:        CheckLevel.OFF);\n// buggy line:  }\n  if (options.checkGlobalThisLevel!= null) {\n    if (options.checkGlobalThisLevel.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          options.checkGlobalThisLevel);\n    } else {\n      options.setWarningLevel(\n          DiagnosticGroups.GLOBAL_THIS,\n          CheckLevel.OFF);\n    }\n  }\n  if (options.checkSuspiciousCode!= null) {\n    if (options.checkSuspiciousCode.isOn()) {\n      options.setWarningLevel(\n          DiagnosticGroups.CHECK_EVIL_"
      ],
      "function range": "226,3-288,3"
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null ? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName != null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt != null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {",
      "output": [
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n/**\n * Given a {@link JSError}, creates a {@link CheckLevel} based on\n * {@link JSError#########################################################################################################################################",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  public String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown error level: \" + level);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  public String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown error level: \" + level);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error is reported.\n   */\n  protected boolean shouldReport(JSError error) {\n    CheckLevel defaultLevel",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error is reported.\n   */\n  protected boolean isReportable(JSError error) {\n    CheckLevel default",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error is reported.\n   */\n  protected boolean isReportable(JSError error) {\n    return shouldReport",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error is reported.\n   */\n  protected boolean isReportable(JSError error) {\n    return!filter",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  public String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown error level: \" + level);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error is reported.\n   */\n  protected boolean isReportable(JSError error) {\n    return!ign",
        "private String format(JSError error, boolean warning) {\n  SourceExcerptProvider source = getSource();\n  String sourceExcerpt = source == null? null :\n      excerpt.get(\n          source, error.sourceName, error.lineNumber, excerptFormatter);\n  StringBuilder b = new StringBuilder();\n  if (error.sourceName!= null) {\n    b.append(error.sourceName);\n    if (error.lineNumber > 0) {\n      b.append(':');\n      b.append(error.lineNumber);\n    }\n    b.append(\": \");\n  }\n  b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR));\n  b.append(\" - \");\n  b.append(error.description);\n  b.append('\\n');\n  if (sourceExcerpt!= null) {\n    b.append(sourceExcerpt);\n    b.append('\\n');\n    int charno = error.getCharno();\n    if (excerpt.equals(LINE)\n// buggy line:        && 0 <= charno && charno < sourceExcerpt.length()) {\n        && 0 <= charno && charno < sourceExcerpt.length() - 1) {\n      b.append(sourceExcerpt, charno, charno + 1);\n      b.append('^');\n    }\n    b.append('\\n');\n  }\n  return b.toString();\n}\n\n  /**\n   * Given the level of the error, returns a CSS class name that\n   * can be applied to the <code>DIV</code> to indicate the level of the\n   * error.\n   */\n  protected String getLevelName(CheckLevel level) {\n    switch (level) {\n      case ERROR:\n        return \"level-error\";\n      case WARNING:\n        return \"level-warning\";\n      case OFF:\n        return \"level-off\";\n      default:\n        throw new AssertionError(\"Unknown level: \" + level);\n    }\n  }\n\n  /**\n   * Decides whether the given error \"belongs\" to this category.  If the\n   * error does not belong to any category or if no category was"
      ],
      "function range": "66,3-111,3"
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;",
      "output": [
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      default:\n        // Reference: http://www.unicode.org/versions/Unicode7.0.0/ch03.pdf##########################################################################################################################################################################################################",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(String.format(\"\\\\u%04x\", (int) c));\n          }\n          ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(String.format(\"\\\\u%04x\", (int) c));\n          }\n          ",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n          }\n          else {\n            sb.append(c);",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            try {\n              sb.append(outputCharsetEncoder.encode(CharBuffer.wrap((char",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            try {\n              sb.append(outputCharsetEncoder.encode(CharBuffer.wrap((char",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F')\n            || (c >= '\\u007F' && c <= '\\u009F')\n            || (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            try {\n              sb.append(outputCharsetEncoder.encode(CharBuffer.wrap((new",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            try {\n              sb.append(outputCharsetEncoder.encode(CharBuffer.wrap((new",
        "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n  StringBuilder sb = new StringBuilder(s.length() + 2);\n  sb.append(quote);\n  for (int i = 0; i < s.length(); i++) {\n    char c = s.charAt(i);\n    switch (c) {\n// buggy line:      case '\\0': sb.append(\"\\\\0\"); break;\n      case '\\'': sb.append(singlequoteEscape); break;\n      case '\"': sb.append(doublequoteEscape); break;\n      case '\\\\': sb.append(backslashEscape); break;\n      case '\\b': sb.append(\"\\\\b\"); break;\n      case '\\f': sb.append(\"\\\\f\"); break;\n      case '\\n': sb.append(\"\\\\n\"); break;\n      case '\\r': sb.append(\"\\\\r\"); break;\n      case '\\t': sb.append(\"\\\\t\"); break;\n      case '/': sb.append(\"\\\\/\"); break;\n      default:\n        //Reference: http://www.unicode.org/versions/Unicode5.1.0/\n        if ((c >= '\\u0000' && c <= '\\u001F') ||\n            (c >= '\\u007F' && c <= '\\u009F') ||\n            (c >= '\\u2000' && c <= '\\u20FF')) {\n          String ss = Integer.toHexString(c);\n          sb.append(\"\\\\u\");\n          for (int k = 0; k < 4 - ss.length(); k++) {\n            sb.append('0');\n          }\n          sb.append(ss.toUpperCase());\n        }\n        else {\n          if (outputCharsetEncoder!= null &&!outputCharsetEncoder.canEncode(c)) {\n            sb.append(singlequoteEscape);\n            sb.append(Character.toString(c));\n            "
      ],
      "function range": "1005,3-1075,3"
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {",
      "output": [
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQName(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node = newName(compiler, name.substring(0, endPos));\n    int startPos;\n    do {\n      startPos = endPos + 1;\n      endPos = name.indexOf('.', startPos);\n      String part = (endPos == -1\n                    ? name.substring(startPos)\n                     : name.sub",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQName(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = IR.name(nodeName);\n    }\n    node",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Returns true if the node an assignment to a prototype property of\n   * some constructor.\n   */\n  static boolean isPrototypePropertyDeclaration(Node n) {\n    return isExprAssign(n) &&\n        isPrototypeProperty(n.getFirstChild().getFirstChild());\n  }\n\n  /**\n   * Returns true if the node is an assignment to a prototype property\n   * of some constructor.\n   */\n  static boolean isPrototypeProperty(Node n) {\n    Node firstChild = n.getFirstChild();\n    return firstChild.getType() == Token.GETPROP &&\n        firstChild.isGetProp() &&\n        firstChild.getLastChild().getString().equals(\"prototype\") ||\n        firstChild.getLastChild().getString().equals(\"__proto__\");\n  }\n\n  /**\n   ",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQname(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    if (\"this\".equals(nodeName)) {\n      node = newName(compiler, name);\n    } else {\n      node = newName(compiler, nodeName);\n      Node prop = newStringNode(Token.STRING, name.substring(end",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQname(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = IR.name(nodeName);\n    }\n    node",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQname(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = IR.name(nodeName);\n    }\n    return",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQName(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = IR.name(nodeName);\n    }\n    return",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQName(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = IR.getprop(newName(compiler, nodeName",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQName(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      compiler.report(\n          JSError.make(Abstract",
        "private boolean isPrototypePropertyAssign(Node assign) {\n  Node n = assign.getFirstChild();\n  if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n      && n.getType() == Token.GETPROP\n// buggy line:      ) {\n      && n.getLastChild().getType() == Token.OBJECTLIT) {\n    return true;\n  }\n  return false;\n}\n\n\n  /**\n   * Creates a node for an empty result expression:\n   *   \"void 0\"\n   */\n  static Node newUndefinedNode(Node srcReferenceNode) {\n    Node node = IR.voidNode(IR.number(0));\n    if (srcReferenceNode!= null) {\n      node.copyInformationFromForTree(srcReferenceNode);\n    }\n    return node;\n  }\n\n  /**\n   * Creates a VAR node containing the given name and initial value expression.\n   */\n  static Node newVarNode(String name, Node value) {\n    Node nodeName = IR.name(name);\n    if (value!= null) {\n      nodeName.addChildToBack(value);\n      nodeName.srcref(value);\n    }\n    Node var = IR.var(nodeName).srcref(nodeName);\n\n    return var;\n  }\n\n  /**\n   * Creates a new node representing a qualified name.\n   *\n   * @param name A qualified name (e.g. \"foo\" or \"foo.bar.baz\")\n   * @return A NAME or GETPROP node\n   */\n  static Node newQname(AbstractCompiler compiler, String name) {\n    int endPos = name.indexOf('.');\n    if (endPos == -1) {\n      return newName(compiler, name);\n    }\n    Node node;\n    String nodeName = name.substring(0, endPos);\n    String remaining = name.substring(endPos + 1);\n    if (isValidPropertyName(nodeName)) {\n      node = newName(compiler, nodeName);\n    } else {\n      node = newGetProp(compiler, nodeName, newName("
      ],
      "function range": "314,5-334,5"
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType != null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters != null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter != null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);",
      "output": [
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(Node node,",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   */\n  private void defineSlot(Node node, Node parent, JSType type)",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Defines a slot on the given node.\n   * @see #defineSlot\n   */\n  private void defineSlot(Node node, Node parent,",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    node.setJSType(type);\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    if (parent.isParamList()) {\n      parent.addChildToFront(node);\n    } else {\n      parent.addChildBefore(node, parent.getFirstChild",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Defines a slot on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(Node node,",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    node.setJSType(type);\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    node.setJSType(type);\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent);\n  }\n\n  /**\n   * Defines a slot on the given node.\n   * @see #defineSlot\n   */\n  private void",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    parent.addChildToBack(\n        IR.name(node.getString()).useSourceInfoFrom(node));\n    if (type!= null) {\n      parent.setJSType(type);\n    }\n  ",
        "private void declareArguments(Node functionNode) {\n  Node astParameters = functionNode.getFirstChild().getNext();\n  Node body = astParameters.getNext();\n  FunctionType functionType = (FunctionType) functionNode.getJSType();\n  if (functionType!= null) {\n    Node jsDocParameters = functionType.getParametersNode();\n    if (jsDocParameters!= null) {\n      Node jsDocParameter = jsDocParameters.getFirstChild();\n      for (Node astParameter : astParameters.children()) {\n        if (jsDocParameter!= null) {\n          defineSlot(astParameter, functionNode,\n// buggy line:              jsDocParameter.getJSType(), true);\n              jsDocParameter.getJSType(), true);\n          jsDocParameter = jsDocParameter.getNext();\n        } else {\n          defineSlot(astParameter, functionNode, null, true);\n        }\n      }\n    }\n  }\n}\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type, isOptional);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   * @see #defineSlot\n   */\n  private void defineSlot(\n      Node node, Node parent, JSType type, boolean isOptional) {\n    if (type == null) {\n      type = JSType.UNKNOWN;\n    }\n    if (isOptional) {\n      node.putBooleanProp(Node.OPT_ES6_TYPED, true);\n    }\n    defineSlot(node, parent, type);\n  }\n\n  /**\n   * Declares a parameter on the given FUNCTION node.\n   */\n  private void defineSlot(Node node, Node parent, JSType jsType"
      ],
      "function range": "1734,5-1753,5"
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType != null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&",
      "output": [
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BAS",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANT",
        "private void checkPropertyVisibility(NodeTraversal t,\n    Node getprop, Node parent) {\n  ObjectType objectType =\n      ObjectType.cast(dereference(getprop.getFirstChild().getJSType()));\n  String propertyName = getprop.getLastChild().getString();\n  if (objectType!= null) {\n// buggy line:    boolean isOverride = t.inGlobalScope() &&\n//           parent.getJSDocInfo()!= null &&\n//           parent.isAssign() &&\n//           parent.getFirstChild() == getprop &&\n//           (parent.getJSDocInfo().isOverride() ||\n//            parent.getJSDocInfo().isConstructor() ||\n//            parent.getJSDocInfo().makesStructs() ||\n//            parent.getJSDocInfo().makesDicts());\n    boolean isOverride = t.inGlobalScope() &&\n        parent.getJSDocInfo()!= null &&\n        parent.isAssign() &&\n        parent.getFirstChild() == getprop &&\n        (parent.getJSDocInfo().isOverride() ||\n         parent.getJSDocInfo().isConstructor() ||\n         parent.getJSDocInfo().makesStructs() ||\n         parent.getJSDocInfo().makesDicts());\n    if (isOverride) {\n      compiler.report(\n          t.makeError(getprop, OVERRIDE_JSDOC,\n              propertyName));\n    }\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS"
      ],
      "function range": "407,3-500,3"
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();",
      "output": [
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructorType() {\n\t\treturn this == CONSTRUCTOR_TYPE;\n\t}\n\n\tpublic final boolean isInstanceType() {\n\t\treturn this == INSTANCE_TYPE;\n\t}\n\n\tpublic final boolean isInterfaceType() {\n\t\treturn this == INTERFACE_TYPE;\n\t}\n\n\tpublic final",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean is",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructorType() {\n\t\treturn this == CONSTRUCTOR_TYPE;\n\t}\n\n\tpublic final",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isObjectType() {\n\t\treturn this == OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructorType() {\n\t\treturn this == CONSTRUCTOR_TYPE;\n\t}\n\n\tpublic final",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isObjectType() {\n\t\treturn this == OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructorType() {\n\t\treturn this == CONSTRUCTOR_TYPE;\n\t}\n\n\tpublic",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isTypeVariable() {\n\t\treturn this == TYPE_VARIABLE;\n\t}\n\n\tpublic final boolean",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isObjectType() {\n\t\treturn this == OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructor() {\n\t\treturn this == CONSTRUCTOR;\n\t}\n\n\tpublic final boolean is",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isObjectType() {\n\t\treturn this == OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructor() {\n\t\treturn this == CONSTRUCTOR;\n\t}\n\n\tpublic final boolean isInterface",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isUndefinedType() {\n\t\treturn this == UNDEFINED_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isObjectType() {\n\t\treturn this == OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isFunctionType() {\n\t\treturn this == FUNCTION_TYPE;\n\t}\n\n\tpublic final boolean isConstructor() {\n\t\treturn this == CONSTRUCTOR;\n\t}\n\n\tpublic final boolean isInstance",
        "public final boolean isEmptyType() {\n// buggy line:  return isNoType() || isNoObjectType() || isNoResolvedType();\n\t\treturn isNoType() || isNoObjectType() || isNoResolvedType();\n\t}\n\n\tpublic final boolean isNoType() {\n\t\treturn this == NO_TYPE;\n\t}\n\n\tpublic final boolean isNoObjectType() {\n\t\treturn this == NO_OBJECT_TYPE;\n\t}\n\n\tpublic final boolean isNoResolvedType() {\n\t\treturn this == NO_RESOLVED_TYPE;\n\t}\n\n\tpublic final boolean isArrayType() {\n\t\treturn this == ARRAY_TYPE;\n\t}\n\n\tpublic final boolean isBooleanType() {\n\t\treturn this == BOOLEAN_TYPE;\n\t}\n\n\tpublic final boolean isByteType() {\n\t\treturn this == BYTE_TYPE;\n\t}\n\n\tpublic final boolean isCharType() {\n\t\treturn this == CHAR_TYPE;\n\t}\n\n\tpublic final boolean isDoubleType() {\n\t\treturn this == DOUBLE_TYPE;\n\t}\n\n\tpublic final boolean isFloatType() {\n\t\treturn this == FLOAT_TYPE;\n\t}\n\n\tpublic final boolean isIntType() {\n\t\treturn this == INT_TYPE;\n\t}\n\n\tpublic final boolean isLongType() {\n\t\treturn this == LONG_TYPE;\n\t}\n\n\tpublic final boolean isNumberType() {\n\t\treturn this == NUMBER_TYPE;\n\t}\n\n\tpublic final boolean isShortType() {\n\t\treturn this == SHORT_TYPE;\n\t}\n\n\tpublic final boolean isStringType() {\n\t\treturn this == STRING_TYPE;\n\t}\n\n\tpublic final boolean isVoidType() {\n\t\treturn this == VOID_TYPE;\n\t}\n\n\tpublic final boolean isAllType() {\n\t\treturn this == ALL_TYPE;\n\t}\n\n\tpublic final boolean isUnknownType() {\n\t\treturn this == UNKNOWN_TYPE;\n\t}\n\n\tpublic final boolean isNullType() {\n\t\treturn this == NULL_TYPE;\n\t}\n\n\tpublic final boolean isNamedType() {\n\t\treturn this!= NO_TYPE && this!= NO_OBJECT_TYPE && this!= NO_RES"
      ],
      "function range": "162,3-164,3"
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);",
      "output": [
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.al",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\n",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.al",
        "@Override\npublic int parseArguments(Parameters params) throws CmdLineException {\n// buggy line:  String param = params.getParameter(0);\n\tString param = params.getParameter(0);\n\tif (param == null) {\n\t\tthrow new CmdLineException(\"Missing parameter\");\n\t}\n\ttry {\n\t\treturn Integer.parseInt(param);\n\t} catch (NumberFormatException e) {\n\t\tthrow new CmdLineException(e.getMessage());\n\t}\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org"
      ],
      "function range": "332,7-351,7"
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;",
      "output": [
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      // x = '' + g (x is",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g;\n",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force local values:\n      //  x = '' + g (x is",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x++;\n      //  x",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value) && value.getFirstChild().isName()) {\n        return true;\n      }\n      return false;\n  }\n}\n\n\n/**\n * @return Whether the call has a local result.\n */\nstatic boolean callHas",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g\n      ",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force special evaluation.\n      return false;\n  }\n}\n\n\n",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.DELPROP:\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x++;\n      //  foo",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n         && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.apply(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.apply(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.apply(value);\n    case Token.NEW:\n// buggy line:      return true;\n      return false;\n    case Token.FUNCTION:\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (NodeUtil.isAssignmentOp(value) && value.getFirstChild().isName()) {\n        return true;\n      }\n      return false;\n  }\n}\n\n/**\n * @return Whether the call has a local result.\n */\nstatic boolean callHas"
      ],
      "function range": "2424,3-2489,3"
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');",
      "output": [
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      firstNode.",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//               String before = namespace.substring(0, indexOfDot);\n//               String after = namespace.substring(indexOfDot + 1);\n//               namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      firstNode.",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      replacementNode",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//               String before = namespace.substring(0, indexOfDot);\n//               String after = namespace.substring(indexOfDot + 1);\n//               namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      replacementNode",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      Node newName",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//               String before = namespace.substring(0, indexOfDot);\n//               String after = namespace.substring(indexOfDot + 1);\n//               namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      Node newName",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      if (first",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      Node newNode",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//                 String before = namespace.substring(0, indexOfDot);\n//                 String after = namespace.substring(indexOfDot + 1);\n//                 namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      Node newNames",
        "void replace() {\n  if (firstNode == null) {\n    replacementNode = candidateDefinition;\n    return;\n  }\n  if (candidateDefinition!= null && explicitNode!= null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    replacementNode = createDeclarationNode();\n    if (firstModule == minimumModule) {\n      firstNode.getParent().addChildBefore(replacementNode, firstNode);\n    } else {\n// buggy line:      int indexOfDot = namespace.indexOf('.');\n//               String before = namespace.substring(0, indexOfDot);\n//               String after = namespace.substring(indexOfDot + 1);\n//               namespace = before + \".\" + minimumModule + \".\" + after;\n      String namespace = firstNode.getQualifiedName();\n      int indexOfDot = namespace.indexOf('.');\n      String before = namespace.substring(0, indexOfDot);\n      String after = namespace.substring(indexOfDot + 1);\n      namespace = before + \".\" + minimumModule + \".\" + after;\n      if (first"
      ],
      "function range": "747,5-809,5"
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt != lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt != rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;",
      "output": [
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue result",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  TernaryValue",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new Error(\"Unknown shift operator\");\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \"\n            + Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g.\n * <pre",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \"\n            + Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g.\n * <pre",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  if (NodeUt",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        return n;\n    }\n    Node newNumber = IR.number(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g ==\n */\nNode tryFoldComparison(Node n, Node left, Node right) {\n  if (NodeUtil",
        "private Node tryFoldShift(Node n, Node left, Node right) {\n  if (left.getType() == Token.NUMBER &&\n      right.getType() == Token.NUMBER) {\n    double result;\n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n      error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n      return n;\n    }\n    if (!(rval >= 0 && rval < 32)) {\n      error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n      return n;\n    }\n    int lvalInt = (int) lval;\n    if (lvalInt!= lval) {\n      error(FRACTIONAL_BITWISE_OPERAND, left);\n      return n;\n    }\n    int rvalInt = (int) rval;\n    if (rvalInt!= rval) {\n      error(FRACTIONAL_BITWISE_OPERAND, right);\n      return n;\n    }\n    switch (n.getType()) {\n      case Token.LSH:\n        result = lvalInt << rvalInt;\n        break;\n      case Token.RSH:\n        result = lvalInt >> rvalInt;\n        break;\n      case Token.URSH:\n// buggy line:        result = lvalInt >>> rvalInt;\n        if (rvalInt == 0) {\n          error(BITWISE_SHIFT_AMOUNT_OUT_OF_RANGE, right);\n          return n;\n        }\n        result = lvalInt >>> rvalInt;\n        break;\n      default:\n        throw new AssertionError(\"Unknown shift operator: \" +\n            Token.name(n.getType()));\n    }\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    return newNumber;\n  }\n  return n;\n}\n\n/**\n * Try to fold comparison nodes, e.g.\n * ==,"
      ],
      "function range": "652,3-713,3"
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result != null) {",
      "output": [
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType getLeastSupertype(JSType that) {\n  ",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.getLeastSupertype(that)!= null) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.getLeastSupertype(this)!= null) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.getLeastSupertype(this)!= null) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic boolean isSubtype(",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isLeastSupertype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isLeastSupertype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isLeastSupertype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getGreatestSubtype(JSType that)",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.getRestrictedUnion(that)!= null) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.getRestrictedUnion(this)!= null) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.getRestrictedUnion(this)!= null) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType getLe",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.getLeastSupertype(that)!= null) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.getLeastSupertype(this)!= null) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.getLeastSupertype(this)!= null) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic Iterable<JST",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.getLeastSupertype(that)!= null) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.getLeastSupertype(this)!= null) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.getLeastSupertype(this)!= null) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getGreat",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.getLeastSupertype(that)!= null) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.getLeastSupertype(this)!= null) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.getLeastSupertype(this)!= null) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType collapseUnion",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder restricted",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  } else {\n    return null;\n  }\n}\n\npublic JSType collapseUnion() {\n  if (isUnion()) {\n    ",
        "JSType meet(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getLeastSupertype(JSType that) {\n  UnionTypeBuilder builder = new UnionTypeBuilder(registry);\n  for (JSType alternate : alternates) {\n    if (alternate.isSubtype(that)) {\n      builder.addAlternate(alternate);\n    }\n  }\n  if (that instanceof UnionType) {\n    for (JSType otherAlternate : ((UnionType) that).alternates) {\n      if (otherAlternate.isSubtype(this)) {\n        builder.addAlternate(otherAlternate);\n      }\n    }\n  } else if (that.isSubtype(this)) {\n    builder.addAlternate(that);\n  }\n  JSType result = builder.build();\n// buggy line:  if (result!= null) {\n// fixed line:  if (result!= null &&!result.isEmptyType()) {\n  if (result!= null &&!result.isEmptyType()) {\n    return result;\n  }\n  return null;\n}\n\n@Override\npublic JSType getRestrictedUnion(JSType that) {\n  UnionTypeBuilder builder"
      ],
      "function range": "273,3-298,3"
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);",
      "output": [
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   */\n  private Node parseUnionType(JsDocToken token, int lineno, int charno) {\n    Node typeNode = parseTypeUnion(token, lineno, charno);\n    if (typeNode!= null) {\n      while (match(JsDocToken.PIPE)) {\n        nextToken();\n        skipEOLs();\n        typeNode = parseTypeUnion(token, lineno, charno, typeNode);\n      }\n",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   */\n  private Node parseUnionType(JsDocToken token, int lineno, int charno) {\n    Node typeNode = parseTypeUnion(token, lineno, charno);\n    if (typeNode!= null) {\n      while (match(JsDocToken.PIPE)) {\n        nextToken();\n        skipEOLs();\n        typeNode = parseUnionType(token, lineno, charno);\n\n        if (typeNode!=",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      Node typeNode = parseTypeName(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        if (match(JsDocToken.RIGHT_CURLY)) {\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        } else {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        }\n      }\n\n      Node result = typeNode;\n      if (result!= null) {\n        skipEOLs();\n        result =",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      Node typeNode = parseTypeName(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        if (match(JsDocToken.RIGHT_CURLY)) {\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        } else {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        }\n      }\n\n      Node result = typeNode;\n      if (result!= null) {\n        result = wrapNode(Token.CONTEXT",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' TopLevelTypeUnionList '}'\n   *     '{' TopLevelTypeList '}'\n   *     '{' TopLevelType '}'\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    Node typeNode = parseUnionType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    typeNode = parseRecordType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    typeNode = parseType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    return null;\n  }\n\n  /**\n   * TopLevelType :\n   *     UnionType\n   *     ",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   */\n  private Node parseUnionType(JsDocToken token, int lineno, int charno) {\n    Node typeNode = parseTypeUnion(token, lineno, charno);\n    if (typeNode!= null) {\n      while (match(JsDocToken.PIPE)) {\n        nextToken();\n        skipEOLs();\n        typeNode = parseUnionType(token, lineno, charno,\n            typeNode, parseType",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      return parseTypeName(token);\n    }\n  }\n\n  /**\n   * UnionType := '(' TypeUnionList ')'\n   * TypeUnionList := TypeExpression | TypeExpression '|' TypeUnionList\n   */\n  private Node parseUnionType(JsDocToken token, int lineno, int charno) {\n    Node typeNode = parseTypeUnion(token, lineno, charno);\n    if (typeNode!= null) {\n      while (match(JsDocToken.PIPE)) {\n        nextToken();\n        skipEOLs();\n        typeNode = parseUnionType(token, lineno, charno,\n            typeNode, topLevel",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' TopLevelTypeUnionList '}'\n   *     '{' TopLevelTypeList '}'\n   *     '{' TopLevelType '}'\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    Preconditions.checkArgument(token == JsDocToken.LEFT_CURLY);\n    int lineno = stream.getLineno();\n    int charno = stream.getCharno();\n\n    Node typeNode = parseUnionType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    typeNode = parseRecordType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    typeNode = parseType(token, lineno, charno);\n    if (typeNode!= null) {\n      return typeNode;\n    }\n\n    return null;\n  }\n\n  /**\n   * TopLevelType : ExtendedType\n   *\n   * An extended",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      Node typeNode = parseTypeName(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        if (match(JsDocToken.RIGHT_CURLY)) {\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        } else {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        }\n      }\n\n      return typeNode;\n    }\n  }\n\n  /**\n   * UnionType :\n   *    '(' Union",
        "private Node parseContextTypeExpression(JsDocToken token) {\n// buggy line:        return parseTypeName(token);\n    return parseTypeExpression(token);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno, int charno) {\n    return parseContextTypeExpression(token, lineno, charno, false);\n  }\n\n  private Node parseContextTypeExpression(JsDocToken token, int lineno,\n                                          int charno, boolean topLevel) {\n    Node typeNode;\n    if (token == JsDocToken.LEFT_CURLY) {\n      typeNode = parseRecordType(token, lineno, charno);\n    } else if (token == JsDocToken.LEFT_PAREN) {\n      typeNode = parseUnionType(token, lineno, charno);\n    } else {\n      typeNode = parseTypeName(token);\n    }\n\n    if (topLevel) {\n      typeNode = wrapNode(Token.CONTEXT_TYPE, typeNode);\n    }\n\n    return typeNode;\n  }\n\n  /**\n   * ContextTypeExpression :\n   *     '{' ContextTypeExpression '}'\n   *     | TypeName\n   */\n  private Node parseContextTypeExpression(JsDocToken token) {\n    if (token == JsDocToken.LEFT_CURLY) {\n      skipEOLs();\n      return parseContextTypeExpression(token, nextLineno, nextCharno);\n    } else {\n      Node typeNode = parseTypeName(token);\n      if (typeNode!= null) {\n        skipEOLs();\n        if (match(JsDocToken.RIGHT_CURLY)) {\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        } else {\n          reportTypeSyntaxWarning(\"msg.jsdoc.missing.rc\");\n          nextLineno = stream.getLineno();\n          nextCharno = stream.getCharno();\n        }\n      }\n\n      return typeNode;\n    }\n  }\n\n  /**\n   * UnionType :\n   *     UnionType |"
      ],
      "function range": "1907,3-1909,3"
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;",
      "output": [
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseSymbolType(SymbolType symbolType) {\n    return symbolType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseAllType(AllType allType) {\n    return allType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(Template",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseSymbolType(SymbolType symbolType) {\n    return symbolType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseTypeVar(Type",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseEnumElementType(EnumElementType enumElementType) {\n    return enumElementType;\n  }\n\n  @Override\n  protected JSType caseAllType(AllType allType) {\n    return allType;\n  }\n\n  @Override\n  protected JST",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseSymbolType(SymbolType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType type) {\n    return type;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType type) {\n    return",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyType) {\n    return proxyType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObject",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseProxyType(Proxy",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseAllType(All",
        "@Override\nprotected JSType caseTopType(JSType topType) {\n// buggy line:  return topType;\n    return null;\n  }\n\n  @Override\n  protected JSType caseNoObjectType(NoObjectType noObjectType) {\n    return noObjectType;\n  }\n\n  @Override\n  protected JSType caseNoType(NoType noType) {\n    return noType;\n  }\n\n  @Override\n  protected JSType caseBooleanType(BooleanType booleanType) {\n    return booleanType;\n  }\n\n  @Override\n  protected JSType caseFunctionType(FunctionType functionType) {\n    return functionType;\n  }\n\n  @Override\n  protected JSType caseNullType(NullType nullType) {\n    return nullType;\n  }\n\n  @Override\n  protected JSType caseNumberType(NumberType numberType) {\n    return numberType;\n  }\n\n  @Override\n  protected JSType caseObjectType(ObjectType objectType) {\n    return objectType;\n  }\n\n  @Override\n  protected JSType caseStringType(StringType stringType) {\n    return stringType;\n  }\n\n  @Override\n  protected JSType caseUnionType(UnionType unionType) {\n    return unionType;\n  }\n\n  @Override\n  protected JSType caseUnknownType(UnknownType unknownType) {\n    return unknownType;\n  }\n\n  @Override\n  protected JSType caseVoidType(VoidType voidType) {\n    return voidType;\n  }\n\n  @Override\n  protected JSType caseTemplatizedType(TemplatizedType templatizedType) {\n    return templatizedType;\n  }\n\n  @Override\n  protected JSType caseTemplateType(TemplateType templateType) {\n    return templateType;\n  }\n\n  @Override\n  protected JSType caseNamedType(NamedType namedType) {\n    return namedType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectType(ProxyObjectType proxyObjectType) {\n    return proxyObjectType;\n  }\n\n  @Override\n  protected JSType caseProxyObjectTypeAltern"
      ],
      "function range": "52,9-55,9"
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null || !provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph != null &&\n          module != providedModule &&\n          !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided != null) {",
      "output": [
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:    }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  private void reportBadRequireErrorHelper(NodeTraversal t, Node n, Node arg) {\n",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:      }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  private void reportBadRequireErrorHelper(NodeTraversal t, Node n, Node arg) {\n",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:    }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require function warning.\n   */\n  private void reportBadRequireError",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:      }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require function warning.\n   */\n  private void reportBadRequireError",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:    }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param t The traversal",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:      }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param t The traversal",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:    }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param n The require call",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:      }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param n The require call",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:    }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param n The node of",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) {\n  Node left = n.getFirstChild();\n  Node arg = left.getNext();\n  if (verifyLastArgumentIsString(t, left, arg)) {\n    String ns = arg.getString();\n    ProvidedName provided = providedNames.get(ns);\n    if (provided == null ||!provided.isExplicitlyProvided()) {\n      unrecognizedRequires.add(\n          new UnrecognizedRequire(n, ns, t.getSourceName()));\n    } else {\n      JSModule providedModule = provided.explicitModule;\n      Preconditions.checkNotNull(providedModule);\n      JSModule module = t.getModule();\n      if (moduleGraph!= null &&\n          module!= providedModule &&\n         !moduleGraph.dependsOn(module, providedModule)) {\n        compiler.report(\n            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n                providedModule.getName(),\n                module.getName()));\n      }\n    }\n    maybeAddToSymbolTable(left);\n    maybeAddStringNodeToSymbolTable(arg);\n// buggy line:    if (provided!= null) {\n// buggy line:        compiler.report(\n// buggy line:            t.makeError(n, XMODULE_REQUIRE_ERROR, ns,\n// buggy line:            providedModule.getName(),\n// buggy line:            module.getName()));\n// buggy line:      }\n  }\n}\n\n  /**\n   * Verifies that the last argument of a goog.require call is a string\n   * literal. Reports a warning otherwise.\n   *\n   * @return Whether the last argument was a string literal.\n   */\n  private boolean verifyLastArgumentIsString(\n      NodeTraversal t, Node n, Node arg) {\n    if (arg == null ||!arg.isString()) {\n      reportBadRequireErrorHelper(t, n, arg);\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Reports a bad require call error.\n   *\n   * @param n The node of"
      ],
      "function range": "295,3-334,3"
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns != null) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext() != n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {",
      "output": [
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDelProp() && parent.getFirstChild() == n) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isCall() && parent.getFirstChild()",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild() == n) {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isInc() || parent.isDec()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCatch()) {\n      Node catchVar = parent.getFirstChild();\n      if (catchVar.getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      Preconditions.checkState(false, \"",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild() == n) {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isInc() || parent.isDec()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCatch()) {\n      Node catchVar = parent.getFirstChild();\n      if (catchVar.getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      Preconditions.checkState(parent.is",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild() == n) {\n      Node callee = parent.getFirstChild();\n      if (callee.isGetProp() && callee.getLast",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDelProp() && parent.getFirstChild() == n) {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}\n\n  private void recordDepScope(Node node",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() || parent.isGetElem()) {\n      if (parent.getFirstChild() == n) {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isHook()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isInc() || parent.isDec()) {\n      if (parent.getFirstChild()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCatch()) {\n      Node catchVar = parent.getFirstChild();\n      if (catchVar.getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else {\n      throw new IllegalArgumentException(\n          \"",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isDelProp() && parent.getFirstChild() == n) {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}\n\n  private void recordDepScope(Node n",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild() == n) {\n      Node callee = parent.getFirstChild();\n      if (callee.isGetProp()) {\n        Node prop =",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node nameNode = n.getFirstChild();\n  Node parent = n.getParent();\n  NameInformation ns = createNameInformation(t, nameNode);\n  if (ns!= null) {\n    if (parent.isFor() &&!NodeUtil.isForIn(parent)) {\n      if (parent.getFirstChild().getNext()!= n) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n// buggy line:    } else {\n      } else {\n        recordDepScope(recordNode, ns);\n      }\n    } else if (parent.isVar() || parent.isFunction()) {\n      recordDepScope(recordNode, ns);\n    } else if (parent.isAssign() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (NodeUtil.isNormalGet(parent) && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isGetProp() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isHook() && parent.getFirstChild() == n) {\n      if (n.getNext()!= null) {\n        recordDepScope(recordNode, ns);\n      } else {\n        recordDepScope(nameNode, ns);\n      }\n    } else if (parent.isCall() && parent.getFirstChild() == n) {\n      Node callee = parent.getFirstChild();\n      if (callee.isGetProp()) {\n        Node callee"
      ],
      "function range": "558,5-588,5"
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child != null;\n      child = child.getNext()) {",
      "output": [
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isCase()) {\n      handleCase(t, child);\n    } else if (child.isDefault",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isTry",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isFunction()) {\n      handleFunction(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isV",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isVar()) {\n      handleVar(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isForIn()) {\n      handleForIn(t, child);\n    } else if (child.isForOf()) {\n      handleForOf(t, child);\n    } else if (child.isDebugger()) {\n      handleDebugger(t, child);\n    } else {\n      handle",
        "private void handleObjectLit(NodeTraversal t, Node n) {\n  for (Node child = n.getFirstChild();\n      child!= null;\n      child = child.getNext()) {\n    // Maybe STRING, GET, SET\n    if (child.isString()) {\n      continue;\n    } else if (child.isGet()) {\n      handleGet(t, child);\n    } else if (child.isSet()) {\n      handleSet(t, child);\n    } else if (child.isObjectLit()) {\n      handleObjectLit(t, child);\n    } else if (child.isArrayLit()) {\n      handleArrayLit(t, child);\n    } else if (child.isCall()) {\n      handleCall(t, child);\n    } else if (child.isNew()) {\n      handleNew(t, child);\n    } else if (child.isIf()) {\n      handleIf(t, child);\n    } else if (child.isWhile()) {\n      handleWhile(t, child);\n    } else if (child.isDo()) {\n      handleDo(t, child);\n    } else if (child.isFor()) {\n      handleFor(t, child);\n    } else if (child.isReturn()) {\n      handleReturn(t, child);\n    } else if (child.isVoid()) {\n      handleVoid(t, child);\n    } else if (child.isLabel()) {\n      handleLabel(t, child);\n    } else if (child.isGoto()) {\n      handleGoto(t, child);\n    } else if (child.isContinue()) {\n      handleContinue(t, child);\n    } else if (child.isBreak()) {\n      handleBreak(t, child);\n    } else if (child.isThis()) {\n      handleThis(t, child);\n    } else if (child.isWith()) {\n      handleWith(t, child);\n    } else if (child.isSwitch()) {\n      handleSwitch(t, child);\n    } else if (child.isThrow()) {\n      handleThrow(t, child);\n    } else if (child.isCase"
      ],
      "function range": "490,5-513,5"
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block != null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;",
      "output": [
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = getFirstDef();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block =",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = getOneUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block =",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = getFirstUseInLifetime();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!=",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = firstAssignment;\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the last assignment.\n */\npublic Reference getLastAssignment() {\n  Reference ref = lastAssignment;\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = firstUse;\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = getLastUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block =",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  return firstUse;\n}\n\n/**\n * Sets the first use.\n */\npublic void setFirstUse(Reference firstUse) {\n  this.firstUse = firstUse;\n}\n\n/**\n",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  Reference ref = getOneUse();\n  if (ref == null) {\n    return null;\n  }\n  return ref;\n}\n\n/**\n * Returns the one use.\n */\npublic Reference",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  return firstUse;\n}\n\n/**\n * Sets the first use.\n */\npublic void setFirstUse(Reference ref) {\n  firstUse = ref;\n}\n\n/**\n * Returns the first",
        "boolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns the one and only assignment.\n */\npublic Reference getOneAndOnlyAssignment() {\n  Reference ref = getOneAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the one assignment.\n */\npublic Reference getOneAssignment() {\n  Reference ref = getFirstAssignment();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first assignment.\n */\npublic Reference getFirstAssignment() {\n  Reference ref = getFirstUse();\n  if (ref == null) {\n    return null;\n  }\n  for (BasicBlock block = ref.getBasicBlock();\n       block!= null; block = block.getParent()) {\n    if (block.isFunction) {\n// buggy line:      break;\n      return null;\n    }\n  }\n  return ref;\n}\n\n/**\n * Returns the first use.\n */\npublic Reference getFirstUse() {\n  return firstUse;\n}\n\n/**\n * Sets the first use.\n */\npublic void setFirstUse(Reference ref) {\n  firstUse = ref;\n}\n\n/**\n * Returns the last"
      ],
      "function range": "421,5-438,5"
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) {",
      "output": [
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                   ",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                        if (comment.getValue().",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                        if (comment.getValue().indexOf(\"/*\")!= -1",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                   ",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                        if (comment.getValue().indexOf(\"/*\")!=",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                    if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                        if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                            if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                    if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                        if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                            if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                                if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"*/\")!= -1 || comment.getValue().indexOf(\"\\n */\")!= -1) {\n                                                        if (comment.getValue().indexOf(\"*/\")!= -1 || comment",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                    return;\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n\n                                                   ",
        "private void handleBlockComment(Comment comment) {\n// buggy line:  if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                        if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                            if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                if (comment.getValue().indexOf(\"/*\")!= -1 || comment.getValue().indexOf(\"\\n *\")!= -1) {\n                                                    if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) {\n                                                        return;\n                                  "
      ],
      "function range": "251,3-258,3"
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType != null) {",
      "output": [
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssignTo(t, valueNode, actual",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR, type.toString());\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssignTo(t",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = typeRegistry.getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectCanAssign",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n      validator.expectCanAss",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR, type.toString());\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n      validator",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = typeRegistry.getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = typeRegistry.getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode);\n      }\n\n      // verifying\n      validator.expectUndefinedReturnType(t, functionType, value",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR, type.toString());\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n      if (",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n      if (actualReturnType.is",
        "private void visitNew(NodeTraversal t, Node n) {\n  Node constructor = n.getFirstChild();\n  JSType type = getJSType(constructor).restrictByNotNullOrUndefined();\n  if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) {\n    FunctionType fnType = type.toMaybeFunctionType();\n// buggy line:    if (fnType!= null) {\n    if (fnType!= null && fnType.hasInstanceType()) {\n      visitParameterList(t, n, fnType);\n      ensureTyped(t, n, fnType.getInstanceType());\n    } else {\n      ensureTyped(t, n);\n    }\n  } else {\n    report(t, n, NOT_A_CONSTRUCTOR);\n    ensureTyped(t, n);\n  }\n}\n\n\n  /**\n   * Visits a RETURN node.\n   *\n   * @param t The node traversal object that supplies context, such as the\n   * scope chain to use in name lookups as well as error reporting.\n   * @param n The node being visited.\n   */\n  private void visitReturn(NodeTraversal t, Node n) {\n    JSType jsType = getJSType(t.getEnclosingFunction());\n\n    if (jsType.isFunctionType()) {\n      FunctionType functionType = jsType.toMaybeFunctionType();\n\n      JSType returnType = functionType.getReturnType();\n\n      // if no return type is specified, undefined must be returned\n      // (it's a void function)\n      if (returnType == null) {\n        returnType = getNativeType(VOID_TYPE);\n      }\n\n      // fetching the returned value's type\n      Node valueNode = n.getFirstChild();\n      JSType actualReturnType;\n      if (valueNode == null) {\n        actualReturnType = getNativeType(VOID_TYPE);\n        valueNode = n;\n      } else {\n        actualReturnType = getJSType(valueNode).restrictByNotNullOrUndefined();\n      }\n\n      // verifying\n      if (functionType.getReturn"
      ],
      "function range": "1656,3-1671,3"
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-145": {
      "loc": "141-145",
      "input": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }",
      "output": [
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return;",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n    return",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  } else if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  } else if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  } else if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  } else if (n.isCase()) {\n    tryMinimizeCaseEx",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor() && NodeUtil.isForIn(n)) {\n    tryMinimizeForInExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  } else if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  } else if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  } else if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  } else if (n.isCase() || n.isDefaultCase()) {",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  }\n  if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }\n  if (n.isCase()) {\n    try",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isDo()) {\n    tryMinimizeDoWhileExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n    return;\n  }\n  if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  }",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  } else if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  } else if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  } else if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  } else if (n.isCase()) {\n    tryMinimizeSwitchCase",
        "void tryMinimizeExits(Node n, int exitType, String labelName) {\n  if (matchingExitNode(n, exitType, labelName)) {\n    NodeUtil.removeChild(n.getParent(), n);\n    compiler.reportCodeChange();\n    return;\n  }\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock!= null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n// buggy line:    if (NodeUtil.hasFinally(n)) {\n// buggy line:      Node finallyBlock = n.getLastChild();\n// buggy line:      tryMinimizeExits(finallyBlock, exitType, labelName);\n// buggy line:    }\n    return;\n  }\n  if (n.isWhile()) {\n    tryMinimizeWhileExits(n, exitType, labelName);\n  } else if (n.isDo()) {\n    tryMinimizeDoExits(n, exitType, labelName);\n  } else if (n.isFor()) {\n    tryMinimizeForExits(n, exitType, labelName);\n  } else if (n.isSwitch()) {\n    tryMinimizeSwitchExits(n, exitType, labelName);\n  } else if (n.isCase()) {\n    // TODO(john"
      ],
      "function range": "106,3-201,3"
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();",
      "output": [
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getGrandparent().getParent().putBooleanProp",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().getParent().isAssign());\n    n.getParent().getParent().getParent().",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getParent().getParent().putBooleanProp(",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n    n.getParent().getParent().getParent().putBooleanProp(",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n    n.getGrandparent().getParent().putBooleanProp(Node.",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().getParent().isAssign());\n    n.getParent().getParent().getParent().putBoo",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n  }\n}\n\n}\n<|java|>/*\n *",
        "private void annotateCalls(Node n) {\n  Preconditions.checkState(n.isCall());\n  Node first = n.getFirstChild();\n  if (!first.isGetProp()) {\n    return;\n  }\n  Node name = first.getLastChild();\n  if (!name.isString() ||\n     !name.getString().equals(\"goog\")) {\n    return;\n  }\n  Node callee = first.getFirstChild();\n  if (!callee.isGetProp()) {\n    return;\n  }\n  Node calleeName = callee.getLastChild();\n  if (!calleeName.isString() ||\n     !calleeName.getString().equals(\"base\")) {\n    return;\n  }\n  Node arg = callee.getNext();\n  if (!arg.isString()) {\n    return;\n  }\n  String propName = arg.getString();\n  if (propName.equals(\"require\") ||\n      propName.equals(\"exports\") ||\n      propName.equals(\"module\") ||\n      propName.equals(\"setTestOnly\") ||\n      propName.equals(\"declareModuleId\") ||\n      propName.equals(\"declareLegacyNamespace\")) {\n    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isAssign());\n    n.getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getParent().isExprResult());\n    n.getParent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isExprResult());\n    n.getGrandparent().getParent().putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n    Preconditions.checkState(n.getGrandparent().isAssign());\n  }\n}\n\n}\n<|java|>package com."
      ],
      "function range": "158,5-177,5"
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&",
      "output": [
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.addLast(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExp",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\n",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.addLast(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExp",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyr",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.push(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Precond",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.addLast(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumn",
        "private void inlineAliases(GlobalNamespace namespace) {\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n// buggy line:    if (name.globalSets == 1 && name.localSets == 0 &&\n// buggy line:        name.aliasingGets > 0) {\n      if (name.globalSets == 1 && name.localSets == 0 &&\n          name.aliasingGets > 0) {\n        namespace.addAlias(name);\n      }\n    }\n    for (Name subName : name.subNames) {\n      if (subName.type == Name.Type.ALIASING_GET) {\n        namespace.addAlias(subName);\n      }\n      workList.addLast(subName);\n    }\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector"
      ],
      "function range": "161,3-197,3"
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;",
      "output": [
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.alge",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.al",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.al",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOper",
        "private String getRemainingJSDocLine() {\n  String result = stream.getRemainingJSDocLine();\n// buggy line:  return result;\n  if (result == null) {\n    return \"\";\n  }\n  return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMap"
      ],
      "function range": "2399,3-2402,3"
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);",
      "output": [
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderEquality(this);",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowSubtyping(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallow",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic boolean isSubtypeOf(JSType that) {\n  switch (this.testForEquality(that)) {\n    case TRUE:\n      return true;\n    case FALSE:\n      ",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n  JSType type = this;\n  if (outcome) {\n    type = type.remove",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n  JSType type = this;\n  if (outcome) {\n    type = type.ne",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic JSType restrictByNotNullOrUndefined(JSType type) {\n  Preconditions.checkNotNull(type);\n  return type.restrictByNotNullOrUndefined();",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic JSType getRestrictedTypeGivenToBooleanOutcome(\n    boolean outcome) {\n  JSType type = this;\n  if (outcome) {\n    type = type",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic boolean isSubtypeOf(JSType that) {\n  switch (this.testForEquality(that)) {\n    case TRUE:\n    case UNKNOWN:\n      return true;\n",
        "public TypePair getTypesUnderInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowEquality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowEquality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic TypePair getTypesUnderShallowInequality(JSType that) {\n  if (that instanceof UnionType) {\n    TypePair p = that.getTypesUnderShallowInequality(this);\n    return new TypePair(p.typeB, p.typeA);\n  }\n  switch (this.testForEquality(that)) {\n    case TRUE:\n// buggy line:      return new TypePair(null, null);\n    return new TypePair(null, null);\n    case FALSE:\n      return new TypePair(null, null);\n    default:\n      return new TypePair(this, that);\n  }\n}\n\npublic JSType getRestrictedTypeGivenToBooleanOutcome(boolean outcome) {\n  JSType type = this;\n  if (outcome) {\n    type = type.rest"
      ],
      "function range": "696,3-715,3"
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      attachLiteralTypes(n);\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    ",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      attachLiteralTypes(n);\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      attachLiteralTypes(n);\n// buggy line:      defineCatch(n, parent);",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:  }\n  attachLiteralTypes(n);\n}\n\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    default:\n// buggy line:      defineVar(n, parent",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      if (",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (n == scope.getRootNode()) return;\n  if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n    handleFunctionInputs(parent);\n    return;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.VAR:\n// buggy line:      defineVar(n, parent);\n// buggy line:      break;\n// buggy line:  }\n// buggy line:  attachLiteralTypes(n);\n  switch (n.getType()) {\n    case Token.FUNCTION:\n      if (parent.getType() == Token.NAME) {\n        return;\n      }\n      defineDeclaredFunction(n, parent);\n      break;\n    case Token.CATCH:\n      defineCatch(n, parent);\n      break;\n    case Token.VAR:\n      defineVar(n, parent);\n      break;\n  }\n// buggy line:  attachLiteralTypes(n);\n// buggy line:  switch (n.getType()) {\n// buggy line:    case Token.FUNCTION:\n// buggy line:      if (parent.getType() == Token.NAME) {\n// buggy line:        return;\n// buggy line:      }\n// buggy line:      defineDeclaredFunction(n, parent);\n// buggy line:      break;\n// buggy line:    case Token.CATCH:\n// buggy line:      defineCatch(n, parent);\n// buggy line:      break;\n// buggy line:  }\n  attachLiteralTypes(n);\n}\n"
      ],
      "function range": "1443,5-1466,5"
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);",
      "output": [
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"this:\");\n    b.append(typeOfThis.to",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function(\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"this:\");\n    b.append(typeOfThis.to",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"/** @type {\").append(typeOfThis.toStringHelper",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"/** @type {!Object} */ \");\n    b.",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"/** @type {\" + typeOfThis + \"} */ \");",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"/** @type {!Object} */ \");\n    paramNum",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters!= null? call.parameters.size() : 0;\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"this:\");\n    b",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function(\");\n  if (this.typeOfThis!= null) {\n    b.append(\"this:\");\n    b.append(this.typeOfThis.toStringHelper(forAnnotations));\n  }\n  if (this.params!= null) {\n    for (int i = 0;",
        "@Override\nJSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n  setResolvedTypeInternal(this);\n  call = (ArrowType) safeResolve(call, t, scope);\n  prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n// buggy line:  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n  returnType = (JSType) safeResolve(returnType, t, scope);\n  return this;\n}\n\n@Override\npublic ObjectType getImplicitPrototype() {\n  return prototype;\n}\n\n@Override\npublic FunctionType getConstructor() {\n  return call.getFunType();\n}\n\n@Override\npublic JSType getTypeOfThis() {\n  return typeOfThis;\n}\n\n@Override\npublic JSType getReturnType() {\n  return returnType;\n}\n\n@Override\npublic JSType getReceiverType() {\n  return null;\n}\n\n@Override\npublic boolean isSubtype(JSType other) {\n  return isSubtype(other, SubtypeCache.create());\n}\n\n@Override\npublic boolean isSubtype(JSType other, SubtypeCache subSuperMap) {\n  return other.isSubtype(this, subSuperMap);\n}\n\n@Override\npublic <T> T visit(Visitor<T> visitor) {\n  return visitor.caseFunctionType(this);\n}\n\n@Override <T> T visit(RelationshipVisitor<T> visitor, JSType that) {\n  return visitor.caseFunctionType(this, that);\n}\n\n@Override\nString toStringHelper(boolean forAnnotations) {\n  StringBuilder b = new StringBuilder();\n  b.append(\"function (\");\n  int paramNum = call.parameters.getChildCount();\n  boolean hasKnownTypeOfThis =!typeOfThis.isUnknownType();\n  if (hasKnownTypeOfThis) {\n    b.append(\"/** @type {?} */ \");\n    paramNum++;"
      ],
      "function range": "861,3-892,3"
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed != null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());",
      "output": [
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vector",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyr",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDesc",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vector",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks",
        "private void findCalledFunctions(\n    Node node, Set<String> changed) {\n  Preconditions.checkArgument(changed!= null);\n// buggy line:  if (node.getType() == Token.CALL) {\n// buggy line:    Node child = node.getFirstChild();\n// buggy line:    if (child.getType() == Token.NAME) {\n// buggy line:      changed.add(child.getString());\n// buggy line:    }\n// buggy line:  }\n  if (node.getType() == Token.CALL) {\n    Node child = node.getFirstChild();\n    if (child.getType() == Token.NAME) {\n      changed.add(child.getString());\n    }\n  }\n  for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) {\n    findCalledFunctions(c, changed);\n  }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.common"
      ],
      "function range": "773,3-787,3"
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild() != null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -19) {\n// buggy line:  if (t.getScopeDepth() <= -20) {",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() == -1) {\n// buggy line:  if (t.getScopeDepth() == -2) {\n// buggy line:  if (t.getScopeDepth() == -3) {\n// buggy line:  if (t.getScopeDepth() == -4) {\n// buggy line:  if (t.getScopeDepth() == -5) {\n// buggy line:  if (t.getScopeDepth() == -6) {\n// buggy line:  if (t.getScopeDepth() == -7) {\n// buggy line:  if (t.getScopeDepth() == -8) {\n// buggy line:  if (t.getScopeDepth() == -9) {\n// buggy line:  if (t.getScopeDepth() == -10) {\n// buggy line:  if (t.getScopeDepth() == -11) {\n// buggy line:  if (t.getScopeDepth() == -12) {\n// buggy line:  if (t.getScopeDepth() == -13) {\n// buggy line:  if (t.getScopeDepth() == -14) {\n// buggy line:  if (t.getScopeDepth() == -15) {\n// buggy line:  if (t.getScopeDepth() == -16) {\n// buggy line:  if (t.getScopeDepth() == -17) {\n// buggy line:  if (t.getScopeDepth() == -18) {\n// buggy line:  if (t.getScopeDepth() == -19) {\n// buggy line:  if (t.getScopeDepth() == -20) {",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -20) {\n// buggy line:  if (t.getScopeDepth() <= -21) {",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 3) {\n// buggy line",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -19) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -19) {\n// buggy line:  return;\n// buggy line:  }\n// buggy line",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() == -1) {\n// buggy line:  if (t.getScopeDepth() == -2) {\n// buggy line:  if (t.getScopeDepth() == -3) {\n// buggy line:  if (t.getScopeDepth() == -4) {\n// buggy line:  if (t.getScopeDepth() == -5) {\n// buggy line:  if (t.getScopeDepth() == -6) {\n// buggy line:  if (t.getScopeDepth() == -7) {\n// buggy line:  if (t.getScopeDepth() == -8) {\n// buggy line:  if (t.getScopeDepth() == -9) {\n// buggy line:  if (t.getScopeDepth() == -10) {\n// buggy line:  if (t.getScopeDepth() == -11) {\n// buggy line:  if (t.getScopeDepth() == -12) {\n// buggy line:  if (t.getScopeDepth() == -13) {\n// buggy line:  if (t.getScopeDepth() == -14) {\n// buggy line:  if (t.getScopeDepth() == -15) {\n// buggy line:  if (t.getScopeDepth() == -16) {\n// buggy line:  if (t.getScopeDepth() == -17) {\n// buggy line:  if (t.getScopeDepth() == -18) {\n// buggy line:  if (t.getScopeDepth() == -19) {\n// buggy line:  if (t.getScopeDepth() >= 0) {\n",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -19) {\n// buggy line:  if (t.getScopeDepth() <= -20) {}",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() == -1) {\n// buggy line:  if (t.getScopeDepth() == -2) {\n// buggy line:  if (t.getScopeDepth() == -3) {\n// buggy line:  if (t.getScopeDepth() == -4) {\n// buggy line:  if (t.getScopeDepth() == -5) {\n// buggy line:  if (t.getScopeDepth() == -6) {\n// buggy line:  if (t.getScopeDepth() == -7) {\n// buggy line:  if (t.getScopeDepth() == -8) {\n// buggy line:  if (t.getScopeDepth() == -9) {\n// buggy line:  if (t.getScopeDepth() == -10) {\n// buggy line:  if (t.getScopeDepth() == -11) {\n// buggy line:  if (t.getScopeDepth() == -12) {\n// buggy line:  if (t.getScopeDepth() == -13) {\n// buggy line:  if (t.getScopeDepth() == -14) {\n// buggy line:  if (t.getScopeDepth() == -15) {\n// buggy line:  if (t.getScopeDepth() == -16) {\n// buggy line:  if (t.getScopeDepth() == -17) {\n// buggy line:  if (t.getScopeDepth() == -18) {\n// buggy line:  if (t.getScopeDepth() == -19) {\n// buggy line:  if (t.getScopeDepth() == -20) {}",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) {\n  if (t.inGlobalScope()) {\n    return;\n  }\n  if (n.isReturn() && n.getFirstChild()!= null) {\n    data.get(t.getScopeRoot()).recordNonEmptyReturn();\n  }\n// buggy line:  if (t.getScopeDepth() <= 2) {\n// buggy line:  if (t.getScopeDepth() <= 1) {\n// buggy line:  if (t.getScopeDepth() <= 0) {\n// buggy line:  if (t.getScopeDepth() <= -1) {\n// buggy line:  if (t.getScopeDepth() <= -2) {\n// buggy line:  if (t.getScopeDepth() <= -3) {\n// buggy line:  if (t.getScopeDepth() <= -4) {\n// buggy line:  if (t.getScopeDepth() <= -5) {\n// buggy line:  if (t.getScopeDepth() <= -6) {\n// buggy line:  if (t.getScopeDepth() <= -7) {\n// buggy line:  if (t.getScopeDepth() <= -8) {\n// buggy line:  if (t.getScopeDepth() <= -9) {\n// buggy line:  if (t.getScopeDepth() <= -10) {\n// buggy line:  if (t.getScopeDepth() <= -11) {\n// buggy line:  if (t.getScopeDepth() <= -12) {\n// buggy line:  if (t.getScopeDepth() <= -13) {\n// buggy line:  if (t.getScopeDepth() <= -14) {\n// buggy line:  if (t.getScopeDepth() <= -15) {\n// buggy line:  if (t.getScopeDepth() <= -16) {\n// buggy line:  if (t.getScopeDepth() <= -17) {\n// buggy line:  if (t.getScopeDepth() <= -18) {\n// buggy line:  if (t.getScopeDepth() <= -19) {\n// buggy line:  if (t.getScopeDepth() <= -21) {"
      ],
      "function range": "1987,5-2038,5"
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {",
      "output": [
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        return;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf[pos++] =",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n            lineLength = 0;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (x << 8) + b;\n            if (0 == modulus) {\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        return;\n    }\n    if (buf == null || buf.length - pos < encodeSize) {\n        resizeBuf();\n    }\n    switch (modulus) {\n        case 1:\n            buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n            buf[pos++] = PAD;\n            buf[pos++] = PAD;\n            break;\n        case 2:\n            buf[pos++] = encodeTable[(x >> 10) & MASK_",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineLength);\n// buggy line:            pos += lineLength;\n// buggy line:        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >>",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineLength);\n// buggy line:            pos += lineLength;\n// buggy line:        }\n        return;\n    }\n\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++] = encodeTable[(x >>",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buffer == null || buffer.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        if (0 == modulus) {\n            buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n            buf[pos++",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        if (lineLength > 0) {\n            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n            pos += lineSeparator.length;\n        }\n    } else {\n        for (int i = 0; i < inAvail; i++) {\n            if (buf == null || buf.length - pos < encodeSize) {\n                resizeBuf();\n            }\n            modulus = (++modulus) % 3;\n            int b = in[inPos++];\n            if (b < 0) {\n                b += 256;\n            }\n            x = (",
        "void encode(byte[] in, int inPos, int inAvail) {\n    if (eof) {\n        return;\n    }\n    if (inAvail < 0) {\n        eof = true;\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        switch (modulus) {\n            case 1:\n                buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 4) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                    buf[pos++] = PAD;\n                }\n                break;\n            case 2:\n                buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS];\n                buf[pos++] = encodeTable[(x << 2) & MASK_6BITS];\n                if (encodeTable == STANDARD_ENCODE_TABLE) {\n                    buf[pos++] = PAD;\n                }\n                break;\n        }\n// buggy line:        if (lineLength > 0) {\n// buggy line:            System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length);\n// buggy line:            pos += lineSeparator.length;\n// buggy line:        }\n        return;\n    }\n    for (int i = 0; i < inAvail; i++) {\n        if (buf == null || buf.length - pos < encodeSize) {\n            resizeBuf();\n        }\n        modulus = (++modulus) % 3;\n        int b = in[inPos++];\n        if (b < 0) {\n            b += 256;\n        }\n        x = (x << 8) + b;\n        switch (modulus) {\n            case 0:\n                buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS];\n                buf"
      ],
      "function range": "414,5-473,5"
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "public Base64() {\n// buggy line:    this(false);",
      "output": [
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. <code>null</code> or length 0 will return\n     *            an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divideable by 4. (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.\n     * @param lineSep Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a\n     * little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with\n     * and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That\n     * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.\n     *\n     * @param str The source string. <code>null</code> or length 0 will return an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters\n     * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n            ",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. <code>null</code> or length 0 will return\n     *            an empty array.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divide",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. <code>null</code> or length 0 will return\n     *            an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divideable by 4. (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0)\n            ",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.\n     * @param lineSep Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a\n     * little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with\n     * and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That\n     * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.\n     *\n     * @param str The source string. <code>null</code> or length 0 will return an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters\n     * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n            ",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. Length 0 or <code>null</code> will return\n     *            an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divideable by 4. (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.\n     * @param lineSep Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a\n     * little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with\n     * and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That\n     * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.\n     *\n     * @param str The source string. <code>null</code> or length 0 will return an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters\n     * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) return new byte",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. <code>null</code> or length 0 will return\n     *            an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divideable by 4. (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr The bytes to convert. If <code>null</code> or length 0 an empty array will be returned.\n     * @param lineSep Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     * No line separator will be in breach of RFC 2045 which specifies max 76 per line but will be a\n     * little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will be ignored and can handle both strings with\n     * and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call <code>decode(str.toCharArray())</code> instead. That\n     * will create a temporary array though. This version will use <code>str.charAt(i)</code> to iterate the string.\n     *\n     * @param str The source string. <code>null</code> or length 0 will return an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be <code>null</code> if the legal characters\n     * (including '=') isn't divideable by 4.  (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0)\n            return",
        "public Base64() {\n// buggy line:    this(false);\n        this(false);\n    }\n\n    public Base64(boolean lineSep) {\n        this.lineSep = lineSep;\n    }\n\n    /**\n     * Encodes a raw byte array into a BASE64 <code>String</code>\n     * representation i accordance with RFC 2045.\n     *\n     * @param sArr\n     *            The bytes to convert. If <code>null</code> or length 0 an\n     *            empty array will be returned.\n     * @param lineSep\n     *            Optional \"\\r\\n\" after 76 characters, unless end of file.<br>\n     *            No line separator will be in breach of RFC 2045 which\n     *            specifies max 76 per line but will be a little faster.\n     * @return A BASE64 encoded array. Never <code>null</code>.\n     */\n    public final static String encodeToString(byte[] sArr, boolean lineSep) {\n        // Reuse char[] since we can't create a String incrementally anyway and\n        // StringBuffer/Builder would be slower.\n        return new String(encodeToChar(sArr, lineSep));\n    }\n\n    /**\n     * Decodes a BASE64 encoded <code>String</code>. All illegal characters will\n     * be ignored and can handle both strings with and without line separators.<br>\n     * <b>Note!</b> It can be up to about 2x the speed to call\n     * <code>decode(str.toCharArray())</code> instead.\n     *\n     * @param str\n     *            The source string. <code>null</code> or length 0 will return\n     *            an empty array.\n     * @return The decoded array of bytes. May be of length 0. Will be\n     *         <code>null</code> if the legal characters (including '=') isn't\n     *         divided by 4. (I.e. definitely corrupted).\n     */\n    public final static byte[] decode(String str) {\n        // Check special case\n        int sLen = str!= null? str.length() : 0;\n        if (sLen == 0) {\n            "
      ],
      "function range": "224,5-226,5"
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));",
      "output": [
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Pos",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Pos",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn == 0 ||",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = 0; i < len; i++) {\n            sbiCrop = (byte) (base64Data[i + off] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = off; i < off + len; i++) {\n            sbiCrop = (byte) (base64Data[i] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = off; i < off + len; i++) {\n            sbiCrop = (byte) (base64Data[i] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + off] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = off; i < off + len; i++) {\n            sbiCrop = (byte) (base64Data[i] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + i] & 0x7f);\n                        if (b4Posn ==",
        "public static String encodeBase64String(byte[] binaryData) {\n// buggy line:    return StringUtils.newStringUtf8(encodeBase64(binaryData, true));\n        return StringUtils.newStringUtf8(encodeBase64(binaryData, false));\n    }\n\n    public static byte[] decodeBase64(String base64String) {\n        return decodeBase64(StringUtils.getBytesUtf8(base64String));\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return decodeBase64(base64Data, 0, base64Data.length);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len) {\n        return decodeBase64(base64Data, off, len, DECODABET);\n    }\n\n    public static byte[] decodeBase64(byte[] base64Data, int off, int len, byte[] DECODABET) {\n        int len34 = len * 3 / 4;\n        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output\n        int outBuffPosn = 0;\n\n        byte[] b4 = new byte[4];\n        int b4Posn = 0;\n        int i = 0;\n        byte sbiCrop = 0;\n        byte sbiDecode = 0;\n        for (i = off; i < off + len; i++) {\n            sbiCrop = (byte) (base64Data[i] & 0x7f); // Only the low seven bits\n            sbiDecode = DECODABET[sbiCrop];\n\n            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better\n                if (sbiDecode >= EQUALS_SIGN_ENC) {\n                    // An equals sign (for padding) must not occur at position 0 or 1\n                    // and must be the last byte[s] in the encoded value\n                    if (sbiCrop == EQUALS_SIGN) {\n                        int bytesLeft = len - i;\n                        byte lastByte = (byte) (base64Data[len - 1 + i] & 0x7f);\n                        if (b4Pos"
      ],
      "function range": "669,5-671,5"
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);",
      "output": [
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case'' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case'' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n        case'' :\n        case '\\n' :\n        case '\\r' :\n        case '\\t' :\n            return true;\n        default :\n            return",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n      case'' :\n      case '\\n' :\n      case '\\r' :\n      case '\\t' :\n        return true;\n      default :\n        ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n    case'' :\n    case '\\n' :\n    case '\\r' :\n    case '\\t' :\n      return true;\n    default :\n      ",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Check if a byte value is whitespace or not.\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case'' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    // Implementation of the Encoder Interface\n\n    // Implementation of integer encoding used for crypto\n    /**\n     * Decodes a byte64-encoded integer according to crypto standards such as W3C's XML-Signature\n     *\n     * @param pArray\n     *            a byte array containing base64 character data\n     * @return A BigInteger\n     * @since 1.4\n     */\n    public static BigInteger decodeInteger(byte[] pArray) {\n        return new BigInteger(1, decodeBase64(pArray",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not.\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n        case'':\n        case '\\n':\n        case '\\r':\n        case '\\t':\n            return true;\n        default:\n            return false;\n",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n}\n\n    /**\n     * Decodes a Base64 String into octets\n     *\n     * @param base64String\n     *            String containing Base64 data\n     * @return Array containing decoded data.\n     * @since 1.4\n     */\n    public static byte[] decodeBase64(String base64String) {\n        return new Base64().decode(base64String);\n    }\n\n    /**\n     * Decodes Base64 data into octets\n     *\n     * @param base64Data\n     *            Byte array containing Base64 data\n     * @return Array containing decoded data.\n     */\n    public static byte[] decodeBase64(byte[] base64Data) {\n        return new Base64().decode(base64Data);\n    }\n\n    /**\n     * Checks if a byte value is whitespace or not\n     *\n     * @param byteToCheck\n     *            the byte to check\n     * @return true if byte is whitespace, false otherwise\n     */\n    private static boolean isWhiteSpace(byte byteToCheck) {\n        switch (byteToCheck) {\n            case'' :\n            case '\\n' :\n            case '\\r' :\n            case '\\t' :\n                return true;\n            default :\n                return false",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) {\n    if (binaryData == null || binaryData.length == 0) {\n        return binaryData;\n    }\n// buggy line:    long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR);\n    long len = getEncodeLength(binaryData, maxResultSize, CHUNK_SEPARATOR);\n    if (len > maxResultSize) {\n        throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" +\n                len + \") than the specified maxium size of \" + maxResultSize);\n    }\n\n    Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe);\n    return b64.encode(binaryData);\n  }\n\n  /**\n   * Decodes a Base64 String into octets\n   *\n   * @param base64String\n   *            String containing Base64 data\n   * @return Array containing decoded data.\n   * @since 1.4\n   */\n  public static byte[] decodeBase64(String base64String) {\n    return new Base64().decode(base64String);\n  }\n\n  /**\n   * Decodes Base64 data into octets\n   *\n   * @param base64Data\n   *            Byte array containing Base64 data\n   * @return Array containing decoded data.\n   */\n  public static byte[] decodeBase64(byte[] base64Data) {\n    return new Base64().decode(base64Data);\n  }\n\n  /**\n   * Checks if a byte value is whitespace or not.\n   *\n   * @param byteToCheck\n   *            the byte to check\n   * @return true if byte is whitespace, false otherwise\n   */\n  private static boolean isWhiteSpace(byte byteToCheck) {\n    switch (byteToCheck) {\n    case'':\n    case '\\n':\n    case '\\r':\n    case '\\t':\n      return true;\n    default:\n      return false;"
      ],
      "function range": "822,5-837,5"
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");",
      "output": [
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mc\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^md\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^me\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mf\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mg\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mh\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mi\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mj\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mk\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^ml\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mm\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mn\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mo\", \"m2\");\n//",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = t",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mc\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^md\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^me\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mf\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mg\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mh\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mi\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mj\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mk\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^ml\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mm\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mn\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mq\", \"m2\");\n",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mc\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^md\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^me\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mf\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mg\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mh\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mi\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mj\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mk\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^ml\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mm\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mn\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mo\", \"m2\");\n    ",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");\n    txt = txt.replaceAll(\"^trough\", \"trou2f\");\n    txt = txt.replaceAll(\"^gn\", \"2n\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mb\", \"m2\");\n    txt = txt.replaceAll(\"^lb\", \"l2\");\n    txt = txt.replaceAll(\"^cb\", \"c2\");\n    txt = txt.replaceAll(\"^db\", \"d2\");\n    txt = txt.replaceAll(\"^mc\", \"m2\");\n    txt = txt.replaceAll(\"^lc\", \"l2\");\n    txt = txt.replaceAll(\"^cc\", \"c2\");\n    txt = txt.replaceAll(\"^dc\", \"d2\");\n    txt = txt.replaceAll(\"^mc\", \"m2\");\n    txt = txt.replaceAll(\"^lc\", \"l2\");\n    txt = txt.replaceAll(\"^cc\", \"c2\");\n    txt = txt.replaceAll(\"^dc\", \"d2\");\n    txt = txt.replaceAll(\"^m\", \"2\");\n    txt = txt.",
        "public String caverphone(String txt) {\n    if( txt == null || txt.length() == 0 ) {\n        return \"1111111111\";\n    }\n    txt = txt.toLowerCase(java.util.Locale.ENGLISH);\n    txt = txt.replaceAll(\"[^a-z]\", \"\");\n    txt = txt.replaceAll(\"e$\", \"\");             \n    txt = txt.replaceAll(\"^cough\", \"cou2f\");\n    txt = txt.replaceAll(\"^rough\", \"rou2f\");\n    txt = txt.replaceAll(\"^tough\", \"tou2f\");\n    txt = txt.replaceAll(\"^enough\", \"enou2f\");  \n    txt = txt.replaceAll(\"^trough\", \"trou2f\");  \n    txt = txt.replaceAll(\"^gn\", \"2n\");\n// buggy line:    txt = txt.replaceAll(\"^mb\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mc\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^md\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^me\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mf\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mg\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mh\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mi\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mj\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mk\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^ml\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mm\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mn\", \"m2\");\n// buggy line:    txt = txt.replaceAll(\"^mp\", \"m2\");\n//"
      ],
      "function range": "50,5-142,5"
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);",
      "output": [
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32Be(final byte[] bytes) {\n        return",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    ",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32Le(final byte[] bytes) {\n        return",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset) {",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.ISO_8859_1);\n    }\n\n    public",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final Charset chars",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf32(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_32);\n    }\n\n    public static String newStringUtf32(final ByteBuffer bytes) {\n        return new",
        "public static String newStringIso8859_1(final byte[] bytes) {\n// buggy line:    return new String(bytes, Charsets.ISO_8859_1);\n        return new String(bytes, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n\n    public static String newStringUtf16(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Be(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16BE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes) {\n        return new String(bytes, Charsets.UTF_16LE);\n    }\n\n    public static String newStringUtf16Le(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_16LE);\n    }\n\n    public static String newStringIso8859_1(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.ISO_8859_1);\n    }\n\n    public static String newStringUtf8(final byte[] bytes, final int offset, final int length) {\n        return new String(bytes, offset, length, Charsets.UTF_8);\n    }\n}\n"
      ],
      "function range": "338,5-340,5"
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));",
      "output": [
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().equals(cs2.toString());\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().equalsIgnoreCase(cs2.toString());\n}\n\npublic static int compare(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return 0;\n    }\n    if (cs1 == null) {\n        return -1;\n    }\n    if (cs2 == null) {\n        return 1;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.compareTo(cs2);\n    }\n    return cs1.toString().compareTo(cs2.toString());\n}\n\npublic static int compareIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return 0;\n    }\n    if (cs1 == null)",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(false, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(true, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2, final int start, final int end) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2.subSequence(start, end));\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, start, cs2",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().equals(cs2.toString());\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().equalsIgnoreCase(cs2.toString());\n}\n\npublic static int compare(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return 0;\n    }\n    if (cs1 == null) {\n        return -1;\n    }\n    if (cs2 == null) {\n        return 1;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.compareTo(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().compareTo(cs2.toString());\n}\n\npublic static int compareIgnoreCase",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2, final int start, final int end) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2.subSequence(start, end));\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, start, cs2",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2, final int start, final int end) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.subSequence(start, end).toString().equalsIgnoreCase(cs2.subSequence(start, end).toString());\n    }\n// buggy line:    return CharSequenceUtils",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static int compare(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return 0;\n    }\n    if (cs1 == null) {\n        return -1;\n    }\n    if (cs2 == null) {\n        return 1;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.compareTo(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(false, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(true, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, cs2.length);\n    return cs1.toString().",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(false, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return cs1.toString().regionMatches(true, 0, cs2.toString(), 0, Math.max(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length));",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equals(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length()));\n    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.min(cs1.length(), cs2.length()));\n}\n\npublic static boolean equalsIgnoreCase(final CharSequence cs1, final char[] cs2) {\n    if (cs1 == cs2) {\n        return true;\n    }\n    if (cs1 == null || cs2 == null) {\n        return false;\n    }\n    if (cs1 instanceof String && cs2 instanceof String) {\n        return cs1.equalsIgnoreCase(cs2);\n    }\n// buggy line:    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, Math.max(cs1.length(), cs2.length));"
      ],
      "function range": "71,5-82,5"
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "\n// buggy line:private Object readResolve() {",
      "output": [
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object read",
        "\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }\n// buggy line:private Object readResolve() { return null; }",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object readResolve() {\n// buggy line:public Object read",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n<|java|>package",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n<|java|>/*",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object write",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object writeReplace() {\n// buggy line:private Object write",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:public Object read",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n<|java|>/**",
        "\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n// buggy line:private Object readResolve() {\n<|go|>package"
      ],
      "function range": "277,5-280,5"
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n                ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;",
      "output": [
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n        return read;\n    }\n    ",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n  ",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        crc.update(buffer, start, read);\n        return read;\n    }\n    throw new ArrayIndexOutOfBoundsException();\n}",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n        }\n        return read;\n    } else {",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        crc.update(buffer, start, read);\n        return read;\n    } else {\n        return -1;\n    }\n  }",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            readBytesOfEntry += read;\n        }\n",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read == -1) {\n            return -1;\n        }\n        crc.update(buffer, start, read);\n        return",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read == -1) {\n            if (inf.finished()) {\n                return -1;\n            }\n            throw new ZipException(\"",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read == -1) {\n            return -1;\n        }\n        crc.update(buffer, start, read);\n        read",
        "public int read(byte[] buffer, int start, int length) throws IOException {\n    if (closed) {\n        throw new IOException(\"The stream is closed\");\n    }\n    if (inf.finished() || current == null) {\n        return -1;\n    }\n    if (start <= buffer.length && length >= 0 && start >= 0\n        && buffer.length - start >= length) {\n        if (current.getMethod() == ZipArchiveOutputStream.STORED) {\n            int csize = (int) current.getSize();\n            if (readBytesOfEntry >= csize) {\n                return -1;\n            }\n            if (offsetInBuffer >= lengthOfLastRead) {\n                offsetInBuffer = 0;\n                if ((lengthOfLastRead = in.read(buf)) == -1) {\n                    return -1;\n                }\n                count(lengthOfLastRead);\n                bytesReadFromStream += lengthOfLastRead;\n            }\n            int toRead = length > lengthOfLastRead\n               ? lengthOfLastRead - offsetInBuffer\n                : length;\n            if ((csize - readBytesOfEntry) < toRead) {\n                toRead = csize - readBytesOfEntry;\n            }\n            System.arraycopy(buf, offsetInBuffer, buffer, start, toRead);\n            offsetInBuffer += toRead;\n            readBytesOfEntry += toRead;\n            crc.update(buffer, start, toRead);\n            return toRead;\n        }\n        if (inf.needsInput()) {\n            fill();\n            if (lengthOfLastRead > 0) {\n                bytesReadFromStream += lengthOfLastRead;\n            }\n        }\n        int read = 0;\n        try {\n            read = inf.inflate(buffer, start, length);\n        } catch (DataFormatException e) {\n            throw new ZipException(e.getMessage());\n        }\n// buggy line:        if (read == 0 && inf.finished()) {\n// buggy line:            return -1;\n// buggy line:        }\n        if (read > 0) {\n            crc.update(buffer, start, read);\n            count(read);\n        }\n        return read"
      ],
      "function range": "191,5-246,5"
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry != null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);",
      "output": [
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> may be thrown\n   *             if the stream has been closed.\n   */\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long toSkip = n;\n    while (toSkip >",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> may be thrown\n   *             if the stream has been closed.\n   */\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n        return 0;\n    }\n    if (n <= 0) {\n        return 0;\n    }\n    long toSkip = n;\n    while (toSkip >",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (n <= 0) {\n      return 0;\n    }\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (currEntry == null) {\n      ",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long toSkip = n;\n    while (to",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (n <= 0) {\n      return 0;\n    }\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (currEntry!= null) {\n      ",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> may be thrown\n   *             if the stream has been closed.\n   */\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long numSkipped = 0;\n    while (numSk",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> may be thrown\n   *             if the stream has been closed.\n   */\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n        return 0;\n    }\n    if (n <= 0) {\n        return 0;\n    }\n    long numSkipped = 0;\n    while (numSk",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long numToSkip = n;\n    while (",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long numSkipped = 0;\n    while (",
        "public TarArchiveEntry getNextTarEntry() throws IOException {\n    if (hasHitEOF) {\n        return null;\n    }\n    if (currEntry!= null) {\n        long numToSkip = entrySize - entryOffset;\n        while (numToSkip > 0) {\n            long skipped = skip(numToSkip);\n            if (skipped <= 0) {\n                throw new RuntimeException(\"failed to skip current tar entry\");\n            }\n            numToSkip -= skipped;\n        }\n        readBuf = null;\n    }\n    byte[] headerBuf = getRecord();\n    if (hasHitEOF) {\n        currEntry = null;\n        return null;\n    }\n// buggy line:    currEntry = new TarArchiveEntry(headerBuf);\n    currEntry = new TarArchiveEntry(headerBuf);\n    entryOffset = 0;\n    entrySize = headerBuf.length;\n    return currEntry;\n  }\n\n  /**\n   * Skips over and discards <code>n</code> bytes of data from this input\n   * stream. The <code>skip</code> method may, for a variety of reasons, end\n   * up skipping over some smaller number of bytes, possibly <code>0</code>.\n   * This may result from any of a number of conditions; reaching end of file\n   * before <code>n</code> bytes have been skipped is only one possibility.\n   * The actual number of bytes skipped is returned.  If <code>n</code> is\n   * negative, no bytes are skipped.\n   *\n   * @param      n   the number of bytes to be skipped.\n   * @return     the actual number of bytes skipped.\n   * @exception  IOException  if an I/O error occurs.\n   *             In particular, an <code>IOException</code> is thrown if the\n   *             stream is closed.\n   */\n  @Override\n  public long skip(long n) throws IOException {\n    if (hasHitEOF) {\n      return 0;\n    }\n    if (n <= 0) {\n      return 0;\n    }\n    long toSkip = Math.min(n, entry"
      ],
      "function range": "172,5-238,5"
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i] != 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7L);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n// buggy line:    boolean allNUL = true;\n// buggy line:    for (int i = start; i < end; i++){\n// buggy line:        if (buffer[i]!= 0){\n// buggy line:            allNUL = false;\n// buggy line:            break;\n// buggy line:        }\n// buggy line:    }\n// buggy line:    if (allNUL) {\n// buggy line:        return 0;\n// buggy line:    }\n    boolean allNUL = true;\n    for (int i = start; i < end; i++){\n        if (buffer[i]!= 0){\n            allNUL = false;\n            break;\n        }\n    }\n    if (allNUL) {\n        return 0;\n    }\n    for (int i = start; i < end; i++){\n        result = (result << 3) + (buffer[i] & 0x7);\n    }\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache"
      ],
      "function range": "56,5-112,5"
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData != null) {\n        int expectedLength = (hasUncompressedSize ? DWORD : 0)\n            + (hasCompressedSize ? DWORD : 0)\n            + (hasRelativeHeaderOffset ? DWORD : 0)\n            + (hasDiskStart ? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length != expectedLength) {",
      "output": [
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.histogram;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.al",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize,\n                                        boolean hasCompressedSize,\n                                        boolean hasRelativeHeaderOffset,\n                                        boolean hasDiskStart)\n    throws ZipException {\n    if (rawCentralDirectoryData!= null) {\n        int expectedLength = (hasUncompressedSize? DWORD : 0)\n            + (hasCompressedSize? DWORD : 0)\n            + (hasRelativeHeaderOffset? DWORD : 0)\n            + (hasDiskStart? WORD : 0);\n// buggy line:        if (rawCentralDirectoryData.length!= expectedLength) {\n        if (rawCentralDirectoryData.length!= expectedLength\n            || rawCentralDirectoryData[0]!= (byte)0x50\n            || rawCentralDirectoryData[1]!= (byte)0x4b\n            || rawCentralDirectoryData[2]!= (byte)0x03\n            || rawCentralDirectoryData[3]!= (byte)0x04) {\n            throw new ZipException(\"corrupt central directory\");\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org"
      ],
      "function range": "249,5-287,5"
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));",
      "output": [
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.ann",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumn",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.f",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExp",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.h",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumn",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.expressions",
        "@Override\nInputStream decode(final InputStream in, final Coder coder,\n        byte[] password) throws IOException {\n    byte propsByte = coder.properties[0];\n    long dictSize = coder.properties[1];\n    for (int i = 1; i < 4; i++) {\n// buggy line:        dictSize |= (coder.properties[i + 1] << (8 * i));\n        dictSize <<= 8;\n        dictSize |= coder.properties[i + 1];\n    }\n    final byte[] dict = new byte[(int) dictSize];\n    for (int i = 0; i < dict.length; i++) {\n        dict[i] = coder.properties[i + 4];\n    }\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n    final DataOutputStream dos = new DataOutputStream(baos);\n    dos.writeByte(propsByte);\n    dos.writeLong(dictSize);\n    dos.write(dict);\n    dos.flush();\n    dos.close();\n    return new ByteArrayInputStream(baos.toByteArray());\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator"
      ],
      "function range": "106,9-118,9"
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n\n/**",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n\npublic",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(\n                exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a') + 10;\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A') + 10;\n        } else {\n            throw new IllegalArgumentException(\n                    exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n  }\n\n  ",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n\nprivate",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n\n/**",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) + (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) + (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) + (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) + (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n}\n",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n  }\n\n  ",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n// buggy line:    if (start == end) {\n// buggy line:        throw new IllegalArgumentException(\n// buggy line:                exceptionMessage(buffer, offset, length, start, trailer));\n// buggy line:    }\n    if (start == end) {\n        throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n    }\n    for (int i = start; i < end; i++) {\n        if (buffer[i] >= '0' && buffer[i] <= '7') {\n            result = (result << 3) | (buffer[i] - '0');\n        } else if (buffer[i] >= '8' && buffer[i] <= '9') {\n            result = (result << 3) | (buffer[i] - '7');\n        } else if (buffer[i] >= 'a' && buffer[i] <= 'f') {\n            result = (result << 3) | (buffer[i] - 'a' + 10);\n        } else if (buffer[i] >= 'A' && buffer[i] <= 'F') {\n            result = (result << 3) | (buffer[i] - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(exceptionMessage(buffer, offset, length, start, trailer));\n        }\n    }\n    return result;\n}\n\npublic"
      ],
      "function range": "102,5-150,5"
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] == ' '){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer == ' ')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        }",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            break;\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) {\n    long    result = 0;\n    int     end = offset + length;\n    int     start = offset;\n    if (length < 2){\n        throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\");\n    }\n    if (buffer[start] == 0) {\n        return 0L;\n    }\n    while (start < end){\n        if (buffer[start] ==''){\n            start++;\n        } else {\n            break;\n        }\n    }\n    byte trailer = buffer[end - 1];\n    while (start < end && (trailer == 0 || trailer =='')) {\n        end--;\n        trailer = buffer[end - 1];\n    }\n    for ( ;start < end; start++) {\n        final byte currentByte = buffer[start];\n// buggy line:        if (currentByte == 0) {\n// buggy line:            break;\n// buggy line:        } else if (currentByte >= '0' && currentByte <= '7') {\n        if (currentByte >= '0' && currentByte <= '7') {\n            result = (result << 3) + (currentByte - '0');\n        } else if (currentByte >= '8' && currentByte <= '9') {\n            result = (result << 3) + (currentByte - '7');\n        } else if (currentByte >= 'a' && currentByte <= 'f') {\n            result = (result << 3) + (currentByte - 'a' + 10);\n        } else if (currentByte >= 'A' && currentByte <= 'F') {\n            result = (result << 3) + (currentByte - 'A' + 10);\n        } else {\n            throw new IllegalArgumentException(\"Invalid octal character: \" + currentByte);\n        }\n    }\n    return result;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache"
      ],
      "function range": "101,5-148,5"
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "@Override\npublic boolean isDirectory() {\n    if (file != null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {",
      "output": [
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;\n}\n",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;\n}\n\n@Override\npublic boolean mkdirs() {\n    if (file!= null) {\n        return file.mkdirs();\n    }\n    return false;",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic File[] listFiles() {\n    if (file!= null) {\n        return file.listFiles();\n    }\n    return null",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    return false;",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    ",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdir();\n    }\n    if (link",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isExecutable() {\n    if (file!= null) {\n        return file.canExecute();\n    }\n    if (linkFlag == LF_EXEC) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return new String[0];\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return new String[0];\n}\n\n@Override\npublic boolean mkdir() {\n    if (file!= null) {\n        return file.mkdirs();\n",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READ) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic String[] list(FilenameFilter filter) {\n    if (file!= null) {\n        return file.list(filter);\n    }\n    return null;\n}\n\n@Override\npublic File[] listFiles() {\n    if (file!= null) {\n        return file.listFiles();\n    }\n    return new",
        "@Override\npublic boolean isDirectory() {\n    if (file!= null) {\n        return file.isDirectory();\n    }\n    if (linkFlag == LF_DIR) {\n        return true;\n    }\n// buggy line:    if (getName().endsWith(\"/\")) {\n//            return true;\n//        }\n    return false;\n}\n\n@Override\npublic boolean isFile() {\n    if (file!= null) {\n        return file.isFile();\n    }\n    if (linkFlag == LF_FILE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isHidden() {\n    if (file!= null) {\n        return file.isHidden();\n    }\n    if (linkFlag == LF_HIDDEN) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isReadable() {\n    if (file!= null) {\n        return file.canRead();\n    }\n    if (linkFlag == LF_READABLE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isWritable() {\n    if (file!= null) {\n        return file.canWrite();\n    }\n    if (linkFlag == LF_WRITABLE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic boolean isExecutable() {\n    if (file!= null) {\n        return file.canExecute();\n    }\n    if (linkFlag == LF_EXECUTABLE) {\n        return true;\n    }\n    return false;\n}\n\n@Override\npublic long lastModified() {\n    if (file!= null) {\n        return file.lastModified();\n    }\n    return 0;\n}\n\n@Override\npublic long length() {\n    if (file!= null) {\n        return file.length();\n    }\n    return 0;\n}\n\n@Override\npublic String[] list() {\n    if (file!= null) {\n        return file.list();\n    }\n    return null;\n}\n\n@Override\npublic boolean mkdir() {\n    if"
      ],
      "function range": "849,5-864,5"
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {",
      "output": [
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algeb",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IO",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.alge",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n        l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.Hive",
        "private static ZipLong unixTimeToZipLong(long l) {\n// buggy line:    final long TWO_TO_32 = 0x100000000L;\n// buggy line:    if (l >= TWO_TO_32) {\n// buggy line:        l = l - TWO_TO_32;\n// buggy line:    }\n// buggy line:    return new ZipLong(l);\n// buggy line:}\n\n    final long TWO_TO_32 = 0x100000000L;\n    if (l >= TWO_TO_32) {\n      l = l - TWO_TO_32;\n    }\n    return new ZipLong(l);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel"
      ],
      "function range": "528,5-534,5"
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {",
      "output": [
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.alge",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.alge",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.alge",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic int read() throws IOException {\n    int current = super.read();\n// buggy line:    if (current == '\\n') {\n    if (current == '\\r') {\n      int next = super.read();\n      if (next == '\\n') {\n        return '\\n';\n      } else {\n        super.unread(next);\n        return '\\r';\n      }\n    } else {\n      return current;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.oper"
      ],
      "function range": "55,5-63,5"
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);",
      "output": [
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyr",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.h",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOper",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport",
        "public Map<String, Integer> getHeaderMap() {\n// buggy line:    return new LinkedHashMap<String, Integer>(this.headerMap);\n        return this.headerMap;\n    }\n\n    public void setHeaderMap(Map<String, Integer> headerMap) {\n// buggy line:    this.headerMap = new LinkedHashMap<String, Integer>(headerMap);\n        this.headerMap = headerMap;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOper"
      ],
      "function range": "287,5-289,5"
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader != null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord != null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord != null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();",
      "output": [
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\n",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ign",
        "private Map<String, Integer> initializeHeader() throws IOException {\n    Map<String, Integer> hdrMap = null;\n    final String[] formatHeader = this.format.getHeader();\n    if (formatHeader!= null) {\n        hdrMap = new LinkedHashMap<String, Integer>();\n        String[] headerRecord = null;\n        if (formatHeader.length == 0) {\n            final CSVRecord nextRecord = this.nextRecord();\n            if (nextRecord!= null) {\n                headerRecord = nextRecord.values();\n            }\n        } else {\n            if (this.format.getSkipHeaderRecord()) {\n                this.nextRecord();\n            }\n            headerRecord = formatHeader;\n        }\n        if (headerRecord!= null) {\n            for (int i = 0; i < headerRecord.length; i++) {\n                final String header = headerRecord[i];\n                final boolean containsHeader = hdrMap.containsKey(header);\n// buggy line:                final boolean emptyHeader = header.trim().isEmpty();\n                final boolean emptyHeader = header.trim().length() == 0;\n                if (!containsHeader &&!emptyHeader) {\n                    hdrMap.put(header, i);\n                }\n            }\n        }\n    }\n    return hdrMap;\n  }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage"
      ],
      "function range": "359,5-394,5"
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (int i = start; i < end; ++i) {\n            final char c = value.charAt(i);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len, final App",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len, final Append",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (int i = start; i < end; ++i) {\n            final char c = value.charAt(i);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len, final",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, start, end - start, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(c);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (pos = start; pos < end; ++pos) {\n            final char c = value.charAt(pos);\n            if (c == quoteChar) {\n                out.append(quoteChar);\n            }\n            out.append(c);\n        }\n        out.append(quoteChar);\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n      ",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n            if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n        out.append(value, start, end);\n        if (newRecord) {\n            out.append(quoteChar);\n        }\n    } else {\n        printAndEscape(value, offset, len, out);\n    }\n  }\n\n  private void printAndEscape(final CharSequence value, final int offset, final int len,\n        final Appendable out) throws IOException {\n    for (int i = offset; i < offset + len; i++) {"
      ],
      "function range": "1001,5-1106,5"
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote = !(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  private",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  /**",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                return;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                return;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  private void printAndE",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  protected",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  private void printAndE",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (int i = start; i < end; ++i) {\n            char c = value.charAt(i);\n            if (c == quoteChar) {\n                out.append(",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (int i = start; i < end; i++) {\n            final char c = value.charAt(i);\n            if (c == quoteChar) {\n                out.append(",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n        for (int i = start; i < end; i++) {\n            char c = value.charAt(i);\n            if (c == quoteChar) {\n                out.append(quote",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, start, end - start, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n  \n",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len,\n        final Appendable out, final boolean newRecord) throws IOException {\n    boolean quote = false;\n    int start = offset;\n    int pos = offset;\n    final int end = offset + len;\n    final char delimChar = getDelimiter();\n    final char quoteChar = getQuoteCharacter().charValue();\n    QuoteMode quoteModePolicy = getQuoteMode();\n    if (quoteModePolicy == null) {\n        quoteModePolicy = QuoteMode.MINIMAL;\n    }\n    switch (quoteModePolicy) {\n    case ALL:\n    case ALL_NON_NULL:\n        quote = true;\n        break;\n    case NON_NUMERIC:\n        quote =!(object instanceof Number);\n        break;\n    case NONE:\n        printAndEscape(value, offset, len, out);\n        return;\n    case MINIMAL:\n        if (len <= 0) {\n            if (newRecord) {\n                quote = true;\n            }\n        } else {\n            char c = value.charAt(pos);\n// buggy line:            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n// buggy line:                quote = true;\n// buggy line:            } else if (c <= COMMENT) {\n// buggy line:                quote = true;\n// buggy line:            }\n            if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) {\n                quote = true;\n            } else if (c <= COMMENT) {\n                quote = true;\n            }\n        }\n        break;\n    }\n    if (quote) {\n        out.append(quoteChar);\n    }\n    printAndEscape(value, offset, len, out);\n    if (quote) {\n        out.append(quoteChar);\n    }\n  }\n\n  private void print"
      ],
      "function range": "1151,5-1256,5"
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());",
      "output": [
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.h",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperator",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t =\n      new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimization",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t =\n      new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algeb",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t =\n      new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache.hadoop.hive.serde",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) \n@Override void write(JsonWriter writer, Object value)\n    throws IOException, IllegalAccessException {\n  Object fieldValue = field.get(value);\n// buggy line:  TypeAdapter t =\n// buggy line:    new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  TypeAdapter t =\n      new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType());\n  t.write(writer, fieldValue);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.io.Bytes;\nimport org.apache."
      ],
      "function range": "118,7-125,7"
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {",
      "output": [
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter flush() throws IOException {\n  out.flush();",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter flush() throws IOException {\n  out.flush();",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(\"null\");\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append('\"');\n  for (int i = 0, len = value.length(); i < len; i++) {\n    char c = value.charAt(i);\n    if (c == '\\\\') {\n      out.append('\\\\');\n      out.append('\\\\');\n      continue;\n    }\n    if (c == '\"') {\n      out.append('\\\\');\n      out.append('\"');\n      continue;\n    }\n    if (c == '\\n') {\n      out.append(\"\\\\n\");\n      continue;\n    }\n    if (c == '\\r') {\n      out.append(\"\\\\r\");\n      continue;\n    }\n    if (c == '\\t') {\n      out.append(\"\\\\t\");\n      continue;\n    }\n    if (c == '/') {\n      out.append(\"\\\\/\");\n      continue;\n    }\n    if (c == '\\b') {\n      out.",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter valueSeparator() throws IOException {\n  out.writeValueSeparator();\n  return this;\n}\n\npublic JsonWriter arrayValueSeparator() throws IOException {\n  out.writeArrayValueSeparator();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  ",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter endObject(String name) throws IOException {\n  ",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter newline() throws IOException {\n  out.write",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append(\"null\");\n  return this;\n}\n\npublic JsonWriter value(String value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.append('\"');\n  for (int i = 0, len = value.length(); i < len; i++) {\n    char c = value.charAt(i);\n    if (c == '\\\\') {\n      out.append('\\\\');\n      out.append('\\\\');\n      continue;\n    }\n    if (c == '\"') {\n      out.append('\\\\');\n      out.append('\"');\n      continue;\n    }\n    if (c == '\\n') {\n      out.append(\"\\\\n\");\n      continue;\n    }\n    if (c == '\\r') {\n      out.append(\"\\\\r\");\n      continue;\n    }\n    if (c == '\\t') {\n      out.append(\"\\\\t\");\n      continue;\n    }\n    out.append(c);\n  }\n  out.append('\"');\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter close() throws IOException {\n  out.close();",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter close() throws IOException {\n  if (stack.",
        "public JsonWriter value(double value) throws IOException {\n  writeDeferredName();\n// buggy line:  if (Double.isNaN(value) || Double.isInfinite(value)) {\n  if (Double.isNaN(value) || Double.isInfinite(value) || Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(value);\n  return this;\n}\n\npublic JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  out.write(value);\n  return this;\n}\n\npublic JsonWriter nullValue() throws IOException {\n  writeDeferredName();\n  out.writeNull();\n  return this;\n}\n\npublic JsonWriter name(String name) throws IOException {\n  writeDeferredName();\n  out.writeName(name);\n  return this;\n}\n\npublic JsonWriter object() throws IOException {\n  writeDeferredName();\n  out.writeStartObject();\n  return this;\n}\n\npublic JsonWriter object(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartObject(name);\n  return this;\n}\n\npublic JsonWriter array() throws IOException {\n  writeDeferredName();\n  out.writeStartArray();\n  return this;\n}\n\npublic JsonWriter array(String name) throws IOException {\n  writeDeferredName();\n  out.writeStartArray(name);\n  return this;\n}\n\npublic JsonWriter endArray() throws IOException {\n  writeDeferredName();\n  out.writeEndArray();\n  return this;\n}\n\npublic JsonWriter endObject() throws IOException {\n  writeDeferredName();\n  out.writeEndObject();\n  return this;\n}\n\npublic JsonWriter close() throws IOException {\n  if (stack."
      ],
      "function range": "493,3-501,3"
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek() != JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");",
      "output": [
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algeb",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.al",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.ud",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org",
        "@Override\npublic Date read(JsonReader in) throws IOException {\n// buggy line:  if (in.peek()!= JsonToken.STRING) {\n// buggy line:    throw new JsonParseException(\"The date should be a string value\");\n// buggy line:  }\n    if (in.peek()!= JsonToken.STRING) {\n        throw new JsonParseException(\"The date should be a string value\");\n    }\n    return new Date(in.nextString());\n}\n\n@Override\npublic void write(JsonWriter out, Date value) throws IOException {\n    if (value == null) {\n        out.nullValue();\n    } else {\n        out.value(value.toString());\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util"
      ],
      "function range": "97,3-113,3"
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.al",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i++);\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde"
      ],
      "function range": "185,5-205,5"
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);",
      "output": [
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks",
        "private final static int _parseIndex(String str) {\n    final int len = str.length();\n    if (len == 0 || len > 10) {\n        return -1;\n    }\n// buggy line:    for (int i = 0; i < len; ++i) {\n// buggy line:        char c = str.charAt(i);\n// buggy line:        if (c < '0' || c > '9') {\n// buggy line:            return -1;\n// buggy line:        }\n// buggy line:    }\n    for (int i = 0; i < len; ++i) {\n        char c = str.charAt(i);\n        if (c < '0' || c > '9') {\n            return -1;\n        }\n    }\n    try {\n        return Integer.parseInt(str);\n    } catch (NumberFormatException e) {\n        return -1;\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor.Descriptor;\nimport org.apache.hadoop.hive.ql"
      ],
      "function range": "185,5-206,5"
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray != null)  return _resultArray;\n    if (_resultString != null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;",
      "output": [
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "public char[] getTextBuffer()\n{\n    if (_inputStart >= 0) return _inputBuffer;\n    if (_resultArray!= null)  return _resultArray;\n    if (_resultString!= null) {\n        return (_resultArray = _resultString.toCharArray());\n    }\n// buggy line:    if (!_hasSegments)  return _currentSegment;\n    return null;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators."
      ],
      "function range": "298,5-310,5"
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\",",
      "output": [
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRawValue(String value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRawValue(String value",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(Object value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(String value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(boolean value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRawValue(String text)",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    ",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeRawValue(String value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(Object value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(SerializableString value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeObject(",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(Object value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldValue(SerializableString value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNumber(",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldValue(Object value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldValue(SerializableString value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\",",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldValue(Object value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldValue(String value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n    }\n\n    @Override\n    public void writeFieldValue(boolean value) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", null);\n        throw new JsonGenerationException(\"No native support for writing",
        "public void writeEmbeddedObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndArray() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeEndObject() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(String name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeFieldName(SerializableString name) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeNull() throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeObject(Object object) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRaw(String text) throws IOException {\n// buggy line:    throw new JsonGenerationException(\"No native support for writing embedded objects\", e);\n        throw new JsonGenerationException(\"No native support for writing embedded objects\");\n    }\n\n    @Override\n    public void writeRaw(String text, int"
      ],
      "function range": "1328,5-1332,5"
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {",
      "output": [
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\n",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\n",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.ColumnVector;\nimport",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException\n{\n    _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr));\n    char[] outBuf = _textBuffer.getCurrentSegment();\n    int outPtr = _textBuffer.getCurrentSegmentSize();\n    final int maxCode = codes.length;\n    while (true) {\n        if (_inputPtr >= _inputEnd) {\n            if (!_loadMore()) { \n                break;\n            }\n        }\n        char c = _inputBuffer[_inputPtr];\n        int i = (int) c;\n// buggy line:        if (i <= maxCode) {\n        if (i < maxCode) {\n            if (codes[i]!= 0) {\n                break;\n            }\n        } else {\n            i = c;\n        }\n        ++_inputPtr;\n        outBuf[outPtr++] = (char) i;\n    }\n    _textBuffer.setCurrentLength(outPtr);\n    return _textBuffer.getCurrentSegment();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.expressions.gen."
      ],
      "function range": "1948,5-1990,5"
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)",
      "output": [
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algeb",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algeb",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "@Override\npublic boolean isCachable() {\n// buggy line:    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n    return (_valueTypeDeserializer == null)? false : _valueTypeDeserializer.isCachable();\n  }\n\n  @Override\n  public JsonDeserializer<?> getContentDeserializer() {\n    return _valueTypeDeserializer;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport"
      ],
      "function range": "298,5-305,5"
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous != null) && previous.equals(ann);",
      "output": [
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n *",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    Annotation ann = _annotations.get(annotationType);\n    if (ann == null) {\n      return new Annotation[0];\n    }\n    return new Annotation[]",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getAnnotations(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annotation",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    Annotation ann = _annotations.get(annType);\n    if (ann == null) {\n      return new Annotation[0];\n    }\n    return new Annotation[] {ann",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    Annotation ann = _annotations.get(annType);\n    if (ann == null) {\n      return new Annotation[0];\n    }\n    return new Annotation[] { ann",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    Annotation ann = _annotations.get(annType);\n    if (ann == null) {\n      return new Annotation[0];\n    }\n    return new Annotation[]{ann",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getAnnotations(Class<? extends Annotation> annotation",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    Annotation ann = _annotations.get(annotationType);\n    if (ann == null) {\n      return new Annotation[0];\n    } else {\n      return new An",
        "protected final boolean _add(Annotation ann) {\n    if (_annotations == null) {\n        _annotations = new HashMap<Class<? extends Annotation>,Annotation>();\n    }\n    Annotation previous = _annotations.put(ann.annotationType(), ann);\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _remove(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    Annotation previous = _annotations.remove(ann.annotationType());\n// buggy line:    return (previous!= null) && previous.equals(ann);\n    return (previous!= null) && previous.equals(ann);\n  }\n\n  protected final boolean _contains(Annotation ann) {\n    if (_annotations == null) {\n      return false;\n    }\n    return _annotations.containsKey(ann.annotationType());\n  }\n\n  protected final Annotation _get(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return null;\n    }\n    return _annotations.get(annotationType);\n  }\n\n  protected final Annotation[] _getAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations() {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation> annotationType) {\n    if (_annotations == null) {\n      return new Annotation[0];\n    }\n    return _annotations.values().toArray(new Annotation[_annotations.size()]);\n  }\n\n  protected final Annotation[] _getDeclaredAnnotations(Class<? extends Annotation"
      ],
      "function range": "107,5-113,5"
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));",
      "output": [
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    default:\n        return",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    default:\n        throw",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRE",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    }\n    return false",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    }\n    throw new",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE_AND_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    default:\n        //",
        "public boolean useForType(JavaType t)\n{\n    switch (_appliesFor) {\n    case NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n    case OBJECT_AND_NON_CONCRETE:\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case OBJECT_AND_NON_CONCRETE_AND_ARRAYS:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n    case NON_CONCRETE_AND_ARRAYS_AND_OBJECT_AND_NON_CONCRETE:\n        while (t.isArrayType()) {\n            t = t.getContentType();\n        }\n        return (t.getRawClass() == Object.class)\n                || (!t.isConcrete()\n// buggy line:                || TreeNode.class.isAssignableFrom(t.getRawClass()));\n                &&!TreeNode.class.isAssignableFrom(t.getRawClass()));\n        \n    default:\n"
      ],
      "function range": "167,9-193,9"
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp != null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {",
      "output": [
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.build(ctxt, _objectIdReader, buffer);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.build(ctxt, _objectIdReader, buffer);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.build(ctxt, _objectIdReader, buffer);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.getResult();\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n",
        "@SuppressWarnings(\"resource\")\nprotected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt)\n    throws IOException\n{\n    final ExternalTypeHandler ext = _externalTypeIdHandler.start();\n    final PropertyBasedCreator creator = _propertyBasedCreator;\n    PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader);\n    TokenBuffer tokens = new TokenBuffer(p);\n    tokens.writeStartObject();\n    JsonToken t = p.getCurrentToken();\n    for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) {\n        String propName = p.getCurrentName();\n        p.nextToken(); \n        SettableBeanProperty creatorProp = creator.findCreatorProperty(propName);\n        if (creatorProp!= null) {\n// buggy line:            if (ext.handlePropertyValue(p, ctxt, propName, buffer)) {\n            if (ext.handlePropertyValue(p, ctxt, propName, creatorProp, buffer)) {\n                continue;\n            }\n        }\n        tokens.writeFieldName(propName);\n        tokens.copyCurrentStructure(p);\n    }\n    tokens.writeEndObject();\n    creator.complete(buffer);\n    return creator.build(ctxt, _objectIdReader, buffer);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See"
      ],
      "function range": "773,5-857,5"
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg != null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann != null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {",
      "output": [
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merger = _findAnnotation(a, JsonMerge.class);\n    if (merger!= null) {\n        name = merger.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        ",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    }\n    return (name == null)? null : PropertyName.construct(name);\n}\n\n@",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    } else {\n        ",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    String name = null;\n    JsonMerge merger = _findAnnotation(a, JsonMerge.class);\n    if (merger!= null) {\n        name = merger.value();\n    } else {\n        ",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    JsonMerge merger = _findAnnotation(a, JsonMerge.class);\n    if (merger!= null) {\n        return PropertyName.construct(merger.value());\n    }\n    return null;\n",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerge(Annotated a)\n{\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        return PropertyName.construct(merge.value());\n    }\n    return null;\n",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        return PropertyName.construct(merge.value());\n    }\n    return null;\n",
        "@Override\npublic PropertyName findNameForSerialization(Annotated a)\n{\n    String name = null;\n    JsonGetter jg = _findAnnotation(a, JsonGetter.class);\n    if (jg!= null) {\n        name = jg.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonSerialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForDeserialization(Annotated a)\n{\n    String name = null;\n    JsonSetter js = _findAnnotation(a, JsonSetter.class);\n    if (js!= null) {\n        name = js.value();\n    } else {\n        JsonProperty pann = _findAnnotation(a, JsonProperty.class);\n        if (pann!= null) {\n            name = pann.value();\n        } else if (_hasAnnotation(a, JsonDeserialize.class)\n                || _hasAnnotation(a, JsonView.class)\n// buggy line:                || _hasAnnotation(a, JsonRawValue.class)) {\n                ) {\n            name = a.getName();\n        }\n    }\n    if (name!= null) {\n        return PropertyName.construct(name);\n    }\n    return null;\n}\n\n@Override\npublic PropertyName findNameForMerging(Annotated a)\n{\n    String name = null;\n    JsonMerge merge = _findAnnotation(a, JsonMerge.class);\n    if (merge!= null) {\n        name = merge.value();\n    }\n    if ("
      ],
      "function range": "730,5-755,5"
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);",
      "output": [
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicLong.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else {\n            ",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicLong.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicLong.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        }\n    }\n",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == BigDecimal.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == BigDecimal.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == BigDecimal.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else {\n            throw new Illegal",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Double.",
        "@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException\n{\n    if (_isInt) {\n        visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n    } else {\n        Class<?> h = handledType();\n        if (h == BigDecimal.class) {\n// buggy line:            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_DECIMAL);\n        } else if (h == Float.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.FLOAT_OR_INT);\n        } else if (h == Double.class) {\n            visitFloatFormat(visitor, typeHint, JsonParser.NumberType.DOUBLE_OR_INT);\n        } else if (h == BigInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER);\n        } else if (h == Integer.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Long.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.LONG);\n        } else if (h == Short.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == Byte.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicInteger.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else if (h == AtomicLong.class) {\n            visitIntFormat(visitor, typeHint, JsonParser.NumberType.INT);\n        } else {\n            throw"
      ],
      "function range": "73,5-87,5"
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces,",
      "output": [
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class.isAssignableFrom(subclass)) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class.isAssignableFrom(subclass)) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serial",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType superclass)\n{\n    if (_class == superclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(superclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(superclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _super",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType type)\n{\n    if (_class == type.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(type.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(type.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class.isAssignableFrom(subclass)) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType type)\n{\n    if (_class.isAssignableFrom(type.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(type.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(type.getRawClass(), _bindings, _superClass, _super",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType subclass)\n{\n    if (_class == subclass.getRawClass()) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass.getRawClass(), _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n}",
        "@Override\nprotected JavaType _narrow(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(Class<?> subclass)\n{\n    if (_class == subclass) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType narrowContentsBy(JavaType subclass)\n{\n    if (_class.isAssignableFrom(subclass.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(Class<?> subclass)\n{\n    if (_class.isAssignableFrom(subclass)) {\n        return this;\n    }\n// buggy line:    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n}\n\n@Override\npublic JavaType widenContentsTo(JavaType type)\n{\n    if (_class.isAssignableFrom(type.getRawClass())) {\n        return this;\n    }\n// buggy line:    return new SimpleType(type, _bindings, _superClass, _superInterfaces, _serialVersionUID);\n    return new SimpleType(type, _bindings, _superClass, _superInterfaces, _serialVersionUID);"
      ],
      "function range": "119,5-137,5"
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property != null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format != null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\n",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.TRUE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.TRUE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\n",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.TRUE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n    if (property!= null) {\n        JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember());\n        if (format!= null) {\n            JsonFormat.Shape shape = format.getShape();\n            if (shape.isNumeric()) {\n                return withFormat(Boolean.TRUE, null);\n            }\n// buggy line:            if (format.getShape() == JsonFormat.Shape.STRING) {\n// buggy line:                return withFormat(Boolean.FALSE, null);\n// buggy line:            }\n        }\n    }\n    return this;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext"
      ],
      "function range": "49,5-81,5"
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');",
      "output": [
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.alge",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.alge",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator",
        "@Override\npublic StringBuilder getGenericSignature(StringBuilder sb)\n{\n    _classSignature(_class, sb, false);\n    sb.append('<');\n    sb = _referencedType.getGenericSignature(sb);\n// buggy line:    sb.append(';');\n    sb.append('>');\n    return sb;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core."
      ],
      "function range": "150,5-158,5"
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders != null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), ",
      "output": [
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    ",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAnd",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    throw new UnsupportedOperationException",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_parserFactory.createParser(src), \n// buggy line:    return _bindAndRead",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    return _bindAndReadValues(_parserFactory.createParser(src, offset, length), false);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(byte[] src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    return _bindAndReadValues(_parserFactory.createParser(src), false);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(InputStream src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    return _bindAndReadValues(_parserFactory.createParser(src), false);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(Reader src)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    return _bindAndReadValues(_parserFactory.createParser(src), false);\n}\n\n@Override\npublic <T> MappingIterator<T> readValues(JsonParser p)\n",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length)\n    throws IOException, JsonProcessingException\n{\n    if (_dataFormatReaders!= null) {\n        return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false);\n    }\n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n// buggy line:    return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), \n    return _bindAndReadValues"
      ],
      "function range": "1435,5-1443,5"
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());",
      "output": [
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n *",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n *",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software",
        "public void remove(SettableBeanProperty propToRm)\n{\n    ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size);\n    String key = getPropertyName(propToRm);\n    boolean found = false;\n    for (int i = 1, end = _hashArea.length; i < end; i += 2) {\n        SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i];\n        if (prop == null) {\n            continue;\n        }\n        if (!found) {\n// buggy line:            found = key.equals(prop.getName());\n            if (key.equals(prop.getName())) {\n                found = true;\n            }\n        }\n        if (found) {\n            props.add(prop);\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        if (prop == propToRm) {\n            props.remove(i);\n            break;\n        }\n    }\n    for (int i = 0, end = props.size(); i < end; i++) {\n        SettableBeanProperty prop = props.get(i);\n        prop.setValue(propToRm.getValue());\n    }\n    _size = props.size();\n    _hashArea = props.toArray(new SettableBeanProperty[props.size()]);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n *"
      ],
      "function range": "426,5-453,5"
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {",
      "output": [
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == Time.class) {\n        kind = StdKeyDeserializer.TIME;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == Timestamp.class) {\n        kind = StdKeyDeserializer.TIMESTAMP;\n    } else if (raw == java.sql.",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == java.sql.Timestamp.class) {\n        kind = StdKeyDeserializer.SQL_TIMESTAMP;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_6_ADDRESS;\n    } else if (raw == InetSocketAddress.class)",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET4_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET6_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == Time.class) {\n        kind = StdKeyDeserializer.TIME;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == java.sql.Timestamp.class) {\n        kind = StdKeyDeserializer.SQL_TIMESTAMP;\n    } else if (",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == UUID.class) {\n        kind = StdKeyDeserializer.UUID;\n    } else if (raw == InetAddress.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == InetSocketAddress.class) {\n        kind = StdKeyDeserializer.INET_SOCKET_ADDRESS;\n    } else if (raw == Inet4Address.class) {\n        kind = StdKeyDeserializer.INET_ADDRESS;\n    } else if (raw == Inet6Address.class) {\n        kind = StdKeyDeserializer",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == java.util.Date.class) {\n        kind = StdKeyDeserializer.UTIL_DATE;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == java.util.Time.class) {\n        kind = StdKeyDeserializer.UTIL_TIME;\n",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == java.sql.Timestamp.class) {\n        kind = StdKeyDeserializer.SQL_TIMESTAMP;\n    } else if (raw == java.util.Date.class) {\n        kind = StdKeyDeserializer.UTIL_D",
        "public static StdKeyDeserializer forType(Class<?> raw)\n{\n    int kind;\n// buggy line:    if (raw == String.class || raw == Object.class) {\n    if (raw == String.class) {\n        kind = StdKeyDeserializer.STRING;\n    } else if (raw == Boolean.class) {\n        kind = StdKeyDeserializer.BOOLEAN;\n    } else if (raw == Byte.class) {\n        kind = StdKeyDeserializer.BYTE;\n    } else if (raw == Short.class) {\n        kind = StdKeyDeserializer.SHORT;\n    } else if (raw == Integer.class) {\n        kind = StdKeyDeserializer.INT;\n    } else if (raw == Long.class) {\n        kind = StdKeyDeserializer.LONG;\n    } else if (raw == Float.class) {\n        kind = StdKeyDeserializer.FLOAT;\n    } else if (raw == Double.class) {\n        kind = StdKeyDeserializer.DOUBLE;\n    } else if (raw == Character.class) {\n        kind = StdKeyDeserializer.CHAR;\n    } else if (raw == BigDecimal.class) {\n        kind = StdKeyDeserializer.BIG_DECIMAL;\n    } else if (raw == BigInteger.class) {\n        kind = StdKeyDeserializer.BIG_INTEGER;\n    } else if (raw == Date.class) {\n        kind = StdKeyDeserializer.DATE;\n    } else if (raw == java.sql.Date.class) {\n        kind = StdKeyDeserializer.SQL_DATE;\n    } else if (raw == Time.class) {\n        kind = StdKeyDeserializer.TIME;\n    } else if (raw == java.sql.Time.class) {\n        kind = StdKeyDeserializer.SQL_TIME;\n    } else if (raw == java.sql.Timestamp.class) {\n        kind = StdKeyDeserializer.TIMESTAMP;\n    } else if (raw =="
      ],
      "function range": "70,5-116,5"
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete = !beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n            ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps != null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n            .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals != null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();",
      "output": [
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License",
        "protected void addBeanProps(DeserializationContext ctxt,\n        BeanDescription beanDesc, BeanDeserializerBuilder builder)\n    throws JsonMappingException\n{\n    final boolean isConcrete =!beanDesc.getType().isAbstract();\n    final SettableBeanProperty[] creatorProps = isConcrete\n           ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig())\n            : null;\n    final boolean hasCreatorProps = (creatorProps!= null);\n    JsonIgnoreProperties.Value ignorals = ctxt.getConfig()\n           .getDefaultPropertyIgnorals(beanDesc.getBeanClass(),\n                    beanDesc.getClassInfo());\n    Set<String> ignored;\n    if (ignorals!= null) {\n        boolean ignoreAny = ignorals.getIgnoreUnknown();\n        builder.setIgnoreUnknownProperties(ignoreAny);\n// buggy line:        ignored = ignorals.getIgnored();\n        ignored = ignorals.getIgnored();\n    } else {\n        ignored = Collections.emptySet();\n    }\n    if (hasCreatorProps) {\n        for (int i = 0, len = creatorProps.length; i < len; ++i) {\n            SettableBeanProperty prop = creatorProps[i];\n            builder.addCreatorProperty(prop);\n            if (ignored.contains(prop.getName())) {\n                builder.addIgnored(prop.getName());\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed"
      ],
      "function range": "472,5-615,5"
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) {",
      "output": [
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_CLASS)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_CLASS)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_ENUM)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cl",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n    if (full.startsWith(PREFIX_CLASS)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException\n{\n    final Class<?> raw = type.getRawClass();\n    String full = raw.getName();\n    main_check:\n    do {\n        if (_cfgIllegalClassNames.contains(full)) {\n            break;\n        }\n// buggy line:        if (full.startsWith(PREFIX_STRING)) {\n// buggy line:            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n// buggy line:                if (cls.getName().startsWith(PREFIX_STRING)) {\n// buggy line:                    break main_check;\n// buggy line:                }\n// buggy line:            }\n// buggy line:        }\n        if (full.startsWith(PREFIX_STRING)) {\n            for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n                if (cls.getName().startsWith(PREFIX_STRING)) {\n                    break main_check;\n                }\n            }\n        }\n    } while (false);\n    if (full.startsWith(PREFIX_STRING)) {\n        for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) {\n            if (cls.getName().startsWith(PREFIX_STRING)) {\n                break main_check;\n            }\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required"
      ],
      "function range": "67,5-99,5"
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1 != candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName != null) || (injectId != null);\n    if (!useProps && (paramDef != null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);",
      "output": [
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        boolean useProps",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition propDef = candidate.propertyDef(0);\n        boolean useProps",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        if (paramName ==",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        boolean useProps = (paramName!= null) || (injectId!= null);\n\n",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        if (paramName!=",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        \n        if (param",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter param = candidate.parameter(0);\n        JacksonInject.Value injectId = candidate.injection(0);\n        PropertyName paramName = candidate.explicitParamName(0);\n        BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n        if ((paramName ==",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    protected void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter delegateParam = candidate.parameter(0);\n        JacksonInject.Value delegateId = candidate.injection(0);\n        PropertyName delegateName = candidate.explicitParamName(0);\n        BeanPropertyDefinition delegateDef = candidate.propertyDef(0);\n        boolean usePro",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt,\n        BeanDescription beanDesc, CreatorCollector creators,\n        CreatorCandidate candidate)\n    throws JsonMappingException\n{\n    if (1!= candidate.paramCount()) {\n        int oneNotInjected = candidate.findOnlyParamWithoutInjection();\n        if (oneNotInjected >= 0) {\n            if (candidate.paramName(oneNotInjected) == null) {\n                _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n                return;\n            }\n        }\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n        return;\n    }\n    AnnotatedParameter param = candidate.parameter(0);\n    JacksonInject.Value injectId = candidate.injection(0);\n    PropertyName paramName = candidate.explicitParamName(0);\n    BeanPropertyDefinition paramDef = candidate.propertyDef(0);\n    boolean useProps = (paramName!= null) || (injectId!= null);\n    if (!useProps && (paramDef!= null)) {\n// buggy line:        paramName = candidate.findImplicitParamName(0);\n        useProps = true;\n    }\n    if (useProps) {\n        _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate);\n    } else {\n        _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate);\n    }\n}\n    \n    /*\n    /**********************************************************\n    /* Internal methods\n    /**********************************************************\n     */\n\n    private void _addExplicitDelegatingCreator(DeserializationContext ctxt,\n            BeanDescription beanDesc, CreatorCollector creators,\n            CreatorCandidate candidate)\n        throws JsonMappingException\n    {\n        AnnotatedParameter delegateParam = candidate.parameter(0);\n        JacksonInject.Value delegateId = candidate.injection(0);\n        PropertyName delegateName = candidate.explicitParamName(0);\n        BeanPropertyDefinition delegateDef = candidate.propertyDef(0);\n        boolean usePro"
      ],
      "function range": "701,5-752,5"
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);",
      "output": [
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n *",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n{\n    JsonStringFormatVisitor v2 = visitor.expectStringFormat(typeHint);\n    if (v2!= null) {\n        v2.format(_value);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n * \n *   http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\"",
        "@Override\npublic final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic final void serializeWithType(JsonGenerator gen, SerializerProvider ctxt,\n    TypeSerializer typeSer)\n    throws IOException\n{\n    if (_value == null) {\n        ctxt.defaultSerializeNull(gen);\n    } else if (_value instanceof JsonSerializable) {\n        ((JsonSerializable) _value).serialize(gen, ctxt);\n    } else {\n// buggy line:        gen.writeObject(_value);\n        gen.writeString(_value.toString());\n    }\n}\n\n@Override\npublic JsonNode getSchema(SerializerProvider provider, Type typeHint)\n    throws JsonMappingException\n{\n    return createSchemaNode(\"string\", true);\n}\n\n@Override\npublic void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint)\n    throws JsonMappingException\n{\n    visitor.expectStringFormat(typeHint);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS,"
      ],
      "function range": "104,5-116,5"
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);",
      "output": [
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n *",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.createUsingDelegate(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.createUsingDelegate(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License,",
        "public Object complete(JsonParser p, DeserializationContext ctxt,\n        PropertyValueBuffer buffer, PropertyBasedCreator creator)\n    throws IOException\n{\n    final int len = _properties.length;\n    Object[] values = new Object[len];\n    for (int i = 0; i < len; ++i) {\n        String typeId = _typeIds[i];\n        final ExtTypedProperty extProp = _properties[i];\n        if (typeId == null) {\n            if (_tokens[i] == null) {\n                continue;\n            }\n            if (!extProp.hasDefaultType()) {\n                ctxt.reportInputMismatch(_beanType,\n                        \"Missing external type id property '%s'\",\n                        extProp.getTypePropertyName());\n            } else {\n                typeId = extProp.getDefaultTypeId();\n            }\n        } else if (_tokens[i] == null) {\n            SettableBeanProperty prop = extProp.getProperty();\n            ctxt.reportInputMismatch(_beanType,\n                    \"Missing property '%s' for external type id '%s'\",\n                    prop.getName(), _properties[i].getTypePropertyName());\n        }\n        values[i] = _deserialize(p, ctxt, i, typeId);\n        final SettableBeanProperty prop = extProp.getProperty();\n        if (prop.getCreatorIndex() >= 0) {\n            buffer.assignParameter(prop, values[i]);\n            SettableBeanProperty typeProp = extProp.getTypeProperty();\n            if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) {\n// buggy line:                buffer.assignParameter(typeProp, typeId);\n                buffer.assignParameter(typeProp, values[i]);\n            }\n        }\n    }\n    return creator.create(values);\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License"
      ],
      "function range": "255,5-311,5"
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }",
      "output": [
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return null;\n// buggy line:    }\n// buggy line:    if (property == null) {",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    return this;\n// buggy line",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n\n        return this;\n    }\n}\n<",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n\n    return this;\n  }\n}\n<",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n        return this;\n    }\n}\n<",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    return null;\n// buggy line",
        "@Override\npublic JsonSerializer<?> createContextual(SerializerProvider serializers,\n        BeanProperty property) throws JsonMappingException\n{\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    if (property == null) {\n// buggy line:        return this;\n// buggy line:    }\n// buggy line:    JsonSerializer<?> ser"
      ],
      "function range": "61,5-136,5"
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;",
      "output": [
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LIC",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LIC",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LIC",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\"+typeId+\"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LIC",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt,\n        String typeId) throws IOException\n{\n    JsonDeserializer<Object> deser = _deserializers.get(typeId);\n    if (deser == null) {\n        JavaType type = _idResolver.typeFromId(ctxt, typeId);\n        if (type == null) {\n            deser = _findDefaultImplDeserializer(ctxt);\n            if (deser == null) {\n                JavaType actual = _handleUnknownTypeId(ctxt, typeId);\n                if (actual == null) { \n// buggy line:                    return null;\n                    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\" + typeId + \"'\");\n                }\n                deser = ctxt.findContextualValueDeserializer(actual, this);\n            }\n        } else {\n            deser = ctxt.findContextualValueDeserializer(type, this);\n        }\n        if (deser!= null) {\n            _deserializers.put(typeId, deser);\n        }\n    }\n    return deser;\n}\n\nprotected JsonDeserializer<Object> _findDefaultImplDeserializer(DeserializationContext ctxt)\n    throws IOException\n{\n    return null;\n}\n\nprotected JavaType _handleUnknownTypeId(DeserializationContext ctxt, String typeId)\n    throws IOException\n{\n    throw JsonMappingException.from(ctxt, \"Can not find a deserializer for type id '\"+typeId+\"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses"
      ],
      "function range": "146,5-199,5"
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;",
      "output": [
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.al",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLog",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "protected XmlSerializerProvider(XmlSerializerProvider src) {\n    super(src);\n// buggy line:    _rootNameLookup = src._rootNameLookup;\n    _rootNameLookup = src._rootNameLookup;\n  }\n\n  @Override\n  public XmlSerializerProvider copy() {\n    return new XmlSerializerProvider(this);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "55,5-60,5"
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);",
      "output": [
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.al",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.h",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "private void normalise(Element element) {\n    List<Node> toMove = new ArrayList<Node>();\n    for (Node node: element.childNodes) {\n        if (node instanceof TextNode) {\n            TextNode tn = (TextNode) node;\n            if (!tn.isBlank())\n                toMove.add(tn);\n        }\n    }\n    for (Node node: toMove) {\n        element.removeChild(node);\n// buggy line:        body().appendChild(new TextNode(\" \", \"\"));\n// buggy line:        body().appendChild(node);\n        element.appendChild(new TextNode(\" \", \"\"));\n        element.appendChild(node);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.udf.generic.GenericUDF"
      ],
      "function range": "113,5-128,5"
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {",
      "output": [
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    html.attributes().put(attribute);\n                }\n            } else {\n",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    html.attributes().put(attribute);\n                }\n            } else if (\"",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element head = tb.getHeadElement();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element inBase = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!inBase.hasAttr(attribute.getKey()))\n                        ",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    html.attributes().put(attribute);\n                }\n            } else if (",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element html = tb.get",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n                tb.error(this);\n                Element head = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!head.hasAttr(attribute.getKey()))\n                        head.attributes().put(attribute);\n                }\n            } else if (name.equals(\"body\")) {\n                tb.framesetOk(false);\n                Element body = new Element(Tag",
        "boolean process(Token t, TreeBuilder tb) {\n    switch (t.type) {\n        case Character: {\n            Token.Character c = t.asCharacter();\n            if (c.getData().equals(nullString)) {\n                tb.error(this);\n                return false;\n            } else if (isWhitespace(c)) {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n            } else {\n                tb.reconstructFormattingElements();\n                tb.insert(c);\n                tb.framesetOk(false);\n            }\n            break;\n        }\n        case Comment: {\n            tb.insert(t.asComment());\n            break;\n        }\n        case Doctype: {\n            tb.error(this);\n            return false;\n        }\n        case StartTag:\n            Token.StartTag startTag = t.asStartTag();\n            String name = startTag.name();\n            if (name.equals(\"html\")) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                for (Attribute attribute : startTag.getAttributes()) {\n                    if (!html.hasAttr(attribute.getKey()))\n                        html.attributes().put(attribute);\n                }\n// buggy line:            } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) {\n            } else if (\"base\".equals(name) || \"basefont\".equals(name) || \"bgsound\".equals(name) || \"command\".equals(name) || \"link\".equals(name) || \"meta\".equals(name) || \"noframes\".equals(name) || \"style\".equals(name) || \"title\".equals(name)) {\n                tb.error(this);\n                Element html = tb.getStack().getFirst();\n                html.attributes().put(startTag.getAttributes());\n            } else {\n                tb.reconstructFormattingElements();\n                "
      ],
      "function range": "246,9-761,9"
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();",
      "output": [
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (r.matches('/')) {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            }\n            // fall through\n        case '######################################################################################################################################################################################################################################################################",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.eofError(this);\n            }\n            break;\n        case '###############################################################################################",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(ProcessingInstruction);\n            break;\n        case '\"':\n            t.transition(",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                t.dataBuffer.append(c);\n                r.unconsume();\n            }\n            break;\n        case '=':\n            t.tagPending.appendTagName(c);\n            t.dataBuffer.append(c);\n            r.unconsume();\n            break;\n        case '\"':\n        case '\\'':\n            parseString(t, r, c);\n            break;\n        case '!",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(BogusComment);\n            break;\n        default:\n            t.dataBuffer.append(",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(BogusComment);\n            break;\n        case '\"':\n            t.transition(",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(ProcessingInstruction);\n            break;\n        case '%':\n            t.transition(",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(ProcessingInstruction);\n            break;\n        case '\"':\n        case '\\'':",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                t.dataBuffer.append(c);\n                r.unconsume();\n            }\n            break;\n        case '=':\n            t.tagPending.appendTagName(c);\n            t.dataBuffer.append(c);\n            r.unconsume();\n            break;\n        case '\"':\n        case '\\'':\n            parseString(t, c, r);\n            break;\n        case '!",
        "void read(Tokeniser t, CharacterReader r) {\n    if (r.matchesLetter()) {\n        String name = r.consumeLetterSequence();\n        t.tagPending.appendTagName(name.toLowerCase());\n        t.dataBuffer.append(name);\n// buggy line:        r.advance();\n        return;\n    }\n\n    char c = r.consume();\n    switch (c) {\n        case '\\t':\n        case '\\n':\n        case '\\r':\n        case '\\f':\n        case'':\n            do {\n                c = r.consume();\n            } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n            // fall through\n        case '/':\n            if (c == '/') {\n                do {\n                    c = r.consume();\n                } while (c!= '\\n' && c!= '\\r');\n            } else if (c == '*') {\n                boolean seeSlash = false;\n                do {\n                    c = r.consume();\n                    if (c == '*') {\n                        c = r.consume();\n                        if (c == '/') {\n                            seeSlash = true;\n                        }\n                    }\n                } while (c!= '\\n' && c!= '\\r');\n                if (seeSlash) {\n                    do {\n                        c = r.consume();\n                    } while (c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f');\n                }\n            } else {\n                t.tagPending.appendTagName(c);\n                r.unconsume();\n            }\n            break;\n        case '>':\n            t.emitTagPending();\n            t.transition(Data);\n            break;\n        case '!':\n            t.transition(MarkupDeclarationOpen);\n            break;\n        case '?':\n            t.transition(BogusComment);\n            break;\n        default:\n            r.unconsume();\n"
      ],
      "function range": "553,9-586,9"
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar != input[offset])\n            while(++offset < length && startChar != input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {",
      "output": [
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\n",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.",
        "int nextIndexOf(CharSequence seq) {\n    char startChar = seq.charAt(0);\n    for (int offset = pos; offset < length; offset++) {\n        if (startChar!= input[offset])\n            while(++offset < length && startChar!= input[offset]);\n        int i = offset + 1;\n        int last = i + seq.length()-1;\n// buggy line:        if (offset < length) {\n// buggy line:            for (int j = 1; j < seq.length(); j++) {\n// buggy line:                if (input[i++]!= seq.charAt(j))\n// buggy line:                    break;\n// buggy line:            }\n// buggy line:        }\n        if (offset < length && i < last) {\n            for (int j = 1; j < seq.length(); j++) {\n                if (input[i++]!= seq.charAt(j))\n                    break;\n            }\n        }\n        if (i == last+1)\n            return offset;\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org"
      ],
      "function range": "82,5-98,5"
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();",
      "output": [
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.alge",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algeb",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.alge",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org",
        "public String html() {\n    StringBuilder accum = new StringBuilder();\n    html(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void html(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).html(accum);\n    }\n  }\n\n  public String toString() {\n    StringBuilder accum = new StringBuilder();\n    toString(accum);\n// buggy line:    return accum.toString().trim();\n    return accum.toString().trim();\n  }\n\n  public void toString(StringBuilder accum) {\n    for (int i = 0; i < children.size(); i++) {\n      children.get(i).toString(accum);\n    }\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport"
      ],
      "function range": "1098,5-1102,5"
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);",
      "output": [
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        return false;\n    } else if (!systemId.equals(other.systemId))\n      return false;",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (getClass()!= obj.getClass()) {\n      return false;\n    }\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) {\n        return false;\n      }\n    } else if (!name.equals(other.name)) {\n      return false;\n    }\n    if (publicId == null) {\n      if (other.publicId!= null) {\n        return false;\n      }\n    } else if (!publicId.equals(other.publicId)) {\n      return false;\n    }\n    if (systemId == null) {\n      if (other.systemId!= null",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) {\n      return true;\n    }\n    if (obj == null) {\n      return false;\n    }\n    if (!(obj instanceof DocumentType)) {\n      return false;\n    }\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) {\n        return false;\n      }\n    } else if (!name.equals(other.name)) {\n      return false;\n    }\n    if (publicId == null) {\n      if (other.publicId!= null) {\n        return false;\n      }\n    } else if (!publicId.equals(other.publicId)) {\n      return false;\n    }\n    if (systemId == null) {\n      if (other.systemId!= null) {",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass()!= obj.getClass()) return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) return false;\n    } else if (!name.equals(other.name)) return false;\n    if (publicId == null) {\n      if (other.publicId!= null) return false;\n    } else if (!publicId.equals(other.publicId)) return false;\n    if (systemId == null) {\n      if (other.systemId!= null) return false;\n    } else if (!systemId.equals(other.systemId)) return false;\n    return true;\n  }\n\n  @Override\n  public String toString",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType documentType = (DocumentType) o;\n\n    if (name!= null?!name.equals(documentType.name) : documentType.name!= null) return false;\n    if (publicId!= null?!publicId.equals(documentType.publicId) : documentType.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(documentType.systemId) : documentType.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId + '\\'' +\n        ",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (!(obj instanceof DocumentType))\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        return false;\n    } else if (!systemId.equals(other.systemId))\n      return false;\n    ",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    result = prime * result + ((baseUri == null)? 0 : baseUri.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj)\n      return true;\n    if (obj == null)\n      return false;\n    if (getClass()!= obj.getClass())\n      return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null)\n        return false;\n    } else if (!name.equals(other.name))\n      return false;\n    if (publicId == null) {\n      if (other.publicId!= null)\n        return false;\n    } else if (!publicId.equals(other.publicId))\n      return false;\n    if (systemId == null) {\n      if (other.systemId!= null)\n        ",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public int hashCode() {\n    final int prime = 31;\n    int result = 1;\n    result = prime * result + ((name == null)? 0 : name.hashCode());\n    result = prime * result + ((publicId == null)? 0 : publicId.hashCode());\n    result = prime * result + ((systemId == null)? 0 : systemId.hashCode());\n    return result;\n  }\n\n  @Override\n  public boolean equals(Object obj) {\n    if (this == obj) return true;\n    if (obj == null) return false;\n    if (getClass()!= obj.getClass()) return false;\n    DocumentType other = (DocumentType) obj;\n    if (name == null) {\n      if (other.name!= null) return false;\n    } else if (!name.equals(other.name)) return false;\n    if (publicId == null) {\n      if (other.publicId!= null) return false;\n    } else if (!publicId.equals(other.publicId)) return false;\n    if (systemId == null) {\n      if (other.systemId!= null) return false;\n    } else if (!systemId.equals(other.systemId)) return false;\n    return true;\n  }\n\n}\n<|java|>",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n        \"name='\" + name + '\\'' +\n        \", publicId='\" + publicId + '\\'' +\n        \", systemId='\" + systemId + '\\'' +\n        '}';\n  }\n",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) {\n    super(baseUri);\n// buggy line:    Validate.notEmpty(name);\n    this.name = name;\n    this.publicId = publicId;\n    this.systemId = systemId;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public String getPublicId() {\n    return publicId;\n  }\n\n  public void setPublicId(String publicId) {\n    this.publicId = publicId;\n  }\n\n  public String getSystemId() {\n    return systemId;\n  }\n\n  public void setSystemId(String systemId) {\n    this.systemId = systemId;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    DocumentType that = (DocumentType) o;\n\n    if (name!= null?!name.equals(that.name) : that.name!= null) return false;\n    if (publicId!= null?!publicId.equals(that.publicId) : that.publicId!= null) return false;\n    if (systemId!= null?!systemId.equals(that.systemId) : that.systemId!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    int result = name!= null? name.hashCode() : 0;\n    result = 31 * result + (publicId!= null? publicId.hashCode() : 0);\n    result = 31 * result + (systemId!= null? systemId.hashCode() : 0);\n    return result;\n  }\n\n  @Override\n  public String toString() {\n    return \"DocumentType{\" +\n            \"name='\" + name + '\\'' +\n            \", publicId='\" + publicId + '\\'' +\n            \", systemId='\" + systemId + '\\'' +\n            '}';\n  }\n"
      ],
      "function range": "19,5-26,5"
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;",
      "output": [
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    @",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class DeadLetterChannelTest extends ContextTestSupport {\n\n    @Test\n    ",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n    private",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTh",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\n\npublic class RecipientListTest extends ContextTestSupport {\n\n    @Test\n    ",
        "@Override\npublic boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n    if (!super.equals(o)) return false;\n    Element element = (Element) o;\n// buggy line:    return this == o;\n    return this.element.equals(element.element);\n  }\n\n  @Override\n  public int hashCode() {\n    int result = super.hashCode();\n    result = 31 * result + element.hashCode();\n    return result;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.fail;\n\n"
      ],
      "function range": "1167,5-1176,5"
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search))",
      "output": [
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperator",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.h",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.al",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpression",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache.hadoop",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) {\n    Validate.notNull(search);\n    Validate.notNull(elements);\n    for (int i = 0; i < elements.size(); i++) {\n        E element = elements.get(i);\n// buggy line:        if (element.equals(search)) {\n// buggy line:            return i;\n// buggy line:        }\n        if (element.equals(search)) {\n            return i;\n        }\n    }\n    return -1;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.io.Bytes;"
      ],
      "function range": "568,5-578,5"
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) {",
      "output": [
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"th\".equals(name) &&!last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if (\"td\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n//                 transition(HtmlTreeBuilderState.InCell);\n//                 break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            ",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if (\"td\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (last) {\n            transition(HtmlTreeBuilder",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"td\".equals(name) && last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.BeforeHead);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frames",
        "void resetInsertionMode() {\n    boolean last = false;\n    for (int pos = stack.size() -1; pos >= 0; pos--) {\n        Element node = stack.get(pos);\n        if (pos == 0) {\n            last = true;\n            node = contextElement;\n        }\n        String name = node.nodeName();\n        if (\"select\".equals(name)) {\n            transition(HtmlTreeBuilderState.InSelect);\n            break; \n// buggy line:        } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) {\n        } else if ((\"td\".equals(name) || \"th\".equals(name) &&!last)) {\n            transition(HtmlTreeBuilderState.InCell);\n            break;\n        } else if (\"tr\".equals(name)) {\n            transition(HtmlTreeBuilderState.InRow);\n            break;\n        } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTableBody);\n            break;\n        } else if (\"caption\".equals(name)) {\n            transition(HtmlTreeBuilderState.InCaption);\n            break;\n        } else if (\"colgroup\".equals(name)) {\n            transition(HtmlTreeBuilderState.InColumnGroup);\n            break;\n        } else if (\"table\".equals(name)) {\n            transition(HtmlTreeBuilderState.InTable);\n            break;\n        } else if (\"head\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"body\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else if (\"frameset\".equals(name)) {\n            transition(HtmlTreeBuilderState.InFrameset);\n            break;\n        } else if (\"html\".equals(name)) {\n            transition(HtmlTreeBuilderState.InBody);\n            break;\n        } else"
      ],
      "function range": "382,5-429,5"
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&#############################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                         accum.append(\"&#############################################################################################################",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(\"<\");\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(\">\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\" \");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n                    accum.append(\"&gt;\");\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\\'':\n                    if (inAttribute)\n                        accum",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(coreCharset.encode(c));\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        acc",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                default:\n                    if (core",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n// buggy line:                        accum.append(c);\n                        accum.append(\"&nbsp;\");\n                    break;\n                case '<':\n                    if (inAttribute)\n                        accum.append(\"&lt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '>':\n                    if (inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        "
      ],
      "function range": "79,5-154,5"
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode != EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute) {\n// buggy line:                        accum.append(\"&lt;\");\n// buggy line:                        break;\n// buggy line:                    }\n                    accum.append(\"&lt;\");\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute) {\n// buggy line:                        accum.append(\"&gt;\");\n// buggy line:                        break;\n// buggy line:                    }\n                    ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&gt;\");\n                    accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                    accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                    accum.append(\"&gt;\");\n                    accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                    accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n                    if (!inAttribute)\n                        accum.append(\"&gt;\");\n                    else\n                        accum.append(c);\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        accum.append(\"&quot;\");\n                    else\n",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&gt;\");\n                    accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                    accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                    accum.append(\"&gt;\");\n                    accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(map.get('<'));\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&gt;\");\n                    accum.append(map.get('>'));\n                    break;\n                case '\"':\n                    if (escapeMode!= EscapeMode",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(map.get('<'));\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&gt;\");\n                    accum.append(map.get('>'));\n                    break;\n                case '\"':\n                    if (inAttribute)\n                        ",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out,\n                   boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) {\n    boolean lastWasWhite = false;\n    boolean reachedNonWhite = false;\n    final EscapeMode escapeMode = out.escapeMode();\n    final CharsetEncoder encoder = out.encoder();\n    final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name());\n    final Map<Character, String> map = escapeMode.getMap();\n    final int length = string.length();\n    int codePoint;\n    for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) {\n        codePoint = string.codePointAt(offset);\n        if (normaliseWhite) {\n            if (StringUtil.isWhitespace(codePoint)) {\n                if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite)\n                    continue;\n                accum.append(' ');\n                lastWasWhite = true;\n                continue;\n            } else {\n                lastWasWhite = false;\n                reachedNonWhite = true;\n            }\n        }\n        if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) {\n            final char c = (char) codePoint;\n            switch (c) {\n                case '&':\n                    accum.append(\"&amp;\");\n                    break;\n                case 0xA0:\n                    if (escapeMode!= EscapeMode.xhtml)\n                        accum.append(\"&nbsp;\");\n                    else\n                        accum.append(\"&#xa0;\");\n                    break;\n                case '<':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&lt;\");\n                    accum.append(c);\n                    break;\n                case '>':\n// buggy line:                    if (!inAttribute)\n//                                        accum.append(\"&gt;\");\n                    accum.append(c);\n                    break;\n                case '\"':\n                    if (escapeMode == EscapeMode.xhtml)\n                        accum.append"
      ],
      "function range": "79,5-155,5"
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');",
      "output": [
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z') || (c >= '0' && c <= '9');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nboolean matchesLineTerminator() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c == '\\n' || c == '\\r';\n    return c == '\\n' || c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c =='' || c == '\\t' || c == '\\n' || c == '\\r' || c == '\\f' || c == '\\b';\n    return c =='' || c == '\\t' || c == '\\n' || c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nboolean matchesLineTerminator() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return c == '\\n'",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nboolean matchesNewline() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n    return c == '\\n' ||",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nboolean matchesLineTerminator",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c =='' || c == '\\t' || c == '\\r' || c == '\\n' || c == '\\f' || c == '\\b';\n    return c =='' || c == '\\t' || c == '\\r' || c ==",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n}\n\nboolean matchesLine",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n    return c =='' || c == '\\t' || c == '\\n' || c == '\\r';\n}\n\nboolean matchesNewline()",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n}\n\nboolean matchesAny",
        "boolean matchesLetter() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n    return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z');\n}\n\nboolean matchesDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesHexDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n    return (c >= '0' && c <= '9') || (c >= 'A' && c <= 'F') || (c >= 'a' && c <= 'f');\n}\n\nboolean matchesOctalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '7');\n    return (c >= '0' && c <= '7');\n}\n\nboolean matchesDecimalDigit() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c >= '0' && c <= '9');\n    return (c >= '0' && c <= '9');\n}\n\nboolean matchesWhitespace() {\n    if (isEmpty())\n        return false;\n    char c = input[pos];\n// buggy line:    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n    return (c =='' || c == '\\t' || c == '\\n' || c == '\\r');\n}\n\nboolean matchesNew"
      ],
      "function range": "296,5-301,5"
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);",
      "output": [
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    if",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public Set<Map.Entry<String, String>> entry",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key.toLowerCase());\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value.toLowerCase());\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.keySet();\n  }\n\n  public Collection<String> values() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.values();\n  }\n\n  public Set<Entry<String, String>> entrySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key.toLowerCase());\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value.toLowerCase());\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.keySet();\n  }\n\n  public Collection<String> values() {\n    if (attributes == null)\n        return Collections.emptyList();\n    return attributes.values();\n  }\n\n  public Set<Entry<String, String>> entrySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean isEmpty() {\n    if (attributes",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key.toLowerCase());\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value.toLowerCase());\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.keySet();\n  }\n\n  public Set<Map.Entry<String, String>> entrySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.entrySet();\n  }\n\n  public Collection<String> values() {\n    if (attributes == null)\n        return Collections.empty",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    return",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.values().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public Set<Entry<String, String>> entrySet()",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key.toLowerCase());\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value.toLowerCase());\n  }\n\n  public Set<String> keySet() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.keySet();\n  }\n\n  public Set<String> keySetIgnoreCase() {\n    if (attributes == null)\n        return Collections.emptySet();\n    return attributes.keySet();\n  }\n\n  public Collection<String> values() {\n    if (attributes == null)\n        return Collections.emptySet();\n",
        "public void removeIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n// buggy line:            attributes.remove(attrKey);\n            attributes.remove(attrKey.toLowerCase());\n    }\n  }\n\n  public void remove(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return;\n    attributes.remove(key);\n  }\n\n  public void clear() {\n    if (attributes == null)\n        return;\n    attributes.clear();\n  }\n\n  public boolean containsKey(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    return attributes.containsKey(key);\n  }\n\n  public boolean containsKeyIgnoreCase(String key) {\n    Validate.notEmpty(key);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrKey = it.next();\n        if (attrKey.equalsIgnoreCase(key))\n            return true;\n    }\n    return false;\n  }\n\n  public boolean containsValue(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    return attributes.containsValue(value);\n  }\n\n  public boolean containsValueIgnoreCase(String value) {\n    Validate.notEmpty(value);\n    if (attributes == null)\n        return false;\n    for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) {\n        String attrValue = it.next();\n        if (attrValue.equalsIgnoreCase(value))\n            return true;\n    }\n    return false;\n  }\n\n  public Set<String> keySet() {\n    "
      ],
      "function range": "118,5-127,5"
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");",
      "output": [
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getClassName() {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return null;\n        }\n        return classAttr;\n    }\n\n    public String getId() {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return null;\n        }\n        return idAttr;\n    }\n\n    public String getName() {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return null;\n        }\n        return nameAttr;\n    }\n\n    public String getValue() {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return null;\n        }\n        return value",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public void setClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            attributes.put(\"class\", className);\n        } else {\n            attributes.put(\"class\", classAttr + \" \" + className);\n        }\n    }\n\n    public void setId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            attributes.put(\"id\", id);\n        } else {\n            attributes.put(\"id\", idAttr + \" \" + id);\n        }\n    }\n\n    public void setName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            attributes.put(\"name",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getClassName() {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return null;\n        }\n        return classAttr;\n    }\n\n    public String getId() {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return null;\n        }\n        return idAttr;\n    }\n\n    public String getName() {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return null;\n        }\n        return nameAttr;\n    }\n\n    public String getType() {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return null;\n        }\n        return type",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public void setClass(String className) {\n        attributes.put(\"class\", className);\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getId() {\n        return attributes.get(\"id\");\n    }\n\n    public String getName() {\n        return attributes.get(\"name\");\n    }\n\n    public String getValue() {\n        return attributes.get(\"value\");\n    }\n\n    public String getType() {\n        return attributes.get(\"type\");\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n\n    public Map<String, String> getAttributes() {\n        return attributes;\n",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getId() {\n        return attributes.get(\"id\");\n    }\n\n    public String getName() {\n        return attributes.get(\"name\");\n    }\n\n    public String getValue() {\n        return attributes.get(\"value\");\n    }\n\n    public String getType() {\n        return attributes.get(\"type\");\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n\n    @Override\n    public String toString() {\n        return attributes.toString",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public void setClass(String className) {\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            attributes.put(\"class\", className);\n        } else {\n            attributes.put(\"class\", classAttr + \" \" + className);\n        }\n    }\n\n    public void setId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            attributes.put(\"id\", id);\n        } else {\n            attributes.put(\"id\", idAttr + \" \" + id);\n        }\n    }\n\n    public void setName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            attributes.put(\"id",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getId() {\n        return attributes.get(\"id\");\n    }\n\n    public String getName() {\n        return attributes.get(\"name\");\n    }\n\n    public String getValue() {\n        return attributes.get(\"value\");\n    }\n\n    public String getType() {\n        return attributes.get(\"type\");\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder sb",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getId() {\n        return attributes.get(\"id\");\n    }\n\n    public String getName() {\n        return attributes.get(\"name\");\n    }\n\n    public String getValue() {\n        return attributes.get(\"value\");\n    }\n\n    public String getType() {\n        return attributes.get(\"type\");\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n\n    public Map<String, String> getAttributes() {\n        return Collections.un",
        "public boolean hasClass(String className) {\n// buggy line:    final String classAttr = attributes.get(\"class\");\n        final String classAttr = attributes.get(\"class\");\n        if (classAttr == null) {\n            return false;\n        }\n        return classAttr.contains(className);\n    }\n\n    public boolean hasId(String id) {\n        final String idAttr = attributes.get(\"id\");\n        if (idAttr == null) {\n            return false;\n        }\n        return idAttr.equals(id);\n    }\n\n    public boolean hasName(String name) {\n        final String nameAttr = attributes.get(\"name\");\n        if (nameAttr == null) {\n            return false;\n        }\n        return nameAttr.equals(name);\n    }\n\n    public boolean hasValue(String value) {\n        final String valueAttr = attributes.get(\"value\");\n        if (valueAttr == null) {\n            return false;\n        }\n        return valueAttr.equals(value);\n    }\n\n    public boolean hasType(String type) {\n        final String typeAttr = attributes.get(\"type\");\n        if (typeAttr == null) {\n            return false;\n        }\n        return typeAttr.equals(type);\n    }\n\n    public String getId() {\n        return attributes.get(\"id\");\n    }\n\n    public String getName() {\n        return attributes.get(\"name\");\n    }\n\n    public String getValue() {\n        return attributes.get(\"value\");\n    }\n\n    public String getType() {\n        return attributes.get(\"type\");\n    }\n\n    public void setId(String id) {\n        attributes.put(\"id\", id);\n    }\n\n    public void setName(String name) {\n        attributes.put(\"name\", name);\n    }\n\n    public void setValue(String value) {\n        attributes.put(\"value\", value);\n    }\n\n    public void setType(String type) {\n        attributes.put(\"type\", type);\n    }\n\n    @Override\n    public String toString() {\n        final StringBuilder builder ="
      ],
      "function range": "1091,5-1132,5"
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }",
      "output": [
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.h",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) {\n// buggy line:    int bottom = stack.size() -1;\n// buggy line:    if (bottom > MaxScopeSearchDepth) {\n// buggy line:        bottom = MaxScopeSearchDepth;\n// buggy line:    }\n    int bottom = stack.size() - 1;\n    if (bottom > MaxScopeSearchDepth) {\n        bottom = MaxScopeSearchDepth;\n    }\n    for (int i = 0; i < targetNames.length; i++) {\n        String targetName = targetNames[i];\n        for (int j = 0; j < baseTypes.length; j++) {\n            String baseType = baseTypes[j];\n            if (targetName.equals(baseType)) {\n                for (int k = 0; k < extraTypes.length; k++) {\n                    String extraType = extraTypes[k];\n                    if (targetName.equals(extraType)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks."
      ],
      "function range": "466,5-486,5"
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {",
      "output": [
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\n",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\n",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.al",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.ex",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n            && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.ex",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException {\n    final int sz = size;\n    for (int i = 0; i < sz; i++) {\n        final String key = keys[i];\n        final String val = vals[i];\n        accum.append(' ').append(key);\n// buggy line:        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n// buggy line:            && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) {\n        if (!(out.syntax() == Document.OutputSettings.Syntax.html\n                && (val == null || val.equals(key) &&!Attribute.isBooleanAttribute(key)))) {\n            accum.append('=').append(val);\n        }\n        accum.append('\\n');\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\n"
      ],
      "function range": "310,5-326,5"
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();",
      "output": [
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementStack2\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementStack2\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementStack2\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, elNameType);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, null);\n    fElementStack.popElement();\n}\n\n\n} // class ElementStack2\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License",
        "private void popStackToClose(Token.EndTag endTag) {\n// buggy line:    String elName = endTag.name();\n// fixed line:    String elName = endTag.getName();\n// buggy line:    if (XML11Char.isXML11ValidName(elName)) {\n// fixed line:    if (XML11Char.isXML11ValidName(elName.ch, elName.offset, elName.length)) {\n        String elName = endTag.getName();\n        if (XML11Char.isXML11ValidName(elName)) {\n            return;\n        }\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    else {\n        fErrorReporter.reportError(XMLMessageFormatter.XML_DOMAIN,\n                                   \"ElementTypeInvalid\",\n                                   new Object[]{elName},\n                                   XMLErrorReporter.SEVERITY_FATAL_ERROR);\n    }\n    fQName.setValues(null, null, elName, elNameType);\n    fElementStack.popElement();\n}\n\n\n} // class ElementValidator\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n"
      ],
      "function range": "116,5-136,5"
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {",
      "output": [
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n\n  @Override\n  public String toString() {\n    return \"XmlDeclaration{\" +\n        \"data='\" + data + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n\n  @Override\n  public String toString() {\n    return \"XmlDeclaration{\" +\n            \"data='\" + data + '\\'' +\n            '}';\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n\n  @Override\n  public String toString() {\n    return \"XmlDeclaration{\" +\n        \"data='\" + data + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\"",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n\n  @Override\n  public String toString() {\n    return \"XmlDeclaration{\" +\n        \"data='\" + data + '\\'' +\n        '}';\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS",
        "public XmlDeclaration asXmlDeclaration() {\n    String data = getData();\n    Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser());\n    XmlDeclaration decl = null;\n// buggy line:    if (doc.childNodeSize() > 0) {\n    for (Node node : doc.childNodes()) {\n      if (node instanceof XmlDeclaration) {\n        decl = (XmlDeclaration) node;\n        break;\n      }\n    }\n    return decl;\n  }\n\n  public String getData() {\n    return data;\n  }\n\n  public void setData(String data) {\n    this.data = data;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass()!= o.getClass()) return false;\n\n    XmlDeclaration that = (XmlDeclaration) o;\n\n    if (data!= null?!data.equals(that.data) : that.data!= null) return false;\n\n    return true;\n  }\n\n  @Override\n  public int hashCode() {\n    return data!= null? data.hashCode() : 0;\n  }\n\n  @Override\n  public String toString() {\n    return \"XmlDeclaration{\" +\n            \"data='\" + data + '\\'' +\n            '}';\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\""
      ],
      "function range": "74,5-84,5"
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "public String getValue() {\n// buggy line:    return val;",
      "output": [
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.val = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String val) {\n// buggy line:    this.val = val;\n        this.val = val;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public String getValue() {\n// buggy line:    return val;\n        return value;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.val = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\n",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String val) {\n// buggy line:    this.val = val;\n        this.val = val;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\n",
        "public String getValue() {\n// buggy line:    return val;\n        return value;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.value = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\n",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.val = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.val = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String value) {\n// buggy line:    this.val = value;\n        this.val = value;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "public String getValue() {\n// buggy line:    return val;\n        return val;\n    }\n\n    public void setValue(String val) {\n// buggy line:    this.val = val;\n        this.val = val;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks"
      ],
      "function range": "79,5-81,5"
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0 ? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0 ? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1 != null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");",
      "output": [
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CON",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDIT",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CON",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDIT",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANT",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANT",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n                + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES",
        "private int compareNodePointers(\n    NodePointer p1,\n    int depth1,\n    NodePointer p2,\n    int depth2) \n{\n    if (depth1 < depth2) {\n        int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1);\n        return r == 0? -1 : r;\n    }\n    if (depth1 > depth2) {\n        int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2);\n        return r == 0? 1 : r;\n    }\n    if (p1 == null && p2 == null) {\n        return 0;\n    }\n    if (p1!= null && p1.equals(p2)) {\n        return 0;\n    }\n    if (depth1 == 1) {\n// buggy line:        throw new JXPathException(\n// buggy line:                \"Cannot compare pointers that do not belong to the same tree: '\"\n// buggy line:                        + p1 + \"' and '\" + p2 + \"'\");\n        throw new JXPathException(\n            \"Cannot compare pointers that do not belong to the same tree: '\"\n            + p1 + \"' and '\" + p2 + \"'\");\n    }\n    throw new JXPathException(\n        \"Cannot compare pointers that do not belong to the same tree: '\"\n        + p1 + \"' and '\" + p2 + \"'\");\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES"
      ],
      "function range": "642,5-675,5"
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) ",
      "output": [
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\n",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyr",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnn",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.InnerJoinOperator;",
        "public final Object computeValue(EvalContext context) {\n// buggy line:    return compute(args[0].computeValue(context), args[1].computeValue(context)) \n        return compute(args[0].computeValue(context), args[1].computeValue(context));\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOper"
      ],
      "function range": "41,5-44,5"
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType() != Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                    .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);",
      "output": [
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n            return equalStrings(namespaceURI, nodeNS);\n        }\n        return false;\n    ",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getLocalPart()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStr",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getLocalPart().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(node",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespace",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || DOMNodePointer.getLocalName(node).equals(testName.getName())) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(node",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n               .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings",
        "public static boolean testNode(Node node, NodeTest test) {\n    if (test == null) {\n        return true;\n    }\n    if (test instanceof NodeNameTest) {\n        if (node.getNodeType()!= Node.ELEMENT_NODE) {\n            return false;\n        }\n        NodeNameTest nodeNameTest = (NodeNameTest) test;\n        QName testName = nodeNameTest.getNodeName();\n        String namespaceURI = nodeNameTest.getNamespaceURI();\n        boolean wildcard = nodeNameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            String nodeNS = DOMNodePointer.getNamespaceURI(node);\n// buggy line:            return equalStrings(namespaceURI, nodeNS);\n            return equalStrings(nodeNS, namespaceURI);\n        }\n        return false;\n    }\n    if (test instanceof NodeTypeTest) {\n        NodeTypeTest nodeTypeTest = (NodeTypeTest) test;\n        int testType = nodeTypeTest.getNodeType();\n        if (node.getNodeType() == testType) {\n            return true;\n        }\n        return false;\n    }\n    if (test instanceof NameTest) {\n        NameTest nameTest = (NameTest) test;\n        QName testName = nameTest.getNodeName();\n        String namespaceURI = nameTest.getNamespaceURI();\n        boolean wildcard = nameTest.isWildcard();\n        String testPrefix = testName.getPrefix();\n        if (wildcard && testPrefix == null) {\n            return true;\n        }\n        if (wildcard\n            || testName.getName()\n                   .equals(DOMNodePointer.getLocalName(node))) {\n            return equalStrings(namespaceURI, DOMNodePointer.getNamespaceURI(node));\n        }\n        return false;\n    }\n    if (test instanceof Node"
      ],
      "function range": "87,5-136,5"
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());",
      "output": [
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    public boolean isReadOnly() {\n// buggy line:    return ValueUtils.isReadOnly(getBaseValue());\n        return ValueUtils.isReadOnly(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isBinary() {\n// buggy line:    return ValueUtils.isBinary(getBaseValue());\n        return ValueUtils.isBinary(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isReadOnly() {\n// buggy line:    return ValueUtils.isReadOnly(getBaseValue());\n        return ValueUtils.isReadOnly(getBaseValue());\n    }\n\n    public boolean isSearchable() {\n// buggy line:    return ValueUtils.isSearchable(getBaseValue());\n        return ValueUtils.isSearchable(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    public boolean isReadOnly() {\n// buggy line:    return ValueUtils.isReadOnly(getBaseValue());\n        return ValueUtils.isReadOnly(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public int isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    public boolean isReadOnly() {\n// buggy line:    return ValueUtils.isReadOnly(getBaseValue());\n        return ValueUtils.isReadOnly(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNumeric() {\n// buggy line:    return ValueUtils.isNumeric(getBaseValue());\n        return ValueUtils.isNumeric(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isFixed() {\n// buggy line:    return ValueUtils.isFixed(getBaseValue());\n        return ValueUtils.isFixed(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    public boolean isReadOnly() {\n// buggy line:    return ValueUtils.isReadOnly(getBaseValue());\n        return ValueUtils.isReadOnly(getBaseValue());\n    }\n\n    public boolean isSearchable() {\n// buggy line:    return ValueUtils.isSearchable(getBaseValue());\n        return ValueUtils.isSearchable(getBaseValue());\n    }\n\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isCaseSensitive() {\n// buggy line:    return ValueUtils.isCaseSensitive(getBaseValue());\n        return ValueUtils.isCaseSensitive(getBaseValue());\n    }\n\n    public boolean isCurrency() {\n// buggy line:    return ValueUtils.isCurrency(getBaseValue());\n        return ValueUtils.isCurrency(getBaseValue());\n    }\n\n    public boolean isDefinitelyWritable() {\n// buggy line:    return ValueUtils.isDefinitelyWritable(getBaseValue());\n        return ValueUtils.isDefinitelyWritable(getBaseValue());\n    }\n\n    public boolean isNullable() {\n// buggy line:    return ValueUtils.isNullable(getBaseValue());\n        return ValueUtils.isNullable(getBaseValue());\n    }\n\n    public boolean isNumeric() {\n// buggy line:    return ValueUtils.isNumeric(getBaseValue());\n        return ValueUtils.isNumeric(getBaseValue());\n    ",
        "public int getLength() {\n// buggy line:    return ValueUtils.getLength(getBaseValue());\n        return ValueUtils.getLength(getBaseValue());\n    }\n\n    public int getPrecision() {\n// buggy line:    return ValueUtils.getPrecision(getBaseValue());\n        return ValueUtils.getPrecision(getBaseValue());\n    }\n\n    public int getScale() {\n// buggy line:    return ValueUtils.getScale(getBaseValue());\n        return ValueUtils.getScale(getBaseValue());\n    }\n\n    public int getSqlType() {\n// buggy line:    return ValueUtils.getSqlType(getBaseValue());\n        return ValueUtils.getSqlType(getBaseValue());\n    }\n\n    public String getTypeName() {\n// buggy line:    return ValueUtils.getTypeName(getBaseValue());\n        return ValueUtils.getTypeName(getBaseValue());\n    }\n\n    public boolean isAutoIncrement() {\n// buggy line:    return ValueUtils.isAutoIncrement(getBaseValue());\n        return ValueUtils.isAutoIncrement(getBaseValue());\n    }\n\n    public boolean isBinary() {\n// buggy line:    return ValueUtils.isBinary(getBaseValue());\n        return ValueUtils.isBinary(getBaseValue());\n    }\n\n    public boolean isBlob() {\n// buggy line:    return ValueUtils.isBlob(getBaseValue());\n        return ValueUtils.isBlob(getBaseValue());\n    }\n\n    public boolean isBoolean() {\n// buggy line:    return ValueUtils.isBoolean(getBaseValue());\n        return ValueUtils.isBoolean(getBaseValue());\n    }\n\n    public boolean isCharacter() {\n// buggy line:    return ValueUtils.isCharacter(getBaseValue());\n        return ValueUtils.isCharacter(getBaseValue());\n    }\n\n    public boolean isClob() {\n// buggy line:    return ValueUtils.isClob(getBaseValue());\n        return ValueUtils.isClob(getBaseValue());\n    }\n\n    public boolean isConstant() {\n//"
      ],
      "function range": "151,5-153,5"
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));",
      "output": [
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescript",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOper",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vectorized",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExp",
        "public final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char[] c = Character.toChars(Character.codePointAt(input, pos));\n            out.write(c);\n            pos+= c.length;\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n// buggy line:            pos += Character.charCount(Character.codePointAt(input, pos));\n            pos += Character.charCount(input.charAt(pos));\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.query.aggregation.datasketches.theta;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Preconditions;\nimport com.google.common.primitives.Doubles;\nimport"
      ],
      "function range": "75,5-98,5"
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {",
      "output": [
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return null;\n    }\n    if (str.startsWith(\"0B\") || str.startsWith(\"-0B\")) {\n        return null;\n    }\n    if (str.startsWith(\"0D\") || str.startsWith(\"-0D\")) {\n        return null;\n    }\n    if (str.startsWith(\"0O\") || str.startsWith(\"-0O\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    ",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0\") || str.startsWith(\"-0\")) {\n        return null;\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return null;\n    }\n    if (str.startsWith(\"0B\") || str.startsWith(\"-0B\")) {\n        return null;\n    }\n    if (str.startsWith(\"0O\") || str.startsWith(\"-0O\")) {\n        return null;\n    }\n    if (str.startsWith(\"0\") || str.startsWith(\"-0\")) {\n        return null;\n    }\n",
        "public static Number createNumber(String str) throws NumberFormatException {\n    if (str == null) {\n        return null;\n    }\n    if (StringUtils.isBlank(str)) {\n        throw new NumberFormatException(\"A blank string is not a valid number\");\n    }  \n    if (str.startsWith(\"--\")) {\n        return null;\n    }\n// buggy line:    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) {\n        return null;\n    }\n    if (str.startsWith(\"0b\") || str.startsWith(\"-0b\")) {\n        return null;\n    }\n    if (str.startsWith(\"0d\") || str.startsWith(\"-0d\")) {\n        return null;\n    }\n    if (str.startsWith(\"0o\") || str.startsWith(\"-0o\")) {\n        return null;\n    }\n    if (str.startsWith(\"0X\") || str.startsWith(\"-0X\")) {\n        return null;\n    }\n    if (str.startsWith(\"0B\") || str.startsWith(\"-0B\")) {\n        return null;\n    }\n    if (str.startsWith(\"0D\") || str.startsWith(\"-0D\")) {\n        return null;\n    }\n    if (str.startsWith(\"0O\") || str.startsWith(\"-0O\")) {\n      return null;\n    "
      ],
      "function range": "444,5-594,5"
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&",
      "output": [
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.AM_PM)",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Cal",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR) &&\n            cal1",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR) == cal2.get(Cal",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.AM_PM) == cal2.get(Calendar.AM_PM) &&\n            cal1.get(Calendar.HOUR_OF_AMPM) == cal",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) {\n    if (cal1 == null || cal2 == null) {\n        throw new IllegalArgumentException(\"The date must not be null\");\n    }\n    return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) &&\n            cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) &&\n            cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) &&\n// buggy line:            cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) &&\n            cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) &&\n            cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) &&\n            cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) &&\n            cal1.get(Calendar.MONTH) == cal2.get(Calendar.MONTH) &&\n            cal1.get(Calendar.WEEK_OF_YEAR) == cal2.get(Calendar.WEEK_OF_YEAR) &&\n            cal1.get(Calendar.WEEK_OF_MONTH) == cal2.get(Calendar.WEEK_OF_MONTH) &&\n            cal1.get(Calendar.DATE) == cal2.get(Calendar.DATE) &&\n            cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_MONTH) == cal2.get(Calendar.DAY_OF_WEEK_IN_MONTH) &&\n            cal1.get(Calendar.DAY_OF_WEEK_IN_YEAR) == cal2.get(Calendar.DAY_OF_WEEK_IN_YEAR));\n}\n\n}"
      ],
      "function range": "258,5-270,5"
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);",
      "output": [
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis > 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis > 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                if (millis < 10) {\n                    sb.append('0');\n                }\n                sb.append(millis);\n            } else {\n                sb.append(millis);\n            }\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                if (millis < 10) {\n                    sb.append('0');\n                }\n                sb.append(millis);\n            } else {\n                sb.append(millis);\n            }\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                if (millis < 10) {\n                    sb.append('0');\n                }\n                sb.append(millis);\n            } else {\n                sb.append(millis);\n            }\n        }\n        return sb.toString();\n    }\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis > 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file",
        "public String format(Date date) {\n// buggy line:    Calendar c = new GregorianCalendar(mTimeZone);\n        Calendar c = Calendar.getInstance(mTimeZone);\n        c.setTime(date);\n        int year = c.get(Calendar.YEAR);\n        int month = c.get(Calendar.MONTH) + 1;\n        int day = c.get(Calendar.DAY_OF_MONTH);\n        int hour = c.get(Calendar.HOUR_OF_DAY);\n        int minute = c.get(Calendar.MINUTE);\n        int second = c.get(Calendar.SECOND);\n        int millis = c.get(Calendar.MILLISECOND);\n        StringBuilder sb = new StringBuilder();\n        sb.append(year);\n        sb.append(\"-\");\n        if (month < 10) {\n            sb.append('0');\n        }\n        sb.append(month);\n        sb.append('-');\n        if (day < 10) {\n            sb.append('0');\n        }\n        sb.append(day);\n        sb.append(' ');\n        if (hour < 10) {\n            sb.append('0');\n        }\n        sb.append(hour);\n        sb.append(':');\n        if (minute < 10) {\n            sb.append('0');\n        }\n        sb.append(minute);\n        sb.append(':');\n        if (second < 10) {\n            sb.append('0');\n        }\n        sb.append(second);\n        if (millis!= 0) {\n            sb.append('.');\n            if (millis < 100) {\n                sb.append('0');\n            }\n            if (millis < 10) {\n                sb.append('0');\n            }\n            sb.append(millis);\n        }\n        sb.append(' ');\n        return sb.toString();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership"
      ],
      "function range": "819,5-823,5"
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "\n// buggy line:static float toJavaVersionInt(String version) {",
      "output": [
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14));\n//     } else if (version.startsWith(\"15.\")) {\n//         return Integer.parseInt(version.substring(15));\n//     ",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"15.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     ",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 4));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 5));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 6));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 7));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 8));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 9));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 10));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 11));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 12));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 13));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 14));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 15));\n//     } else if (version",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 3));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 3));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 3));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 3));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 3));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 3));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 3));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 3));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 3));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 3));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 3));\n//     } else if (version",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"15.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     ",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 4));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 5));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 6));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 7));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 8));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 9));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 10));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 11));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 12));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 13));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 14));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 15));\n//     } else {\n//",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 3));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 3));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 3));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 3));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 3));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 3));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 3));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 3));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 3));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 3));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 3));\n//     } else {\n//",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 4));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 5));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 6));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 7));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 8));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 9));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 10));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 11));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 12));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 13));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 14));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 15));\n//     }\n//     return",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14));\n//     } else if (version.startsWith(\"15.\")) {\n//         return Integer.parseInt(version.substring(16));\n//     ",
        "\n// buggy line:static float toJavaVersionInt(String version) {\n//     if (version.startsWith(\"1.\")) {\n//         return Integer.parseInt(version.substring(1, 3));\n//     } else if (version.startsWith(\"2.\")) {\n//         return Integer.parseInt(version.substring(2, 3));\n//     } else if (version.startsWith(\"3.\")) {\n//         return Integer.parseInt(version.substring(3, 3));\n//     } else if (version.startsWith(\"4.\")) {\n//         return Integer.parseInt(version.substring(4, 3));\n//     } else if (version.startsWith(\"5.\")) {\n//         return Integer.parseInt(version.substring(5, 3));\n//     } else if (version.startsWith(\"6.\")) {\n//         return Integer.parseInt(version.substring(6, 3));\n//     } else if (version.startsWith(\"7.\")) {\n//         return Integer.parseInt(version.substring(7, 3));\n//     } else if (version.startsWith(\"8.\")) {\n//         return Integer.parseInt(version.substring(8, 3));\n//     } else if (version.startsWith(\"9.\")) {\n//         return Integer.parseInt(version.substring(9, 3));\n//     } else if (version.startsWith(\"10.\")) {\n//         return Integer.parseInt(version.substring(10, 3));\n//     } else if (version.startsWith(\"11.\")) {\n//         return Integer.parseInt(version.substring(11, 3));\n//     } else if (version.startsWith(\"12.\")) {\n//         return Integer.parseInt(version.substring(12, 3));\n//     } else if (version.startsWith(\"13.\")) {\n//         return Integer.parseInt(version.substring(13, 3));\n//     } else if (version.startsWith(\"14.\")) {\n//         return Integer.parseInt(version.substring(14, 3));\n//     }\n//     return"
      ],
      "function range": "1672,5-1674,5"
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();",
      "output": [
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.al",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n}\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperator",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.al",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.al",
        "public static Class<?>[] toClass(Object[] array) {\n    if (array == null) {\n        return null;\n    } else if (array.length == 0) {\n        return ArrayUtils.EMPTY_CLASS_ARRAY;\n    }\n    Class<?>[] classes = new Class[array.length];\n    for (int i = 0; i < array.length; i++) {\n// buggy line:        classes[i] = array[i].getClass();\n        classes[i] = array[i].getClass();\n    }\n    return classes;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra"
      ],
      "function range": "902,5-913,5"
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength != replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();",
      "output": [
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (noMoreMatches",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - 1;\n        if (noMoreMatchesForReplIndex[i",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementLength - searchLength;\n        if (noMoreMatchesForReplIndex[i] || searchList",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = searchList[i].length() - replacementList[i].length();\n        if (noMoreMatches",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - (searchList[i].length() - 1);\n        if (",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - searchList[i].length();\n        increase += greater;\n",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - searchList[i].length() + 1;\n        if (no",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - searchList[i].length();\n        if (increase < greater",
        "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                  boolean repeat, int timeToLive) \n{\n    if (text == null || text.length() == 0 || searchList == null || \n        searchList.length == 0 || replacementList == null || replacementList.length == 0) \n    {\n        return text;\n    }\n    if (timeToLive < 0) {\n        throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n    }\n    int searchLength = searchList.length;\n    int replacementLength = replacementList.length;\n    if (searchLength!= replacementLength) {\n        throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n            + searchLength\n            + \" vs \"\n            + replacementLength);\n    }\n    boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n    int textIndex = -1;\n    int replaceIndex = -1;\n    int tempIndex = -1;\n    for (int i = 0; i < searchLength; i++) {\n        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n            searchList[i].length() == 0 || replacementList[i] == null) \n        {\n            continue;\n        }\n        tempIndex = text.indexOf(searchList[i]);\n        if (tempIndex == -1) {\n            noMoreMatchesForReplIndex[i] = true;\n        } else {\n            if (textIndex == -1 || tempIndex < textIndex) {\n                textIndex = tempIndex;\n                replaceIndex = i;\n            }\n        }\n    }\n    if (textIndex == -1) {\n        return text;\n    }\n    int start = 0;\n    int increase = 0;\n    for (int i = 0; i < searchList.length; i++) {\n// buggy line:        int greater = replacementList[i].length() - searchList[i].length();\n        int greater = replacementList[i].length() - (textIndex - start);\n        if (increase < greater)"
      ],
      "function range": "3605,5-3731,5"
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());",
      "output": [
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}\n\npublic static int",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static boolean equalsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.equalsIgnoreCase(searchStr);\n}\n\npublic static boolean equals(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    ",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static boolean equalsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return equals(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().equals(searchStr.toUpperCase());\n}\n\npublic static boolean equals(String",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n  }\n\n  public static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n  }\n\n  public static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n  }\n\n  public static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n  }\n\n  public static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n  }\n\n  public static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n  }\n\n  public static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int start) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase(), start);\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(), start);",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return INDEX_NOT_FOUND;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().indexOf(searchStr.toUpperCase());\n}",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int startIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase(), startIndex);\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(),",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int startPos) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase(), startPos);\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(),",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr, int fromIndex) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n// buggy line:    return indexOf(str.toUpperCase(), searchStr.toUpperCase(), fromIndex);\n    return str.toUpperCase().indexOf(searchStr.toUpperCase(),",
        "public static boolean containsIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return contains(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().contains(searchStr.toUpperCase());\n}\n\npublic static boolean contains(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.contains(searchStr);\n}\n\npublic static boolean startsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return startsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().startsWith(searchStr.toUpperCase());\n}\n\npublic static boolean startsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.startsWith(searchStr);\n}\n\npublic static boolean endsWithIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n// buggy line:    return endsWith(str.toUpperCase(), searchStr.toUpperCase());\n    return str.toUpperCase().endsWith(searchStr.toUpperCase());\n}\n\npublic static boolean endsWith(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return false;\n    }\n    return str.endsWith(searchStr);\n}\n\npublic static int indexOfIgnoreCase(String str, String searchStr) {\n    if (str == null || searchStr == null) {\n        return -1;\n    }\n    return indexOf(str.toUpperCase(), searchStr.toUpperCase());\n}\n\npublic static int indexOf(String str, String searchStr) {\n    if (str == null || searchStr == null) {"
      ],
      "function range": "1044,5-1049,5"
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null ? null : appendTo.append(QUOTE);",
      "output": [
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.Algebricks",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n        StringBuffer appendTo, boolean escapingOn) {\n    int start = pos.getIndex();\n    char[] c = pattern.toCharArray();\n    if (escapingOn && c[start] == QUOTE) {\n// buggy line:        return appendTo == null? null : appendTo.append(QUOTE);\n      return appendTo == null? null : appendTo.append(c[start]);\n    }\n    for (int i = start; i < c.length; i++) {\n      if (c[i] == QUOTE) {\n        appendTo.append(c[i]);\n        if (i + 1 < c.length && c[i + 1] == QUOTE) {\n          appendTo.append(c[i + 1]);\n          i++;\n        }\n      } else {\n        appendTo.append(c[i]);\n      }\n    }\n    return appendTo;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache"
      ],
      "function range": "417,5-444,5"
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) == 's' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) == 's');\n            }\n// buggy line:        }",
      "output": [
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 't') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) == 'U') &&\n                    ",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n// buggy line:        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 'f') {\n                return \n                    (str.charAt(1) == 'a' || str.charAt(1) == 'A') &&\n                    (str.charAt(2) == 'l' || str.charAt(2) == 'L') &&\n                    ",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 't' || ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 'f' || ch0 == 'F') &&\n                (ch1 == 'a' || ch1 == 'A') &&\n                (ch2 == 'l' || ch2 == 'L') &&\n                (ch3 =='s' || ch3 == 'S');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'f' || ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'r' || ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return\n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return\n                (ch0 == 'f' || ch0 == 'F",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            char ch4 = str.charAt(4);\n            return \n                (ch0 == 'a' || ch0 ==",
        "public static boolean toBoolean(String str) {\n    if (str == \"true\") {\n        return true;\n    }\n    if (str == null) {\n        return false;\n    }\n    switch (str.length()) {\n        case 2: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            return \n                (ch0 == 'o' || ch0 == 'O') &&\n                (ch1 == 'n' || ch1 == 'N');\n        }\n        case 3: {\n            char ch = str.charAt(0);\n            if (ch == 'y') {\n                return \n                    (str.charAt(1) == 'e' || str.charAt(1) == 'E') &&\n                    (str.charAt(2) =='s' || str.charAt(2) == 'S');\n            }\n            if (ch == 'Y') {\n                return \n                    (str.charAt(1) == 'E' || str.charAt(1) == 'e') &&\n                    (str.charAt(2) == 'S' || str.charAt(2) =='s');\n            }\n// buggy line:        }\n        case 4: {\n            char ch0 = str.charAt(0);\n            char ch1 = str.charAt(1);\n            char ch2 = str.charAt(2);\n            char ch3 = str.charAt(3);\n            return \n                (ch0 == 't' || ch0 == 'T') &&\n                (ch1 == 'r' || ch1 == 'R') &&\n                (ch2 == 'u' || ch2 == 'U') &&\n                (ch3 == 'e' || ch3 == 'E');\n        }\n        case 5: {\n            char ch = str.charAt(0);\n            if (ch == 't' || ch == 'T') {\n                return \n                    (str.charAt(1) == 'r' || str.charAt(1) == 'R') &&\n                    (str.charAt(2) == 'u' || str.charAt(2) =="
      ],
      "function range": "649,5-700,5"
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);",
      "output": [
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\n",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.al",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "public static boolean isAvailableLocale(Locale locale) {\n// buggy line:    return cAvailableLocaleSet.contains(locale);\n        return cAvailableLocaleSet.contains(locale);\n    }\n\n    public static Locale[] getAvailableLocales() {\n        Locale[] locales = new Locale[cAvailableLocaleSet.size()];\n        cAvailableLocaleSet.toArray(locales);\n        return locales;\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCall"
      ],
      "function range": "222,5-224,5"
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null ? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);",
      "output": [
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.to",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null?",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, String padStr) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.to",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width) {\n    return appendFixedWidthPadRight(obj, width,'');\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width) {\n    return appendFixed",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        int padLen = width - size;\n        for (int i = 0; i <",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        for (int i = 0; i < width; i++) {\n            buffer[size",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(Object obj, int width, int padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null?",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  public StrBuilder appendFixedWidthPadRight(int i, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        int padLen = width - i;\n        for (int j = 0",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadLeft(Object obj, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        String str = (obj == null? getNullText() : obj.toString());\n        int strLen = str.length();\n        if (strLen >= width) {\n// buggy line:            str.getChars(0, strLen, buffer, size);\n            for (int i = 0; i < strLen; i++) {\n                buffer[size + i] = str.charAt(i);\n            }\n        } else {\n            int padLen = width - strLen;\n            for (int i = 0; i < padLen; i++) {\n                buffer[size + i] = padChar;\n            }\n            str.getChars(0, strLen, buffer, size + padLen);\n        }\n        size += width;\n    }\n    return this;\n  }\n\n  @Override\n  public StrBuilder appendFixedWidthPadRight(int i, int width, char padChar) {\n    if (width > 0) {\n        ensureCapacity(size + width);\n        int padLen = width - i;"
      ],
      "function range": "878,5-895,5"
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0 ? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;",
      "output": [
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex > size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex >= size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex > size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return lastIndexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex - 1; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    ",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex > size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - 1);\n",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex > size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic String substring(int start, int end) {\n    start = (start < 0? 0 : start",
        "public int indexOf(String str, int startIndex) {\n    startIndex = (startIndex < 0? 0 : startIndex);\n    if (str == null || startIndex >= size) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 1) {\n        return indexOf(str.charAt(0), startIndex);\n    }\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i <= len - strLen; i++) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str, int startIndex) {\n    startIndex = (startIndex > size? size - 1 : startIndex);\n    if (str == null || startIndex < 0) {\n        return -1;\n    }\n    int strLen = str.length();\n    if (strLen == 0) {\n        return startIndex;\n    }\n    if (strLen > size) {\n        return -1;\n    }\n    char[] thisBuf = buffer;\n// buggy line:    int len = thisBuf.length - strLen;\n    int len = size - strLen;\n    outer:\n    for (int i = startIndex; i >= 0; i--) {\n        for (int j = 0; j < strLen; j++) {\n            if (str.charAt(j)!= thisBuf[i + j]) {\n                continue outer;\n            }\n        }\n        return i;\n    }\n    return -1;\n}\n\npublic int lastIndexOf(String str) {\n    return lastIndexOf(str, size - str.length"
      ],
      "function range": "1760,5-1787,5"
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();",
      "output": [
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricStandardDeviation() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricVariance() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricSkewness() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricKurtosis() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getPercentile(double p) {\n",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getPercentile(double p)",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getPercentile(double percentile) {\n",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getPercentile(double percentile)",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        ",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumberOfSuccesses() {\n        ",
        "public double getNumericalMean() {\n// buggy line:    return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize();\n        return (double) getNumberOfSuccesses() / (double) getPopulationSize();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getNumericalVariance() {\n        return getNumericalMean() * (1.0 - getNumericalMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getStandardDeviation() {\n        return Math.sqrt(getNumericalVariance());\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getSkewness() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getKurtosis() {\n        return Double.NaN;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getGeometricMean() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMax() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMin() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getMode() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double[] getMedian() {\n        throw new UnsupportedOperationException(\"Not supported yet.\");\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getPercentile(double p"
      ],
      "function range": "267,5-269,5"
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;",
      "output": [
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     * @param real the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     * @param imaginary the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Sets the real and imaginary parts of this complex number.\n     * @param real the real part of this complex number.\n     * @param imaginary the imaginary part of",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Sets the real and imaginary parts",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Sets the real and imaginary parts of this complex number.\n     *",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Sets both the real and imaginary",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Returns a <code>String",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n}\n<|java|>/*\n *",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n}\n<|java|>/*\n",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Returns a string representing this complex",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n    /**\n     * Sets this complex number to the",
        "public Complex reciprocal() {\n    if (isNaN) {\n        return NaN;\n    }\n    if (real == 0.0 && imaginary == 0.0) {\n// buggy line:        return NaN;\n        return new Complex(0.0, 0.0);\n    }\n    return new Complex(1.0 / real, -1.0 / imaginary);\n}\n\n    /**\n     * Returns the argument of this complex number.\n     *\n     * @return the argument of this complex number.\n     */\n    public double getArgument() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the modulus of this complex number.\n     *\n     * @return the modulus of this complex number.\n     */\n    public double getModulus() {\n        return Math.sqrt(real * real + imaginary * imaginary);\n    }\n\n    /**\n     * Returns the phase (in radians) of this complex number.\n     *\n     * @return the phase (in radians) of this complex number.\n     */\n    public double getPhase() {\n        return Math.atan2(imaginary, real);\n    }\n\n    /**\n     * Returns the real part of this complex number.\n     *\n     * @return the real part of this complex number.\n     */\n    public double getReal() {\n        return real;\n    }\n\n    /**\n     * Returns the imaginary part of this complex number.\n     *\n     * @return the imaginary part of this complex number.\n     */\n    public double getImaginary() {\n        return imaginary;\n    }\n\n    /**\n     * Sets the real part of this complex number.\n     *\n     * @param real\n     *            the real part of this complex number.\n     */\n    public void setReal(double real) {\n        this.real = real;\n    }\n\n    /**\n     * Sets the imaginary part of this complex number.\n     *\n     * @param imaginary\n     *            the imaginary part of this complex number.\n     */\n    public void setImaginary(double imaginary) {\n        this.imaginary = imaginary;\n    }\n\n}\n<|java|>package com"
      ],
      "function range": "299,5-321,5"
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));",
      "output": [
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on",
        "public Line revert() {\n// buggy line:    final Line reverted = new Line(zero, zero.subtract(direction));\n// fixed line:    final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        final Line reverted = new Line(zero, zero.subtract(direction.negate()));\n        return reverted;\n    }\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = 1;\n        result = prime * result + ((direction == null)? 0 : direction.hashCode());\n        result = prime * result + ((zero == null)? 0 : zero.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj == null)\n            return false;\n        if (getClass()!= obj.getClass())\n            return false;\n        final Line other = (Line) obj;\n        if (direction == null) {\n            if (other.direction!= null)\n                return false;\n        } else if (!direction.equals(other.direction))\n            return false;\n        if (zero == null) {\n            if (other.zero!= null)\n                return false;\n        } else if (!zero.equals(other.zero))\n            return false;\n        return true;\n    }\n\n    @Override\n    public String toString() {\n        return \"Line [zero=\" + zero + \", direction=\" + direction + \"]\";\n    }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed"
      ],
      "function range": "86,5-89,5"
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length != dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) *",
      "output": [
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double cumulativeProbability(final double z) throws MathIllegalArgumentException {\n    return 0.5 * (1 + FastMath.exp(-0.5 * z));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *    Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double cumulativeProbability(final double z) throws MathIllegalArgumentException {\n    return 0.5 * (1 + FastMath.exp(-0.5 * z));\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return super.inverseCumulativeProbability(p);\n  }\n\n",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *    Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return super.inverseCumulativeProbability(p);\n  }\n\n",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return super.inverseCumulativeProbability(p);\n  }\n",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *    Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return super.inverseCumulativeProbability(p);\n  }\n",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return FastMath.sqrt(-2 * FastMath.log(p));\n  ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *    Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p == 0) {\n      return 0;\n    }\n    if (p == 1) {\n      return Double.POSITIVE_INFINITY;\n    }\n    return FastMath.sqrt(-2 * FastMath.log(p));\n  ",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p < 0.0 || p > 1.0) {\n        throw new MathException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n    } else if (p == 1.0) {",
        "public double density(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n    return FastMath.pow(2 * FastMath.PI, -dim / 2) * FastMath.exp(-0.5 * vals[0] * vals[0]);\n  }\n\n  /** {@inheritDoc} */\n  public double cumulativeProbability(final double[] vals) throws DimensionMismatchException {\n    final int dim = getDimension();\n    if (vals.length!= dim) {\n        throw new DimensionMismatchException(vals.length, dim);\n    }\n// buggy line:    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n    return 0.5 * (1 + FastMath.exp(-0.5 * vals[0] * vals[0]));\n  }\n\n  /** {@inheritDoc} */\n  @Override\n  protected double getSolverAbsoluteAccuracy() {\n    return solverAbsoluteAccuracy;\n  }\n\n  /**\n   * {@inheritDoc}\n   *\n   * The implementation of this method is based on:\n   * <ul>\n   *  <li>\n   *   <a href=\"http://mathworld.wolfram.com/Chi-SquaredDistribution.html\">\n   *   Chi-Squared Distribution</a>, equation (9).</li>\n   *  </ul>\n   */\n  public double inverseCumulativeProbability(final double p) throws MathException {\n    if (p < 0.0 || p > 1.0) {\n        throw new MathException(LocalizedFormats.OUT_OF_RANGE_SIMPLE, p, 0.0, 1.0);\n    } else if (p == 0.0) {"
      ],
      "function range": "177,5-186,5"
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return",
      "output": [
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n        return super.repairAndDecode(x);\n    }\n\n    @Override\n    public double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n        return super.decode(x);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\n",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n        return super.repairAndDecode(x);\n    }\n\n    @Override\n    public double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n        return super.decode(x);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n        return super.repairAndDecode(x);\n    }\n\n    @Override\n    public double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n        return super.decode(x);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n\t\treturn super.repairAndDecode(x);\n\t}\n\n\t@Override\n\tpublic double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n\t\treturn super.decode(x);\n\t}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.",
        "public double[] repairAndDecode(final double[] x) {\n// buggy line:    return super.repairAndDecode(x);\n        return super.repairAndDecode(x);\n    }\n\n    @Override\n    public double[] decode(final double[] x) {\n// buggy line:    return super.decode(x);\n        return super.decode(x);\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks."
      ],
      "function range": "920,9-923,9"
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();",
      "output": [
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.log",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.al",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyr",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogical",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExp",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.ConstantExpression;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyracks.algebricks.core",
        "public double percentageValue() {\n// buggy line:    return multiply(100).doubleValue();\n        return multiply(100d).doubleValue();\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.AbstractFunctionCallExpression;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.VariableReferenceExp"
      ],
      "function range": "596,5-598,5"
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;",
      "output": [
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n        final int n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n\n    final int n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n2 * n1;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n    final int n",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// buggy line:",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// don't work",
        "private double calculateAsymptoticPValue(final double Umin,\n                                         final int n1,\n                                         final int n2)\n    throws ConvergenceException, MaxCountExceededException {\n// buggy line:    final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n// doesn't work:  final int n1n2prod = n1 * n2;\n        final double n"
      ],
      "function range": "168,5-184,5"
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {",
      "output": [
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.al",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.",
        "@Override\nprotected void computeGeometricalProperties() {\n    final Vector2D[][] v = getVertices();\n    if (v.length == 0) {\n        final BSPTree<Euclidean2D> tree = getTree(false);\n// buggy line:        if ((Boolean) tree.getAttribute()) {\n        if (tree.getCut() == null) {\n            return;\n        }\n    }\n    super.computeGeometricalProperties();\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical."
      ],
      "function range": "129,5-181,5"
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {",
      "output": [
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getArtificialVariableOffset();",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset();",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (Integer colToDrop : columnsToDrop)",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = 0; i < getNum",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (Integer i : columnsToDrop) {\n",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = 0; i < columnsTo",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (Integer col : columnsToDrop) {\n",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = 0; i < getNum",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(0);\n        }\n    }\n    for (Integer colToDrop : columnsToDrop)",
        "protected void dropPhase1Objective() {\n    if (getNumObjectiveFunctions() == 1) {\n        return;\n    }\n    List<Integer> columnsToDrop = new ArrayList<Integer>();\n    columnsToDrop.add(0);\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getArtificialVariableOffset(); i < getNumArtificialVariables(); i++) {\n        final double entry = tableau.getEntry(0, i);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNumObjectiveFunctions(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) {\n        final double entry = tableau.getEntry(i + 1, 0);\n// buggy line:        if (Precision.compareTo(entry, 0d, maxUlps) > 0) {\n        if (Precision.compareTo(entry, 0d, maxUlps) >= 0) {\n            columnsToDrop.add(i);\n        }\n    }\n    for (int i = 0; i < getNum"
      ],
      "function range": "327,5-367,5"
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();",
      "output": [
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Collection<Chromosome> values() {\n        return chromosomes.values();\n    }\n\n    @Override\n    public Set<Entry<String, Chromosome>> entrySet",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Chromosome computeIfAbsent(String key, Function<? super String,? extends Chromosome> mappingFunction) {\n        return chromosomes.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public Chromosome computeIfPresent(String key, BiFunction<?",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(Chromosome key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends Chromosome,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(Chromosome key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(Chromosome key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(Chromosome key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<Chromosome> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Collection<Chromosome> values() {\n        return chromosomes.values();\n    }\n\n    ",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Collection<Chromosome> values() {\n        return chromosomes.values();\n    }\n\n    @Override\n    public Set<Map.Entry<String, Chromosome>>",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Collection<Chromosome> values() {\n        return chromosomes.values();\n    }\n\n    @Override\n    public Set<java.util.Map.Entry<String,",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public void forEach(BiConsumer<? super String,? super Chromosome> action) {\n        chromosomes.forEach(action);\n    }\n\n    @Override\n    public void replaceAll(BiFunction<? super String,? super Chromosome,? extends Chromosome> function) {",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(Chromosome key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends Chromosome,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(Chromosome key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(Chromosome key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(Chromosome key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Chromosome computeIfAbsent(Chromosome key, Function<? super Chromosome,? extends Chromosome> mappingFunction) {\n        return chromosomes.computeIfAbsent(key, mappingFunction);\n    }\n\n",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<Chromosome> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Collection<Chromosome> values() {\n        return chromosomes.values();\n    }\n\n    @Override\n    public Set<Entry<String, Chromosome",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return chromosomes.keySet();\n    }\n\n    @Override\n    public Set<Map.Entry<String, Chromosome>> entrySet() {\n        return chromosomes.entrySet();\n    }\n\n    @Override\n    public Collection<Chromos",
        "public Iterator<Chromosome> iterator() {\n// buggy line:    return chromosomes.iterator();\n        return chromosomes.values().iterator();\n    }\n\n    @Override\n    public int size() {\n        return chromosomes.size();\n    }\n\n    @Override\n    public boolean isEmpty() {\n        return chromosomes.isEmpty();\n    }\n\n    @Override\n    public boolean containsKey(Object key) {\n        return chromosomes.containsKey(key);\n    }\n\n    @Override\n    public boolean containsValue(Object value) {\n        return chromosomes.containsValue(value);\n    }\n\n    @Override\n    public Chromosome get(Object key) {\n        return chromosomes.get(key);\n    }\n\n    @Override\n    public Chromosome put(String key, Chromosome value) {\n        return chromosomes.put(key, value);\n    }\n\n    @Override\n    public Chromosome remove(Object key) {\n        return chromosomes.remove(key);\n    }\n\n    @Override\n    public void putAll(Map<? extends String,? extends Chromosome> m) {\n        chromosomes.putAll(m);\n    }\n\n    @Override\n    public void clear() {\n        chromosomes.clear();\n    }\n\n    @Override\n    public Chromosome putIfAbsent(String key, Chromosome value) {\n        return chromosomes.putIfAbsent(key, value);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return chromosomes.remove(key, value);\n    }\n\n    @Override\n    public boolean replace(String key, Chromosome oldValue, Chromosome newValue) {\n        return chromosomes.replace(key, oldValue, newValue);\n    }\n\n    @Override\n    public Chromosome replace(String key, Chromosome value) {\n        return chromosomes.replace(key, value);\n    }\n\n    @Override\n    public Chromosome computeIfAbsent(String key, Function<? super String,? extends Chromosome> mappingFunction) {\n        return chromosomes.computeIfAbsent(key, mappingFunction);\n    }\n\n    @Override\n    public boolean remove(Object key, Object value) {\n        return"
      ],
      "function range": "208,5-210,5"
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {",
      "output": [
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - means[i];\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n      if (length == 1) {\n        var = 0.0;\n      } else if (length > 1) {\n        double accum = 0.0;\n        double dev = 0.0;\n        double accum2 = 0.0;\n        for (int i = begin; i < begin + length; i++) {\n          dev = values[i] - means[i];\n          accum += weights[i] * (dev * dev);\n          accum2 += weights[i] * dev;\n        }\n        double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n\n  public double evaluate(final double[] values, final double[] weights,\n                         final double[] means, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - means[i];\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n            for (int i = 0; i < weights.length; i",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to you under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.",
        "public double evaluate(final double[] values, final double[] weights,\n                       final double mean, final int begin, final int length) {\n    double var = Double.NaN;\n    if (test(values, weights, begin, length)) {\n        if (length == 1) {\n            var = 0.0;\n        } else if (length > 1) {\n            double accum = 0.0;\n            double dev = 0.0;\n            double accum2 = 0.0;\n            for (int i = begin; i < begin + length; i++) {\n                dev = values[i] - mean;\n                accum += weights[i] * (dev * dev);\n                accum2 += weights[i] * dev;\n            }\n            double sumWts = 0;\n// buggy line:            for (int i = 0; i < weights.length; i++) {\n// buggy line:                sumWts += weights[i];\n// buggy line:            }\n// buggy line:            if (sumWts > 0) {\n// buggy line:                var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n// buggy line:            }\n            var = (accum - (accum2 * accum2 / sumWts)) / sumWts;\n        }\n    }\n    return var;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*"
      ],
      "function range": "501,5-532,5"
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/**\n * Copyright (c) Microsoft Corporation. All rights reserved.\n * Licensed under the MIT License. See License.txt in the project root for\n * license information",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return inverted? x1 : x0;\n        }\n        if (Math.abs(f1) <= ftol) {\n            return inverted? x1 : x0;\n        }\n    }\n}\n}\n<|java|>/**\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n *",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                break;\n            default:\n                throw MathRuntimeException.createIllegalStateException(method);\n            }\n            x1 = x;\n            f1 = fx;\n        }\n        if (Math.abs(x1 - x0) <= atol + rtol * (Math.abs(x1) + Math.abs(x0))) {\n            return x;\n        }\n        if (Math.abs(f1) <= ftol * Math.abs(f0)) {\n            return x;\n        }\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file distributed with\n * this work for additional"
      ],
      "function range": "129,5-251,5"
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-191": {
      "loc": "187-191",
      "input": "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted = !inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }",
      "output": [
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                } else {\n// buggy line:                    x1 = 0.5 * (x0 + x1 + FastMath.min(rtol * FastMath.abs(x0), atol));\n// buggy line:                    f1 = computeObjectiveValue(x1);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                } else {\n// buggy line:                    x1 = 0.5 * (x0 + x1 + FastMath.min(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f1 = computeObjectiveValue(x1);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE,\n                                                   ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathIllegalStateException(LocalizedFormats.SIMPLE_MESSAGE, method);\n            }\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathIllegalStateException(LocalizedFormats.UNKNOWN_METHOD, method);\n            }\n        }\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathIllegalStateException(LocalizedFormats.METHOD_NOT_SUPPORTED_YET,\n                                ",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                } else {\n// buggy line:                    x1 = 0.5 * (x0 + x1 + FastMath.min(rtol * FastMath.abs(x0), atol));\n// buggy line:                    f1 = computeObjectiveValue(x1);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1);\n                    f0 = computeObject",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                // Should never happen.\n                throw MathRuntimeException.createInternalError(method.toString());\n            }\n        }",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                throw new MathIllegalStateException(LocalizedFormats.METHOD_NOT_SUPPORTED_YET, method);\n",
        "protected final double doSolve() {\n    double x0 = getMin();\n    double x1 = getMax();\n    double f0 = computeObjectiveValue(x0);\n    double f1 = computeObjectiveValue(x1);\n    if (f0 == 0.0) {\n        return x0;\n    }\n    if (f1 == 0.0) {\n        return x1;\n    }\n    verifyBracketing(x0, x1);\n    final double ftol = getFunctionValueAccuracy();\n    final double atol = getAbsoluteAccuracy();\n    final double rtol = getRelativeAccuracy();\n    boolean inverted = false;\n    while (true) {\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n        if (f1 * fx < 0) {\n            x0 = x1;\n            f0 = f1;\n            inverted =!inverted;\n        } else {\n            switch (method) {\n            case ILLINOIS:\n                f0 *= 0.5;\n                break;\n            case PEGASUS:\n                f0 *= f1 / (f1 + fx);\n                break;\n            case REGULA_FALSI:\n// buggy line:                if (x == x1) {\n// buggy line:                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n// buggy line:                    f0 = computeObjectiveValue(x0);\n// buggy line:                }\n                if (x == x1) {\n                    x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol));\n                    f0 = computeObjectiveValue(x0);\n                }\n                break;\n            default:\n                // Should never happen.\n                throw MathRuntimeException.createInternalError(method.toString());\n            }\n            f"
      ],
      "function range": "128,5-253,5"
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(),",
      "output": [
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n  }\n\n  public Complex negate() {\n// buggy line:    return createComplex(-real, -imaginary);\n    return createComplex(-real, -imaginary);\n  }\n\n  public Complex conjugate() {\n// buggy line:    return createComplex(real, -imaginary);\n    return",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex negate() {\n// buggy line:    return createComplex(-real, -imaginary);\n    return createComplex(-real, -imaginary);\n  }\n\n  @Override\n  public Complex",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex negate() {\n    return createComplex(-real, -imaginary);\n  }\n\n  @Override\n  public Complex conjugate() {\n    return createComplex(real, -imaginary",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return createComplex(-real, -imaginary);\n  }\n\n  @Override\n  public Complex conjugate() {\n    return createComplex(real, -imaginary",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() * rhs.getReal() - imaginary * rhs.getImaginary());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() * rhs.getReal() - imaginary * rhs.getImaginary());\n  }\n\n  @Override\n  public double getReal() {\n    return real;\n  }\n\n  @Override\n  public double getImaginary() {\n    return imaginary;",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() * rhs.getReal() - imaginary * rhs.getImaginary());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() * rhs.getReal() - imaginary * rhs.getImaginary());\n  }\n\n  @Override\n  public Complex negate() {\n    return createComplex(-real, -imaginary);\n  }\n\n  @Override\n  public Complex conjugate()",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n  }\n\n  @Override\n  public double getReal() {\n    return real;\n  }\n\n  @Override\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  @Override\n  public Complex conjug",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n  }\n\n  @Override\n  public double getReal() {\n    return real;\n  }\n\n  @Override\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  @Override\n  public Complex add(",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), imaginary * rhs.getReal() - real * rhs.getImaginary());\n  }\n\n  @Override\n  public double getReal() {\n    return real;\n  }\n\n  @Override\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  @Override\n  public Complex conjug",
        "public Complex add(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n    return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary());\n  }\n\n  @Override\n  public Complex subtract(Complex rhs)\n    throws NullArgumentException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n    return createComplex(real - rhs.getReal(), imaginary - rhs.getImaginary());\n  }\n\n  @Override\n  public Complex multiply(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() - imaginary * rhs.getImaginary(), real * rhs.getImaginary() + imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex divide(Complex rhs)\n    throws NullArgumentException, MathArithmeticException {\n    MathUtils.checkNotNull(rhs);\n// buggy line:    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n    return createComplex(real * rhs.getReal() + imaginary * rhs.getImaginary(), real * rhs.getImaginary() - imaginary * rhs.getReal());\n  }\n\n  @Override\n  public Complex negate() {\n// buggy line:    return createComplex(-real, -imaginary);\n    return createComplex(-real, -imaginary);\n  }\n\n  @Override\n  public boolean"
      ],
      "function range": "150,5-155,5"
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;",
      "output": [
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.Algeb",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.h",
        "public int[] getCounts(int index) {\n    if (index < 0 ||\n        index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n    final int[] indices = new int[dimension];\n    int count = 0;\n    for (int i = 0; i < last; i++) {\n        int idx = 0;\n        final int offset = uniCounterOffset[i];\n        while (count <= index) {\n            count += offset;\n            ++idx;\n        }\n        --idx;\n        count -= offset;\n        indices[i] = idx;\n    }\n// buggy line:    int idx = 1;\n// buggy line:    while (count < index) {\n// buggy line:        count += idx;\n// buggy line:        ++idx;\n// buggy line:    }\n// buggy line:    --idx;\n// buggy line:    indices[last] = idx;\n    return indices;\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor"
      ],
      "function range": "216,5-246,5"
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;",
      "output": [
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            if (index <= dx2[i]) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= dx2[i];\n// buggy line:        }\n        int sum = 0;\n        for (int i = 0; i < dx2.length; i++) {\n            T p = pointSet.get(i);\n            dx2[i] = p.squaredDistance(firstPoint);\n            sum += dx2[i];\n        }\n        int index = random.nextInt(sum);\n        for (int i = 0; i < dx2.length; i++) {\n            if (index <= dx2[i]) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            if (index <= dx2[i]) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= dx2[i];\n// buggy line:        }\n        int sum = 0;\n        for (int i = 0; i < dx2.length; i++) {\n            dx2[i] = firstPoint.squaredDistance(pointSet.get(i));\n            sum += dx2[i];\n        }\n        int index = random.nextInt(sum);\n        for (int i = 0; i < dx2.length; i++) {\n            if (index <= dx2[i]) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int sum = 0;\n        for (int i = 0; i < dx2.length; i++) {\n            T p = pointSet.get(i);\n            dx2[i] = p.squaredDistance(firstPoint);\n            sum += dx2[i];\n        }\n        int index = random.nextInt(sum);\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(dx2.length);\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n}\n<|java|>package",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(pointSet.size());\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n}\n<|java|>package",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(dx2.length);\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(pointSet.size());\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n}\n<|java|>/*",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(dx2.length);\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n\n  private static <T extends Clusterable<",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(pointSet.size());\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n\n  private static <T extends Clusterable<",
        "private static <T extends Clusterable<T>> List<Cluster<T>>\n    chooseInitialCenters(final Collection<T> points, final int k, final Random random) {\n    final List<T> pointSet = new ArrayList<T>(points);\n    final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>();\n    final T firstPoint = pointSet.remove(random.nextInt(pointSet.size()));\n    resultSet.add(new Cluster<T>(firstPoint));\n    final double[] dx2 = new double[pointSet.size()];\n    while (resultSet.size() < k) {\n// buggy line:        int sum = 0;\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            T p = pointSet.get(i);\n// buggy line:            dx2[i] = p.squaredDistance(firstPoint);\n// buggy line:            sum += dx2[i];\n// buggy line:        }\n// buggy line:        int index = random.nextInt(sum);\n// buggy line:        for (int i = 0; i < dx2.length; i++) {\n// buggy line:            double d = dx2[i];\n// buggy line:            if (index <= d) {\n// buggy line:                T p = pointSet.get(i);\n// buggy line:                resultSet.add(new Cluster<T>(p));\n// buggy line:                pointSet.remove(p);\n// buggy line:                break;\n// buggy line:            }\n// buggy line:            index -= d;\n// buggy line:        }\n        int index = random.nextInt(dx2.length);\n        for (int i = 0; i < dx2.length; i++) {\n            double d = dx2[i];\n            if (index <= d) {\n                T p = pointSet.get(i);\n                resultSet.add(new Cluster<T>(p));\n                pointSet.remove(p);\n                break;\n            }\n            index -= d;\n        }\n    }\n    return resultSet;\n  }\n}\n<|java|>/**"
      ],
      "function range": "161,5-198,5"
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);",
      "output": [
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.h",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Abstract",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Con",
        "public double[] fit() {\n    final double[] guess = (new ParameterGuesser(getObservations())).guess();\n// buggy line:    return fit(new Gaussian.Parametric(), guess);\n    return fit(new Gaussian.Parametric(), guess);\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.expressions.Variable"
      ],
      "function range": "119,5-122,5"
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b);",
      "output": [
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : a + b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g, h), i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e), f, g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e), f, g, h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : a + b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f), g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e), f, g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e), f, g, h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max(",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : a + b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e), f, g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e), f, g, h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e), f, g, h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return",
        "public static float max(final float a, final float b) {\n// buggy line:    return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b);\n        return (a <= b)? a : (Float.isNaN(a + b)? Float.NaN : b);\n    }\n\n    public static float max(final float a, final float b, final float c) {\n        return max(max(a, b), c);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d) {\n        return max(max(a, b, c), d);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e) {\n        return max(max(a, b, c, d), e);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f) {\n        return max(max(a, b, c, d, e), f);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g) {\n        return max(max(a, b, c, d, e, f), g);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h) {\n        return max(max(a, b, c, d, e, f, g), h);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i) {\n        return max(max(a, b, c, d, e, f, g), h, i);\n    }\n\n    public static float max(final float a, final float b, final float c, final float d, final float e, final float f, final float g, final float h, final float i, final float j) {\n        return max("
      ],
      "function range": "3481,5-3483,5"
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;",
      "output": [
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n// buggy line:    return (x == null && y == null) || (x!= null && x.equals(y));\n        return x == y || (x!= null && x.equals(y));\n    }\n\n    public static boolean equalsIgnoreCase(String x, String y",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean notEquals(double x, double y)",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n}\n<|java|>/*\n * Copyright (c",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n// buggy line:    return (x == null && y == null) || (x!= null && x.equals(y));\n        return x == y || (x!= null && x.equals(y));\n    }\n\n    public static boolean equals(Object x, Object y, Comparator",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n}\n<|java|>/*\n * Licensed to the",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n// buggy line:    return (x == null && y == null) || (x!= null && x.equals(y));\n        return x == y || (x!= null && x.equals(y));\n    }\n}\n<|java|>/*\n * Copyright (c",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n\n    public static boolean equals(Object x, Object y, Comparator",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n// buggy line:    return (x == null && y == null) || (x!= null && x.equals(y));\n        return x == y || (x!= null && x.equals(y));\n    }\n}\n<|java|>/*\n * Licensed to the",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n}\n<|java|>/*\n * Copyright (C",
        "public static boolean equals(double x, double y) {\n// buggy line:    return (Double.isNaN(x) && Double.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(float x, float y) {\n// buggy line:    return (Float.isNaN(x) && Float.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(long x, long y) {\n// buggy line:    return (Long.isNaN(x) && Long.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(int x, int y) {\n// buggy line:    return (Integer.isNaN(x) && Integer.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(short x, short y) {\n// buggy line:    return (Short.isNaN(x) && Short.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(char x, char y) {\n// buggy line:    return (Character.isNaN(x) && Character.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(byte x, byte y) {\n// buggy line:    return (Byte.isNaN(x) && Byte.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(boolean x, boolean y) {\n// buggy line:    return (Boolean.isNaN(x) && Boolean.isNaN(y)) || x == y;\n        return x == y;\n    }\n\n    public static boolean equals(Object x, Object y) {\n        if (x == y) {\n            return true;\n        }\n        if (x == null || y == null) {\n            return false;\n        }\n        return x.equals(y);\n    }\n}\n<|java|>/**\n * Copyright (c"
      ],
      "function range": "416,5-418,5"
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));",
      "output": [
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = correlationMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createReal",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return new BlockRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return new BlockRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return new BlockRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            double r = covarianceMatrix.getEntry(i, j);",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                out[i][j] = covarianceMatrix.getEntry(i, j);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++)",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                out[i][j] = covarianceMatrix.getEntry(i, j);\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCorrelationMatrix() throws MathException {\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            double r = covarianceMatrix.get",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            double cov = covarianceMatrix.get",
        "public RealMatrix getCorrelationPValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = correlationMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            if (i == j) {\n                out[i][j] = 0d;\n            } else {\n                double r = correlationMatrix.getEntry(i, j);\n                double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r)));\n// buggy line:                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t));\n                out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t / Math.sqrt(nObs - 2)));\n            }\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovarianceMatrix() throws MathException {\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = covarianceMatrix.getEntry(i, j);\n        }\n    }\n    return MatrixUtils.createRealMatrix(out);\n  }\n\n  public RealMatrix getCovariancePValues() throws MathException {\n    TDistribution tDistribution = new TDistributionImpl(nObs - 2);\n    int nVars = covarianceMatrix.getColumnDimension();\n    double[][] out = new double[nVars][nVars];\n    for (int i = 0; i < nVars; i++) {\n        for (int j = 0; j < nVars; j++) {\n            out[i][j] = 2"
      ],
      "function range": "160,5-176,5"
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);",
      "output": [
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionE",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws FunctionE",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     *  or the solver",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     *  or the solver",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     *   or the solver",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     *   or the solver",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws IllegalArg",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n// buggy line:    return solve(min, max);\n        return solve(f, min, max, initial);\n    }\n\n    /**\n     * Find a real root in the given interval with initial value.\n     * <p>\n     * Requires bracketing condition.</p>\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @param initial the start value to use\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * or the solver detects convergence problems otherwise\n     * @throws FunctionEvaluationException if an error occurs evaluating the\n     * function\n     * @throws IllegalArgumentException if any parameters are invalid\n     */\n    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // check for zeros before verifying bracketing\n        if (f.value(min) == 0.0) { return min; }\n        if (f.value(max) == 0.0) { return max; }\n        if (f.value(initial) == 0.0) { return initial; }\n\n        verifyBracketing(min, max);\n        verifySequence(min, initial, max);\n        if (isBracketing(min, initial, max)) {\n            return solve(f, min, initial);\n        } else {\n            return solve(f, initial, max);\n        }\n    }\n\n    /**\n     * Find a real root in the given interval.\n     *\n     * @param f the function to solve\n     * @param min the lower bound for the interval\n     * @param max the upper bound for the interval\n     * @return the point at which the function value is zero\n     * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n     * @throws IllegalArg"
      ],
      "function range": "70,5-73,5"
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }",
      "output": [
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double min",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   * @throws IllegalArgumentException if any parameters are invalid.\n   */\n  ",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param yMin the value of the function at the lower bound\n   * @param max the upper bound for the interval\n   * @param yMax the value of the function at the upper bound\n   * @param initial the start value to use\n   * @param yInitial the value of the function at the start value\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   * @throws IllegalArgumentException if any parameters are invalid\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param max the upper bound for the interval.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @param minY the value of the function at <code>min</code>.\n   * @param maxY the value of the function at <code>max</code>.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                      final double min",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, max, yMax, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param max the upper bound for the interval.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @param minY the value of the function at <code>min</code>.\n   * @param maxY the value of the function at <code>max</code>.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   * @throws IllegalArgumentException if any parameters are invalid",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve.\n   * @param min the lower bound for the interval.\n   * @param yMin the value of the function at the lower bound.\n   * @param max the upper bound for the interval.\n   * @param yMax the value of the function at the upper bound.\n   * @param initial the start value to use.\n   * @param yInitial the value of the function at the start value.\n   * @return the point at which the function value is zero.\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise.\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function.\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double",
        "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    verifySequence(min, initial, max);\n    double yInitial = f.value(initial);\n    if (Math.abs(yInitial) <= functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n    double yMin = f.value(min);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(yMin, 0);\n        return result;\n    }\n    if (yInitial * yMin < 0) {\n        return solve(f, min, yMin, initial, yInitial, min, yMin);\n    }\n    double yMax = f.value(max);\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(yMax, 0);\n        return result;\n    }\n    if (yInitial * yMax < 0) {\n        return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n    }\n    return solve(f, initial, yInitial, min, yMin, max, yMax);\n  }\n\n  /**\n   * Find a real root in the given interval.\n   *\n   * @param f the function to solve\n   * @param min the lower bound for the interval\n   * @param max the upper bound for the interval\n   * @param initial the start value to use\n   * @param y0 the value of the function at the start value\n   * @param yMin the value of the function at the lower bound\n   * @param yMax the value of the function at the upper bound\n   * @return the point at which the function value is zero\n   * @throws MaxIterationsExceededException if the maximum iteration count is exceeded\n   * or the solver detects convergence problems otherwise\n   * @throws FunctionEvaluationException if an error occurs evaluating the\n   * function\n   */\n  private double solve(final UnivariateRealFunction f,\n                       final double min, final double y0, final double max"
      ],
      "function range": "98,5-140,5"
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);",
      "output": [
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyr",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;\nimport org.apache.h",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;",
        "@Deprecated\npublic double getPct(Object v) {\n// buggy line:    return getCumPct((Comparable<?>) v);\n    return getCumPct((Comparable<?>) v);\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.express"
      ],
      "function range": "301,5-304,5"
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;",
      "output": [
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.oper",
        "private boolean flipIfWarranted(final int n, final int step) {\n    if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) {\n// buggy line:        int j = 4 * n - 1;\n        int j = 4 * (n - 1) + pingPong;\n        int tmp = work[pingPong];\n        work[pingPong] = work[j];\n        work[j] = tmp;\n        pingPong = 1 - pingPong;\n        return true;\n    }\n    return false;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.serde2.io.HiveDecimalWritable;\nimport org.apache"
      ],
      "function range": "1132,5-1147,5"
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {",
      "output": [
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  protected List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  protected List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numCols = tableau.getNumCols();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numCols; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i)!= 0) {\n            list",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numCols = tableau.getNumCols();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numCols; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i)!= 0) {\n            list",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  protected List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numCols = tableau.getNumCols();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numCols; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i)!= 0) {\n            list",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        if (tableau.getEntry(i, tableau.getWidth() - 1)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < tableau.getNumObjectiveFunctions(); i++) {\n        if (tableau.getEntry(i, tableau.getWidth() - 1)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  ",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions() - 1)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < tableau.getNumObjectiveFunctions(); i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions() - 1, i)!= 0) {\n            list.add(i);\n        }\n    ",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numColumns = tableau.getNumColumns();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numColumns; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i)!= 0) {\n            list",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        if (tableau.getEntry(i, tableau.getWidth() - 1)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of fixed columns.\n   */\n  public List<Integer> getFixedColumns(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < tableau.getWidth() - 1; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  protected List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  protected List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numCols = tableau.getNumCols();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < numCols; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions(), i",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        if (tableau.getEntry(i, tableau.getWidth() - 1)!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getWidth(); i++) {\n        if (tableau.getEntry(tableau.getHeight() - 1, i)!= 0) {\n            list.add(i);\n        }\n    }\n    return",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) {\n    double minRatio = Double.MAX_VALUE;\n    Integer minRatioPos = null;\n    for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) {\n        final double rhs = tableau.getEntry(i, tableau.getWidth() - 1);\n        final double entry = tableau.getEntry(i, col);\n// buggy line:        if (MathUtils.compareTo(entry, 0, epsilon) >= 0) {\n        if (Precision.compareTo(entry, 0, epsilon) >= 0) {\n            final double ratio = FastMath.abs(rhs / entry);\n            if (ratio < minRatio) {\n                minRatio = ratio;\n                minRatioPos = i;\n            }\n        }\n    }\n    return minRatioPos;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot columns.\n   */\n  public List<Integer> getPivotColumns(final SimplexTableau tableau) {\n    final int numRows = tableau.getNumRows();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numRows; i++) {\n        if (tableau.getEntry(i, tableau.getNumObjectiveFunctions())!= 0) {\n            list.add(i);\n        }\n    }\n    return list;\n  }\n\n  /**\n   * @param tableau Simple tableau for which to get basis.\n   * @return List of pivot rows.\n   */\n  public List<Integer> getPivotRows(final SimplexTableau tableau) {\n    final int numCols = tableau.getNumCols();\n    final List<Integer> list = new ArrayList<Integer>();\n    for (int i = 0; i < numCols; i++) {\n        if (tableau.getEntry(tableau.getNumObjectiveFunctions() + i, tableau.getNumR"
      ],
      "function range": "76,5-91,5"
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {",
      "output": [
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations < maximumIterations) {\n        return new double[] {a, b};\n    } else {\n        throw MathRuntimeException.createConvergenceException(\n              \"maximum number of iterations exceeded: {0}\", maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations < maximumIterations) {\n        return new double[] {a, b};\n    } else {\n        throw MathRuntimeException.createConvergenceException(\n              \"maximum number of iterations exceeded: {0}\", maximumIterations);\n    }\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE file",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more contributor license\n * agreements. See the NOTICE file",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n}\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements. See the NOTICE file",
        "public static double[] bracket(UnivariateRealFunction function,\n        double initial, double lowerBound, double upperBound, \n        int maximumIterations) throws ConvergenceException, \n        FunctionEvaluationException {\n    if (function == null) {\n        throw MathRuntimeException.createIllegalArgumentException(\"function is null\");\n    }\n    if (maximumIterations <= 0)  {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"bad value for maximum iterations number: {0}\", maximumIterations);\n    }\n    if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) {\n        throw MathRuntimeException.createIllegalArgumentException(\n              \"invalid bracketing parameters:  lower bound={0},  initial={1}, upper bound={2}\",\n              lowerBound, initial, upperBound);\n    }\n    double a = initial;\n    double b = initial;\n    double fa;\n    double fb;\n    int numIterations = 0 ;\n    do {\n        a = Math.max(a - 1.0, lowerBound);\n        b = Math.min(b + 1.0, upperBound);\n        fa = function.value(a);\n        fb = function.value(b);\n        numIterations++ ;\n    } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && \n            ((a > lowerBound) || (b < upperBound)));\n// buggy line:    if (fa * fb >= 0.0 ) {\n    if (fa * fb > 0.0) {\n        throw MathRuntimeException.createConvergenceException(\n              \"function values at a and b have different signs: {0} and {1}\",\n              a, b);\n    }\n    if (numIterations >= maximumIterations) {\n        throw MathRuntimeException.createConvergenceException(\n              \"no bracketing point found in {0} iterations\",\n              maximumIterations);\n    }\n    return new double[] {a, b};\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements. See the NOTICE"
      ],
      "function range": "165,5-208,5"
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();",
      "output": [
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>short</code> value.</p>\n     *\n     * @return the fraction as a <code>short</code> value\n     */\n    public short shortValue() {\n        return (short) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>byte</code> value.</p>\n     *\n     * @return the fraction as",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>short</code> value.</p>\n     *\n     * @return the fraction as a <code>short</code> value\n     */\n    public short shortValue() {\n        return (short) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>byte</code> value.</p>\n     *\n     * @return the fraction as",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>byte</code> value.</p>\n     *\n     * @return the fraction as a <code>byte</code> value\n     */\n    public byte byteValue() {\n        return (byte) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>short</code> value.</p>\n     *\n     * @return the fraction as",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>\n     *\n     * <p>Any negative signs are resolved to be on the numerator.</p>\n     *\n     * @param numerator  the numerator, for example the three in 'three sevenths'\n     * @param denominator  the denominator, for example the seven in 'three sevenths",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>short</code> value.</p>\n     *\n     * @return the fraction as a <code>short</code> value\n     */\n    public short shortValue() {\n        return (short) doubleValue();\n    }\n\n    /**\n     * <p>Converts the fraction to a <code>String</code>.</p>\n     *\n     * <p>The format used",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>BigInteger</code> value.</p>\n     *\n     * @return the fraction as a <code>BigInteger</code> value\n     */\n    public BigInteger bigIntegerValue() {\n        return numerator.bigIntegerValue().divide(denominator.bigIntegerValue());\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>BigDecimal",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>short</code> value.</p>\n     *\n     * @return the fraction as a <code>short</code> value\n     */\n    public short shortValue() {\n        return (short) doubleValue();\n    }\n\n    /**\n     * <p>Creates a <code>Fraction</code> instance with the 2 parts\n     * of a fraction Y/Z.</p>",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Converts the fraction to a <code>String</code>.</p>\n     *\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    public String toString() {\n        if (numerator.equals(BigInteger.",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Converts the fraction to a <code>String</code>.</p>\n     *\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    public String toString() {\n        if (toString == null) {\n            toString",
        "public int compareTo(Fraction object) {\n// buggy line:    double nOd = doubleValue();\n// buggy line:    double dOn = object.doubleValue();\n// buggy line:    return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n        double nOd = doubleValue();\n        double dOn = object.doubleValue();\n        return (nOd < dOn)? -1 : ((nOd == dOn)? 0 : 1);\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>double</code> value.</p>\n     *\n     * @return the fraction as a <code>double</code> value\n     */\n    public double doubleValue() {\n        return numerator.doubleValue() / denominator.doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>float</code> value.</p>\n     *\n     * @return the fraction as a <code>float</code> value\n     */\n    public float floatValue() {\n        return (float) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as an <code>int</code> value.</p>\n     *\n     * @return the fraction as an <code>int</code> value\n     */\n    public int intValue() {\n        return (int) doubleValue();\n    }\n\n    /**\n     * <p>Gets the fraction as a <code>long</code> value.</p>\n     *\n     * @return the fraction as a <code>long</code> value\n     */\n    public long longValue() {\n        return (long) doubleValue();\n    }\n\n    /**\n     * <p>Converts the fraction to a <code>String</code>.</p>\n     *\n     * <p>The format used is '<i>numerator</i>/<i>denominator</i>' always.\n     *\n     * @return a <code>String</code> form of the fraction\n     */\n    @Override\n    public String toString() {\n        if (numerator.equals"
      ],
      "function range": "258,5-262,5"
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {",
      "output": [
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        ",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n//",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n//",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        return -v;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        return",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:\n// buggy line:    if (v < 0) {\n",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n//",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n//",
        "public static int gcd(int u, int v) {\n// buggy line:    if (u * v == 0) {\n// buggy line:        return 0;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u == 0) {\n// buggy line:        return v;\n// buggy line:    }\n// buggy line:    if (v == 0) {\n// buggy line:        return u;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    if (v < 0) {\n// buggy line:        v = -v;\n// buggy line:    }\n// buggy line:    if (u < 0) {\n// buggy line:        u = -u;\n// buggy line:    }\n// buggy line:    return v;\n// buggy line:}"
      ],
      "function range": "411,5-460,5"
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); ",
      "output": [
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  public boolean is",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  public String to",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  public static Complex",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  public double get",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n}\n<",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public String toString() {\n    return \"(\" + real + \" + \" + imaginary + \"i)\";\n  }\n}\n<|java|>",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  @Override\n",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n  \n  public",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public Complex add(Complex other) {\n    return new Complex(real + other.real, imaginary + other.imaginary);\n  }\n\n  public Complex subtract",
        "public boolean equals(Object other) {\n    boolean ret;\n    if (this == other) { \n        ret = true;\n    } else if (other == null) {\n        ret = false;\n    } else  {\n        try {\n            Complex rhs = (Complex)other;\n            if (rhs.isNaN()) {\n                ret = this.isNaN();\n            } else {\n// buggy line:                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n                ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); \n            }\n        } catch (ClassCastException e) {\n            ret = false;\n        }\n    }\n    return ret;\n  }\n\n  public int hashCode() {\n    int result = 17;\n    long temp = Double.doubleToRawLongBits(real);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    temp = Double.doubleToRawLongBits(imaginary);\n    result = 37 * result + (int)(temp ^ (temp >>> 32));\n    return result;\n  }\n\n  public double getReal() {\n    return real;\n  }\n\n  public double getImaginary() {\n    return imaginary;\n  }\n\n  public void setReal(double real) {\n    this.real = real;\n  }\n\n  public void setImaginary(double imaginary) {\n    this.imaginary = imaginary;\n  }\n\n  public boolean isNaN() {\n    return Double.isNaN(real) || Double.isNaN(imaginary);\n  }\n\n  public boolean isInfinite() {\n    return Double.isInfinite(real) || Double.isInfinite(imaginary);\n  }\n\n  public Complex add"
      ],
      "function range": "245,5-267,5"
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (",
      "output": [
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from a string to produce a <code>Number</code>.\n   * <p>\n   * The method attempts to parse text starting at the index given by\n   * <code>pos</code>.\n   * <p>\n   * If parsing succeeds, then the index of <code>pos</code> is updated\n   * to the index after the last character used (parsing does not necessarily\n",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    } else {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n  }\n\n  /**\n   * Parses text from a string to produce a <code>Number</code>.\n   * <p>\n   * The method attempts to parse text starting at the index given by\n   * <code>pos</code>.\n   * <p>\n   * If parsing succeeds, then the index of <code>pos</code> is updated\n   * to the index after the last character used (parsing",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    } else {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n    } else {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on usage of this method.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   *",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on message parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @return",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    }\n    pos.setIndex(initialIndex);\n    pos.setErrorIndex(startIndex);\n    return null;\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on number parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed.\n   * @param",
        "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    parseAndIgnoreWhitespace(source, pos);\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n    parseAndIgnoreWhitespace(source, pos);\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        pos.setIndex(initialIndex);\n        return null;\n    }\n    int n = getImaginaryCharacter().length();\n    startIndex = pos.getIndex();\n    int endIndex = startIndex + n;\n// buggy line:    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n    if (source.substring(startIndex, endIndex).equals(getImaginaryCharacter())) {\n        pos.setIndex(endIndex);\n        return new Complex(re.doubleValue(), sign * im.doubleValue());\n    } else {\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n  }\n\n  /**\n   * Parses text from the beginning of the given string to produce a number.\n   * The method may not use the entire text of the given string.\n   * <p>\n   * See the {@link #parse(String, ParsePosition)} method for more information\n   * on message parsing.\n   *\n   * @param source A <code>String</code> whose beginning should be parsed."
      ],
      "function range": "320,5-389,5"
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;",
      "output": [
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumSquaredErrors() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquares() {\n        return sumYYAdj - sumXYAdj * sumXYAd",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquares() {\n        return sumYY - sumXY * sumXY / sumXX;",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumOfSquares() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXY",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumSquaredErrors() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAd",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getResidualSumOfSquares() {\n        return getSumSquaredErrors() - getSumXY() * getSumXY() / getSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquares() {\n        return getAdjustedSumSquaredErrors() - getAdjustedSumXY() * getAdjustedSumXY() / getAdjustedSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquaresAdj() {\n        return getAdjustedSumSquaredErrorsAdj() - getAdjustedSumXYAdj() * getAdjustedSumXYAdj() / getAdjustedSumXXAdj();\n    }\n\n    public double getCorrelation() {\n        return getSumXY() / Math.sqrt(getSumXX() * getSumYY());\n    }\n\n    public double getAdjustedCorrelation() {\n        return getAdjustedSumXY() / Math.sqrt(getAdjustedSumXX() * getAdjustedSumYY());\n    }\n\n    public double getAdjustedCorrelationAdj() {\n        return getAdjustedSumXYAdj() / Math.sqrt(getAdjustedSumXXAdj() * getAdjustedSumYYAdj());\n    }\n\n    public double getCoefficientOfDetermination() {\n        return 1 - getResidualSumOfSquares() / getSumSquaredErrors();\n    }\n\n    public double getAdjustedCoefficientOfDetermination() {\n        return 1 - getAdjustedResidualSumOfSquares()",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquares() {\n        return sumYYAdj - sumXYAdj * sumXY",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumSquaredErrors() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquares() {\n        return sumYY - sumXY * sumXY / sumXX;\n    }",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getResidualSumOfSquares() {\n        return getSumSquaredErrors() - getSumXY() * getSumXY() / getSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquares() {\n        return getAdjustedSumSquaredErrors() - getAdjustedSumXY() * getAdjustedSumXY() / getAdjustedSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquaresAdj() {\n        return getAdjustedSumSquaredErrorsAdj() - getAdjustedSumXYAdj() * getAdjustedSumXYAdj() / getAdjustedSumXXAdj();\n    }\n\n    public double getCorrelation() {\n        return getSumXY() / Math.sqrt(getSumXX() * getSumYY());\n    }\n\n    public double getAdjustedCorrelation() {\n        return getAdjustedSumXY() / Math.sqrt(getAdjustedSumXX() * getAdjustedSumYY());\n    }\n\n    public double getAdjustedCorrelationAdj() {\n        return getAdjustedSumXYAdj() / Math.sqrt(getAdjustedSumXXAdj() * getAdjustedSumYYAdj());\n    }\n\n    public double getCoefficientOfDetermination() {\n        return 1 - getResidualSumOfSquares() / getAdjustedResidualSumOfSquares();\n    }\n\n    public double getAdjustedCoefficientOfDetermination() {\n        return 1 - getAdjustedResidualSum",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquaredErrorsAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumOfSquaresAdj() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getRSquaredAdj() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getSumSquaredErrorsAdj() / getSumOfSquaresAdj();\n    }\n\n    public double getAdjustedSumOfSquares() {\n        return sumYYAdj - sumXYAdj * sumXYAdj / sumXXAdj;\n    }\n\n    public double getAdjustedSumSquares() {\n        return sumYYAdj - sumXYAdj * sumXYAdj /",
        "public double getSumSquaredErrors() {\n// buggy line:    return sumYY - sumXY * sumXY / sumXX;\n        return sumYY - sumXY * sumXY / sumXX;\n    }\n\n    public double getRSquared() {\n        return 1 - getSumSquaredErrors() / getSumOfSquares();\n    }\n\n    public double getAdjustedRSquared() {\n        return 1 - getAdjustedSumSquaredErrors() / getAdjustedSumOfSquares();\n    }\n\n    public double getAdjustedRSquaredAdj() {\n        return 1 - getAdjustedSumSquaredErrorsAdj() / getAdjustedSumOfSquaresAdj();\n    }\n\n    public double getResidualSumOfSquares() {\n        return getSumSquaredErrors() - getSumXY() * getSumXY() / getSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquares() {\n        return getAdjustedSumSquaredErrors() - getAdjustedSumXY() * getAdjustedSumXY() / getAdjustedSumXX();\n    }\n\n    public double getAdjustedResidualSumOfSquaresAdj() {\n        return getAdjustedSumSquaredErrorsAdj() - getAdjustedSumXYAdj() * getAdjustedSumXYAdj() / getAdjustedSumXXAdj();\n    }\n\n    public double getCorrelation() {\n        return getSumXY() / Math.sqrt(getSumXX() * getSumYY());\n    }\n\n    public double getAdjustedCorrelation() {\n        return getAdjustedSumXY() / Math.sqrt(getAdjustedSumXX() * getAdjustedSumYY());\n    }\n\n    public double getAdjustedCorrelationAdj() {\n        return getAdjustedSumXYAdj() / Math.sqrt(getAdjustedSumXXAdj() * getAdjustedSumYYAdj());\n    }\n\n    public double getCoefficientOfDetermination() {\n        return getRSquared() * getAdjustedRSquared();\n    }\n\n    public double getAdjustedCoefficientOfDetermination() {\n        return getAdjustedRSquaredAdj() * getAdjustedAdjustedRSquared();"
      ],
      "function range": "263,5-265,5"
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();",
      "output": [
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptim",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.h",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOpt",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache",
        "public void captureArgumentsFrom(Invocation invocation) {\n    if (invocation.getMethod().isVarArgs()) {\n        int indexOfVararg = invocation.getRawArguments().length - 1;\n// buggy line:        throw new UnsupportedOperationException();\n        for (int i = indexOfVararg; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    } else {\n        for (int i = 0; i < invocation.getRawArguments().length; i++) {\n            invocation.addArgument(invocation.getRawArguments()[i]);\n        }\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogical"
      ],
      "function range": "120,5-150,5"
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {",
      "output": [
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.NoMockFound e) {",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.Wanted",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInv",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.ArgumentsAreDifferent e) {",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.UnfinishedVerificationException e)",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.NoMockingProgress e) {",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.NoMockClassesFound e",
        "public void verify(VerificationData data) {\n    AssertionError error = null;\n    timer.start();\n    while (timer.isCounting()) {\n        try {\n            delegate.verify(data);\n            if (returnOnSuccess) {\n                return;\n            } else {\n                error = null;\n            }\n        } catch (MockitoAssertionError e) {\n            error = handleVerifyException(e);\n        }\n// buggy line:        catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.WantedButNotInvoked e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooLittleActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.TooManyActualInvocations e) {\n// buggy line:        \terror = handleVerifyException(e);\n// buggy line:        } catch (org.mockito.exceptions.verification.junit.NoMockFound"
      ],
      "function range": "75,5-99,5"
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));",
      "output": [
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    registerTypeVariable(typeVariable, typeVariable.getBounds());\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable, Type[] types) {\n    for (Type type : types) {\n      registerTypeVariable(typeVariable, type);\n    }\n  }\n\n  private void registerTypeVariable",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    registerTypeVariable(typeVariable, typeVariable.getBounds());\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable, Type[] types) {\n    for (Type type : types) {\n      registerTypeVariableOn(typeVariable, type);\n    }\n  }\n\n  private void registerType",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    registerTypeVariable(typeVariable, typeVariable.getBounds());\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable, Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariable(",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    registerTypeVariable(typeVariable, typeVariable.getBounds());\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable, Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariables",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    registerTypeVariable(clazz, typeVariable",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    if (clazz == null) {\n",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    if (clazz.equals(Object",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    if (clazz.getTypeParameters().",
        "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n// buggy line:    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n    registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n  }\n\n  private void registerTypeVariablesOn(Type type) {\n    if (type instanceof TypeVariable) {\n      registerTypeVariable((TypeVariable) type);\n    } else if (type instanceof ParameterizedType) {\n      registerTypeVariablesOn((ParameterizedType) type);\n    } else if (type instanceof GenericArrayType) {\n      registerTypeVariablesOn((GenericArrayType) type);\n    } else if (type instanceof WildcardType) {\n      registerTypeVariablesOn((WildcardType) type);\n    }\n  }\n\n  private void registerTypeVariablesOn(ParameterizedType type) {\n    registerTypeVariablesOn(type.getOwnerType());\n    registerTypeVariablesOn(type.getRawType());\n  }\n\n  private void registerTypeVariablesOn(GenericArrayType type) {\n    registerTypeVariablesOn(type.getGenericComponentType());\n  }\n\n  private void registerTypeVariablesOn(WildcardType type) {\n    registerTypeVariablesOn(type.getUpperBounds());\n    registerTypeVariablesOn(type.getLowerBounds());\n  }\n\n  private void registerTypeVariablesOn(Type[] types) {\n    for (Type type : types) {\n      registerTypeVariablesOn(type);\n    }\n  }\n\n  private void registerTypeVariablesOn(TypeVariable[] typeVariables) {\n    for (TypeVariable typeVariable : typeVariables) {\n      registerTypeVariable(typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(TypeVariable typeVariable) {\n    if (typeVariable.getGenericDeclaration() instanceof Class) {\n      registerTypeVariable((Class) typeVariable.getGenericDeclaration(), typeVariable);\n    }\n  }\n\n  private void registerTypeVariable(Class clazz, TypeVariable typeVariable) {\n    if (clazz.equals(type"
      ],
      "function range": "375,9-380,9"
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {",
      "output": [
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    Type[] lowerBounds = wildcardType.getLowerBounds();\n    Type[] bounds = new Type[upperBounds.length + lowerBounds.length];\n    System.arraycopy(upperBounds, 0, bounds, 0, upperBounds.length);\n    System.arraycopy(lowerBounds, 0, bounds, upperBounds.length, lowerBounds.length);\n    return bounds;\n  }\n\n  private static Type[] boundsOf(",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    Type[] upperBounds = wildcardType.getUpperBounds();\n    Type[] lowerBounds = wildcardType.getLowerBounds();\n    Type[] bounds = new Type[upperBounds.length + lowerBounds.length];\n    System.arraycopy(upperBounds, 0, bounds, 0, upperBounds.length);\n    System.arraycopy(lowerBounds, 0, bounds, upperBounds.length, lowerBounds.length);\n    return bounds;\n  }\n\n  private static Type[] boundsOf(",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[]",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[]",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable<?> typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable<?> typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] bounds",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Class<?",
        "protected void registerTypeVariablesOn(Type classType) {\n    if (!(classType instanceof ParameterizedType)) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType) classType;\n    TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n    Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n    for (int i = 0; i < actualTypeArguments.length; i++) {\n        TypeVariable typeParameter = typeParameters[i];\n        Type actualTypeArgument = actualTypeArguments[i];\n        if (actualTypeArgument instanceof WildcardType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n// buggy line:        } else {\n        } else if (actualTypeArgument instanceof GenericArrayType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((GenericArrayType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof TypeVariable) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument));\n        } else if (actualTypeArgument instanceof ParameterizedType) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((ParameterizedType) actualTypeArgument));\n        } else if (actualTypeArgument instanceof Class) {\n            contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument));\n        }\n    }\n  }\n\n  private static Type[] boundsOf(WildcardType wildcardType) {\n    return wildcardType.getUpperBounds();\n  }\n\n  private static Type[] boundsOf(GenericArrayType genericArrayType) {\n    return genericArrayType.getGenericComponentType().getClass().getTypeParameters();\n  }\n\n  private static Type[] boundsOf(TypeVariable typeVariable) {\n    return typeVariable.getBounds();\n  }\n\n  private static Type[] boundsOf(ParameterizedType parameterizedType) {\n    return parameterizedType.getActualTypeArguments();\n  }\n\n  private static Class<?"
      ],
      "function range": "66,5-84,5"
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {",
      "output": [
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelOnPrepareTest extends ContextTestSupport {\n\n",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelTest extends ContextTestSupport {\n\n    @Test",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertSame",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class RecipientListTest extends ContextTestSupport {\n\n    @Test",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class MulticastTest extends ContextTestSupport {\n\n    @Test",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\npublic class DeadLetterChannelTest extends ContextTestSupport {\n\n    private static",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.fail;",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTh",
        "public static boolean areEqual(Object o1, Object o2) {\n// buggy line:    if (o1 == null || o2 == null) {\n        if (o1 == null) {\n            if (o2 == null) {\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            if (o2 == null) {\n                return false;\n            } else {\n                return o1.equals(o2);\n            }\n        }\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one or more\n * contributor license agreements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.processor;\n\nimport org.apache.camel.ContextTestSupport;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.Processor;\nimport org.apache.camel.builder.RouteBuilder;\nimport org.apache.camel.component.mock.MockEndpoint;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.junit.jupiter.api.Assertions.assertNotNull;\nimport static org.junit.jupiter.api.Assertions.assertNull;\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\n/**\n * Unit test to verify that redelivery counters is working as"
      ],
      "function range": "12,5-20,5"
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;",
      "output": [
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod()))",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.toString();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return 0;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return false;\n        } else {\n            return name.toString().equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.toString().hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod())) {\n        Object mock = invocation.",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return 0;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return false;\n        } else {\n            return name.toString().equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return false;\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return 0;\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        Mock",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return invocation.proceed();\n    }\n  }\n}\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return 0;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return false;\n        } else {\n            return name.toString().equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.toString().hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isAnswerMethod(invocation.getMethod())) {\n        return invocation.getM",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    }\n    return null;\n  }\n}\n<|java|>/*\n",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    }\n    return null;\n  }\n}\n<|java|>package com",
        "public Object answer(InvocationOnMock invocation) {\n    if (methodsGuru.isToString(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) {\n// buggy line:        return 1;\n        return -1;\n    } else if (methodsGuru.isEqualsMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.equals(invocation.getArguments()[0]);\n        } else {\n            return name.equals(invocation.getArguments()[0]);\n        }\n    } else if (methodsGuru.isHashCodeMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return mock.hashCode();\n        } else {\n            return name.hashCode();\n        }\n    } else if (methodsGuru.isToStringMethod(invocation.getMethod())) {\n        Object mock = invocation.getMock();\n        MockName name = mockUtil.getMockName(mock);\n        if (name.isDefault()) {\n            return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode();\n        } else {\n            return name.toString();\n        }\n    } else {\n        return invocation.proceed();\n    }\n  }\n\n  @"
      ],
      "function range": "63,5-81,5"
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));",
      "output": [
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mock",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.M",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS).defaultBehavior(org.mockito.Mockito.CALLS_REAL_METHODS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS).defaultBehavior(org.mockito.Mockito.CALLS_REAL_METHODS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS).defaultBehavior(org.mockito.Mockito.CALLS_REAL_METHODS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.resetMock(mock",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n  }\n}\n<|",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n\n",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl<T>().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n  }\n\n  public <T>",
        "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n// buggy line:    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n// buggy line:    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.mockingDetails(mock).setMockCreationSettings(new MockSettingsImpl().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    org.mockito.Mockito.mockingDetails(mock).setMockHandler(newMockHandler);\n    org.mockito.Mockito.resetMockingDetails(m"
      ],
      "function range": "62,5-67,5"
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();",
      "output": [
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vector",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogical",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDesc",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.Vector",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algeb",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport java.util.Arrays;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n// buggy line:        mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n      try {\n        field.set(fieldInstance, mocks.iterator().next());\n      } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n      }\n    }\n  }\n\n  private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<Field>();\n    while(clazz!= null) {\n      fields.addAll(Arrays.asList(clazz.getDeclaredFields()));\n      clazz = clazz.getSuperclass();\n    }\n    return fields;\n  }\n\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algeb"
      ],
      "function range": "91,5-95,5"
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());",
      "output": [
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Logical",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.Log",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.operators",
        "public void describeTo(Description description) {\n    description.appendText(\"same(\");\n    appendQuoting(description);\n// buggy line:    description.appendText(wanted.toString());\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\", \");\n    appendQuoting(description);\n    description.appendText(\")\");\n  }\n\n  private void appendQuoting(Description description) {\n    description.appendText(\"\\\"\");\n    description.appendText(wanted.toString());\n    description.appendText(\"\\\"\");\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.exec.vector.expressions;\n\nimport org.apache.hadoop.hive.ql.exec.vector.BytesColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.LongColumnVector;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorExpressionDescriptor;\nimport org.apache.hadoop.hive.ql.exec.vector.VectorizedRowBatch;\nimport org.apache.hadoop.hive.ql.metadata.HiveException;\nimport org.apache.hadoop.hive.ql.util.JavaDataModel;\nimport org.apache.hadoop.io"
      ],
      "function range": "26,5-32,5"
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {",
      "output": [
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyr",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport",
        "public void captureArgumentsFrom(Invocation i) {\n    int k = 0;\n    for (Matcher m : matchers) {\n// buggy line:        if (m instanceof CapturesArguments) {\n// buggy line:            ((CapturesArguments) m).captureArgumentsFrom(i, k);\n// buggy line:        }\n      if (m instanceof CapturesArguments) {\n        ((CapturesArguments) m).captureArgumentsFrom(i, k);\n      }\n      k++;\n    }\n  }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalExpression;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalExpressionTag;\nimport org.apache.hyr"
      ],
      "function range": "103,5-111,5"
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());",
      "output": [
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\n",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.commons.lang3.mutable.MutableObject;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractLogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.Abstract",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator;\nimport org.apache.hyr",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractBinaryJoinOperator;",
        "private boolean toStringEquals(Matcher m, Object arg) {\n// buggy line:    return StringDescription.toString(m).equals(arg.toString());\n        return m.toString().equals(arg.toString());\n    }\n}\n<|java|>/*\n * Licensed to the Apache Software Foundation (ASF) under one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.hyracks.algebricks.rewriter.rules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.mutable.Mutable;\n\nimport org.apache.hyracks.algebricks.common.exceptions.AlgebricksException;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalOperator;\nimport org.apache.hyracks.algebricks.core.algebra.base.ILogicalPlan;\nimport org.apache.hyracks.algebricks.core.algebra.base.IOptimizationContext;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalOperatorTag;\nimport org.apache.hyracks.algebricks.core.algebra.base.LogicalVariable;\nimport org.apache.hyracks.algebricks.core.algebra.operators.logical.AbstractUnnestMapOperator"
      ],
      "function range": "47,5-49,5"
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);",
      "output": [
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iTypes = newTypes;\n        iValues = new",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        return newPartial;\n    } else {\n        ",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        return newPartial;\n    }\n    if (",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(newTypes, newValues);\n        return newPartial;\n    } else {\n        int[] newValues =",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        return newPartial;\n    }\n    int[]",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology.withUTC(), newTypes, newValues);\n        return newPartial;\n    }\n",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(newTypes, newValues);\n        return newPartial;\n    }\n    int[] newValues = iValues",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        iChronology = newPartial.iChron",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        newPartial.iType = this.iType;",
        "public Partial with(DateTimeFieldType fieldType, int value) {\n    if (fieldType == null) {\n        throw new IllegalArgumentException(\"The field type must not be null\");\n    }\n    int index = indexOf(fieldType);\n    if (index == -1) {\n        DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n        int[] newValues = new int[newTypes.length];\n        int i = 0;\n        DurationField unitField = fieldType.getDurationType().getField(iChronology);\n        if (unitField.isSupported()) {\n            for (; i < iTypes.length; i++) {\n                DateTimeFieldType loopType = iTypes[i];\n                DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n                if (loopUnitField.isSupported()) {\n                    int compare = unitField.compareTo(loopUnitField);\n                    if (compare > 0) {\n                        break;\n                    } else if (compare == 0) {\n                        DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                        DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                        if (rangeField.compareTo(loopRangeField) > 0) {\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        System.arraycopy(iTypes, 0, newTypes, 0, i);\n        System.arraycopy(iValues, 0, newValues, 0, i);\n        newTypes[i] = fieldType;\n        newValues[i] = value;\n        System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n        System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n// buggy line:        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        Partial newPartial = new Partial(iChronology, newTypes, newValues);\n        return newPartial;\n    }\n    \n    "
      ],
      "function range": "426,5-474,5"
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;",
      "output": [
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * 2;\n        case 3:\n            return val1 * 3;\n        case 4:\n            return val1 * 4;\n        case 5:\n            return val1 * 5;\n        case 6:\n            return val1 * 6;\n        case 7:\n            return val1 * 7;\n        case 8:\n            return val1 * 8;\n        case 9:\n            return val1 * 9;\n        case 10:\n            return val1 * 10;\n        case 11:\n            return val1 * 11;\n        case 12:\n            return val1 * 12;\n        case 13:\n            return val1 * 13;\n        case 14:\n            return val1 * 14;\n        case 15:\n            return val1 * 15;\n        case 16:\n            return val1 * 16;\n        case 17:\n            return val1 * 17;\n        case 18:\n            return val1 * 18;\n        case 19:\n            return val1 * 19;\n        case 20:\n            return val1 * 20;\n        case 21:\n            return val1 * 21;\n        case 22:\n            return val1 * 22;\n        case 23:\n            return val1 * 23;\n        case 24:\n            return val1 * 24;\n        case 25:\n            return val1 * 25;\n        case 26:\n            return val1 * 26;\n        case 27:\n            return val1 * 27;\n        case 28:\n            return val1 * 28;\n        case 29:\n            return val1 * 29;\n        case 30:\n            return val1 * 30;\n        case 31:\n            return val1 * 31;\n        case 32:\n            return val1 * 32;\n        case 33:\n            return val1 * 33;\n        case 34:\n            return val1 * 34;\n        case 35:\n            return val1 * 35;\n        case 36:\n            ",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        case 36:\n            ",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n            return Long.MIN_VALUE;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 <<",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * val1;\n        case 3:\n            return val1 * val1 * val1;\n        case 4:\n            return val1 * val1 * val1 * val1;\n        case 5:\n            return val1 * val1 * val1 * val1 * val1;\n        case 6:\n            return val1 * val1 * val1 * val1 * val1 * val1;\n        case 7:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 8:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 9:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 10:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 11:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 12:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 13:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 14:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1;\n        case 15:\n            return val1 * val1 * val1 * val1 * val1 * val1 * val1 * val1 * val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            return",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * 2;\n        case 3:\n            return val1 * 3;\n        case 4:\n            return val1 * 4;\n        case 5:\n            return val1 * 5;\n        case 6:\n            return val1 * 6;\n        case 7:\n            return val1 * 7;\n        case 8:\n            return val1 * 8;\n        case 9:\n            return val1 * 9;\n        case 10:\n            return val1 * 10;\n        case 11:\n            return val1 * 11;\n        case 12:\n            return val1 * 12;\n        case 13:\n            return val1 * 13;\n        case 14:\n            return val1 * 14;\n        case 15:\n            return val1 * 15;\n        case 16:\n            return val1 * 16;\n        case 17:\n            return val1 * 17;\n        case 18:\n            return val1 * 18;\n        case 19:\n            return val1 * 19;\n        case 20:\n            return val1 * 20;\n        case 21:\n            return val1 * 21;\n        case 22:\n            return val1 * 22;\n        case 23:\n            return val1 * 23;\n        case 24:\n            return val1 * 24;\n        case 25:\n            return val1 * 25;\n        case 26:\n            return val1 * 26;\n        case 27:\n            return val1 * 27;\n        case 28:\n            return val1 * 28;\n        case 29:\n            return val1 * 29;\n        case 30:\n            return val1 * 30;\n        case 31:\n            return val1 * 31;\n        case 32:\n            return val1 * 32;\n        case 33:\n            return val1 * 33;\n        case 34:\n            return val1 * 34;\n        case 35:\n            return val1 * 35;\n        default:\n            return",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * 2;\n        case 3:\n            return val1 * 3;\n        case 4:\n            return val1 * 4;\n        case 5:\n            return val1 * 5;\n        case 6:\n            return val1 * 6;\n        case 7:\n            return val1 * 7;\n        case 8:\n            return val1 * 8;\n        case 9:\n            return val1 * 9;\n        case 10:\n            return val1 * 10;\n        case 11:\n            return val1 * 11;\n        case 12:\n            return val1 * 12;\n        case 13:\n            return val1 * 13;\n        case 14:\n            return val1 * 14;\n        case 15:\n            return val1 * 15;\n        case 16:\n            return val1 * 16;\n        case 17:\n            return val1 * 17;\n        case 18:\n            return val1 * 18;\n        case 19:\n            return val1 * 19;\n        case 20:\n            return val1 * 20;\n        case 21:\n            return val1 * 21;\n        case 22:\n            return val1 * 22;\n        case 23:\n            return val1 * 23;\n        case 24:\n            return val1 * 24;\n        case 25:\n            return val1 * 25;\n        case 26:\n            return val1 * 26;\n        case 27:\n            return val1 * 27;\n        case 28:\n            return val1 * 28;\n        case 29:\n            return val1 * 29;\n        case 30:\n            return val1 * 30;\n        case 31:\n            return val1 * 31;\n        case 32:\n            return val1 * 32;\n        case 33:\n            return val1 * 33;\n        case 34:\n            return val1 * 34;\n        case 35:\n            return val1 * 35;\n    }\n    return val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n    }\n    return val",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 * 2;\n        case 3:\n            return val1 * 3;\n        case 4:\n            return val1 * 4;\n        case 5:\n            return val1 * 5;\n        case 6:\n            return val1 * 6;\n        case 7:\n            return val1 * 7;\n        case 8:\n            return val1 * 8;\n        case 9:\n            return val1 * 9;\n        case 10:\n            return val1 * 10;\n        case 11:\n            return val1 * 11;\n        case 12:\n            return val1 * 12;\n        case 13:\n            return val1 * 13;\n        case 14:\n            return val1 * 14;\n        case 15:\n            return val1 * 15;\n        case 16:\n            return val1 * 16;\n        case 17:\n            return val1 * 17;\n        case 18:\n            return val1 * 18;\n        case 19:\n            return val1 * 19;\n        case 20:\n            return val1 * 20;\n        case 21:\n            return val1 * 21;\n        case 22:\n            return val1 * 22;\n        case 23:\n            return val1 * 23;\n        case 24:\n            return val1 * 24;\n        case 25:\n            return val1 * 25;\n        case 26:\n            return val1 * 26;\n        case 27:\n            return val1 * 27;\n        case 28:\n            return val1 * 28;\n        case 29:\n            return val1 * 29;\n        case 30:\n            return val1 * 30;\n        case 31:\n            return val1 * 31;\n        case 32:\n            return val1 * 32;\n        case 33:\n            return val1 * 33;\n        case 34:\n            return val1 * 34;\n        default:\n            return val1 * val2;\n    }\n}\n\n",
        "public static long safeMultiply(long val1, int val2) {\n    switch (val2) {\n        case -1:\n// buggy line:            return -val1;\n        case 0:\n            return 0;\n        case 1:\n            return val1;\n        case 2:\n            return val1 << 1;\n        case 3:\n            return val1 << 2;\n        case 4:\n            return val1 << 3;\n        case 5:\n            return val1 << 4;\n        case 6:\n            return val1 << 5;\n        case 7:\n            return val1 << 6;\n        case 8:\n            return val1 << 7;\n        case 9:\n            return val1 << 8;\n        case 10:\n            return val1 << 9;\n        case 11:\n            return val1 << 10;\n        case 12:\n            return val1 << 11;\n        case 13:\n            return val1 << 12;\n        case 14:\n            return val1 << 13;\n        case 15:\n            return val1 << 14;\n        case 16:\n            return val1 << 15;\n        case 17:\n            return val1 << 16;\n        case 18:\n            return val1 << 17;\n        case 19:\n            return val1 << 18;\n        case 20:\n            return val1 << 19;\n        case 21:\n            return val1 << 20;\n        case 22:\n            return val1 << 21;\n        case 23:\n            return val1 << 22;\n        case 24:\n            return val1 << 23;\n        case 25:\n            return val1 << 24;\n        case 26:\n            return val1 << 25;\n        case 27:\n            return val1 << 26;\n        case 28:\n            return val1 << 27;\n        case 29:\n            return val1 << 28;\n        case 30:\n            return val1 << 29;\n        case 31:\n            return val1 << 30;\n        case 32:\n            return val1 << 31;\n        case 33:\n            return val1 << 32;\n        case 34:\n            return val1 << 33;\n        case 35:\n            return val1 << 34;\n        default:\n            throw"
      ],
      "function range": "135,5-149,5"
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);",
      "output": [
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (period == null) {\n        throw new IllegalArgumentException(\"Period must not be null\");\n    }\n    long instantMillis = period.getMillis();\n    Chronology chrono = period.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    period.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    period.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        date.getMillis(), chrono, iLocale, iPivotYear, iDefaultYear);\n        date.getMillis(), chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    Chronology chrono = selectChronology(period.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  //-----------------------------------------------------------------------\n  ",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n}\n<|",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    Chronology chrono = selectChronology(date.getChronology());\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        date.getMillis(), chrono, iLocale, iPivotYear, iDefaultYear);\n        date.getMillis(), chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (period == null) {\n        throw",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  /**\n   * Select",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (period == null) {\n        throw new IllegalArgumentException(\"Period must not be null\");\n    }\n    long instantMillis = period.getMillis();\n    Chronology chrono = period.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    period.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    period.setChronology(chrono);\n    return newPos;\n  }\n\n  //-----------------------------------------------------------------------\n  ",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritableDateTime date, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (date == null) {\n        throw new IllegalArgumentException(\"DateTime must not be null\");\n    }\n    long instantMillis = date.getMillis();\n    Chronology chrono = date.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    date.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    date.setChronology(chrono);\n    return newPos;\n  }\n\n  private Chronology selectCh",
        "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    instant.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    instant.setChronology(chrono);\n    return newPos;\n  }\n\n  @Override\n  public int parseInto(ReadWritablePeriod period, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (period == null) {\n        throw new IllegalArgumentException(\"Period must not be null\");\n    }\n    long instantMillis = period.getMillis();\n    Chronology chrono = period.getChronology();\n    long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n    chrono = selectChronology(chrono);\n    DateTimeParserBucket bucket = new DateTimeParserBucket(\n// buggy line:        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n    int newPos = parser.parseInto(bucket, text, position);\n    period.setMillis(bucket.computeMillis(iDefaultYear, iPivotYear));\n    period.setChronology(chrono);\n    return newPos;\n  }\n\n  /**\n   * Select"
      ],
      "function range": "697,5-724,5"
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal != offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal != nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {",
      "output": [
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      index++;\n    }\n    return standardOffsets[index];\n  }\n\n  /**\n   * Gets the amount of daylight savings",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Returns the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return standardOffsets[0",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Returns the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n        return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n        // switch negative insert position to start of matched range\n        index = -index - 2;\n    } else {\n        return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Returns the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n        return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n        // switch negative insert position to start of matched range\n        index = -index - 2;\n    } else {\n        return standardOffsets[index + 1];\n    }\n    // inline for performance\n    if (index < savingsInstantTransitions.",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return ZoneOffset.UTC;",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    long offsetBefore = standardOffsets[index];\n    long epochSec",
        "public int getOffsetFromLocal(long instantLocal) {\n    final int offsetLocal = getOffset(instantLocal);\n    final long instantAdjusted = instantLocal - offsetLocal;\n    final int offsetAdjusted = getOffset(instantAdjusted);\n    if (offsetLocal!= offsetAdjusted) {\n        if ((offsetLocal - offsetAdjusted) < 0) {\n            long nextLocal = nextTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            if (nextLocal!= nextAdjusted) {\n                return offsetLocal;\n            }\n        }\n// buggy line:    } else if (offsetLocal > 0) {\n        } else if (offsetLocal > offsetAdjusted) {\n            long previousLocal = previousTransition(instantAdjusted);\n            long previousAdjusted = previousTransition(instantLocal - offsetAdjusted);\n            if (previousLocal!= previousAdjusted) {\n                return offsetLocal;\n            }\n        }\n    }\n    return offsetAdjusted;\n  }\n\n  /**\n   * Gets the standard offset for the specified instant in this zone.\n   * <p>\n   * This provides access to historic information on how the standard offset\n   * has changed over time.\n   * The standard offset is the offset before any daylight saving time is applied.\n   * This is typically the offset applicable during winter.\n   *\n   * @param instant  the instant to find the offset information for, not null, but null\n   *  may be ignored if the rules have a single offset for all instants\n   * @return the standard offset, not null\n   */\n  public ZoneOffset getStandardOffset(Instant instant) {\n    if (savingsInstantTransitions.length == 0) {\n      return standardOffsets[0];\n    }\n    long epochSec = instant.getEpochSecond();\n    int index  = Arrays.binarySearch(standardTransitions, epochSec);\n    if (index < 0) {\n      // switch negative insert position to start of matched range\n      index = -index - 2;\n    } else {\n      return standardOffsets[index + 1];\n    }\n    if (index == 0) {\n      return ZoneOffset.ofHours"
      ],
      "function range": "880,5-911,5"
    }
  }
}