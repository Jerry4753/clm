{
  "config": "PLBART_SEQFORM_COMMENTFORM_NOCOMMENT",
  "data": {
    "Chart_4_source/org/jfree/chart/plot/XYPlot.java_4493-4493": {
      "loc": "4493-4493",
      "input": "<s> public Range getDataRange(ValueAxis axis) { Range result = null; List mappedDatasets = new ArrayList(); List includedAnnotations = new ArrayList(); boolean isDomainAxis = true; int domainIndex = getDomainAxisIndex(axis); if (domainIndex >= 0) { isDomainAxis = true; mappedDatasets.addAll(getDatasetsMappedToDomainAxis( new Integer(domainIndex))); if (domainIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } int rangeIndex = getRangeAxisIndex(axis); if (rangeIndex >= 0) { isDomainAxis = false; mappedDatasets.addAll(getDatasetsMappedToRangeAxis( new Integer(rangeIndex))); if (rangeIndex == 0) { Iterator iterator = this.annotations.iterator(); while (iterator.hasNext()) { XYAnnotation annotation = (XYAnnotation) iterator.next(); if (annotation instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(annotation); } } } } Iterator iterator = mappedDatasets.iterator(); while (iterator.hasNext()) { XYDataset d = (XYDataset) iterator.next(); if (d != null) { XYItemRenderer r = getRendererForDataset(d); if (isDomainAxis) { if (r != null) { result = Range.combine(result, r.findDomainBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findDomainBounds(d)); } } else { if (r != null) { result = Range.combine(result, r.findRangeBounds(d)); } else { result = Range.combine(result, DatasetUtilities.findRangeBounds(d)); } } /* Collection c = r.getAnnotations(); */ <mask> Iterator i = c.iterator(); while (i.hasNext()) { XYAnnotation a = (XYAnnotation) i.next(); if (a instanceof XYAnnotationBoundsInfo) { includedAnnotations.add(a); } } } } Iterator it = includedAnnotations.iterator(); while (it.hasNext()) { XYAnnotationBoundsInfo xyabi = (XYAnnotationBoundsInfo) it.next(); if (xyabi.getIncludeInDataBounds()) { if (isDomainAxis) { result = Range.combine(result, xyabi.getXRange()); } else { result = Range.combine(result, xyabi.getYRange()); } } } return result; } </s> java",
      "function range": "4425,5-4519,5"
    },
    "Chart_14_source/org/jfree/chart/plot/CategoryPlot.java_2166-2167": {
      "loc": "2166-2167",
      "input": "<s> public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ <mask> if (removed && notify) { fireChangeEvent(); } return removed; } </s> java",
      "function range": "2155,5-2171,5",
      "output": [
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (removed) { fireChangeEvent(); } else if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (marker == null) { return false; } if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ markers.add(marker); if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ markers.remove(marker); if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (removed && notify) { fireChangeEvent(); } else if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (markers!= null) { markers.remove(marker); } if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (layer == Layer.FOREGROUND) { fireChangeEvent(); } if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (layer == Layer.FOREGROUND) { markers.remove(marker); } if (removed && notify) { fireChangeEvent(); } return removed; }",
        "public boolean removeDomainMarker(int index, Marker marker, Layer layer, boolean notify) { ArrayList markers; if (layer == Layer.FOREGROUND) { markers = (ArrayList) this.foregroundDomainMarkers.get(new Integer( index)); } else { markers = (ArrayList) this.backgroundDomainMarkers.get(new Integer( index)); } /* boolean removed = markers.remove(marker); */ if (layer == Layer.FOREGROUND) { markers.remove(marker); } else { markers.remove(marker); } if (removed && notify) { fireChangeEvent(); } return removed; }"
      ]
    },
    "Chart_26_source/org/jfree/chart/axis/Axis.java_1192-1193": {
      "loc": "1192-1193",
      "input": "<s> protected AxisState drawLabel(String label, Graphics2D g2, Rectangle2D plotArea, Rectangle2D dataArea, RectangleEdge edge, AxisState state, PlotRenderingInfo plotState) { if (state == null) { throw new IllegalArgumentException(\"Null 'state' argument.\"); } if ((label == null) || (label.equals(\"\"))) { return state; } Font font = getLabelFont(); RectangleInsets insets = getLabelInsets(); g2.setFont(font); g2.setPaint(getLabelPaint()); FontMetrics fm = g2.getFontMetrics(); Rectangle2D labelBounds = TextUtilities.getTextBounds(label, g2, fm); Shape hotspot = null; if (edge == RectangleEdge.TOP) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); float w = (float) labelBounds.getWidth(); float h = (float) labelBounds.getHeight(); float labelx = (float) dataArea.getCenterX(); float labely = (float) (state.getCursor() - insets.getBottom() - h / 2.0); TextUtilities.drawRotatedString(label, g2, labelx, labely, TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER); hotspot = new Rectangle2D.Float(labelx - w / 2.0f, labely - h / 2.0f, w, h); state.cursorUp(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.BOTTOM) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle(), labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); float w = (float) labelBounds.getWidth(); float h = (float) labelBounds.getHeight(); float labelx = (float) dataArea.getCenterX(); float labely = (float) (state.getCursor() + insets.getTop() + h / 2.0); TextUtilities.drawRotatedString(label, g2, labelx, labely, TextAnchor.CENTER, getLabelAngle(), TextAnchor.CENTER); hotspot = new Rectangle2D.Float(labelx - w / 2.0f, labely - h / 2.0f, w, h); state.cursorDown(insets.getTop() + labelBounds.getHeight() + insets.getBottom()); } else if (edge == RectangleEdge.LEFT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() - Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); float w = (float) labelBounds.getWidth(); float h = (float) labelBounds.getHeight(); float labelx = (float) (state.getCursor() - insets.getRight() - w / 2.0); float labely = (float) dataArea.getCenterY(); TextUtilities.drawRotatedString(label, g2, labelx, labely, TextAnchor.CENTER, getLabelAngle() - Math.PI / 2.0, TextAnchor.CENTER); hotspot = new Rectangle2D.Float(labelx - w / 2.0f, labely - h / 2.0f, w, h); state.cursorLeft(insets.getLeft() + labelBounds.getWidth() + insets.getRight()); } else if (edge == RectangleEdge.RIGHT) { AffineTransform t = AffineTransform.getRotateInstance( getLabelAngle() + Math.PI / 2.0, labelBounds.getCenterX(), labelBounds.getCenterY()); Shape rotatedLabelBounds = t.createTransformedShape(labelBounds); labelBounds = rotatedLabelBounds.getBounds2D(); float w = (float) labelBounds.getWidth(); float h = (float) labelBounds.getHeight(); float labelx = (float) (state.getCursor() + insets.getLeft() + w / 2.0); float labely = (float) (dataArea.getY() + dataArea.getHeight() / 2.0); TextUtilities.drawRotatedString(label, g2, labelx, labely, TextAnchor.CENTER, getLabelAngle() + Math.PI / 2.0, TextAnchor.CENTER); hotspot = new Rectangle2D.Float(labelx - w / 2.0f, labely - h / 2.0f, w, h); state.cursorRight(insets.getLeft() + labelBounds.getWidth() + insets.getRight()); } if (plotState != null && hotspot != null) { ChartRenderingInfo owner = plotState.getOwner(); /* EntityCollection entities = owner.getEntityCollection(); */ <mask> if (entities != null) { entities.add(new AxisLabelEntity(this, hotspot, this.labelToolTip, this.labelURL)); } } return state; } </s> java",
      "function range": "1092,5-1200,5"
    },
    "Closure_40_src/com/google/javascript/jscomp/NameAnalyzer.java_635-636": {
      "loc": "635-636",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns != null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns != null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ <mask> if (name != null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } } </s> java",
      "function range": "595,5-642,5",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new ClassDefiningMethodNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new ClassDefiningClassDefNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new ClassDefiningClassNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new FunctionDefiningClassNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new FunctionDefiningClassDefNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } else if (ns.onlyAffectsClassDef) { if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new FunctionDefiningClassNode( name, n, parent, parent.getParent())); } } else if (ns.onlyAffectsClassDef) { refNodes.add(new ClassDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { if (NodeUtil.isVarDeclaration(n)) { NameInformation ns = createNameInformation(t, n, parent); Preconditions.checkNotNull(ns); recordSet(ns.name, n); } else if (NodeUtil.isFunctionDeclaration(n)) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { JsName nameInfo = getName(nameNode.getString(), true); recordSet(nameInfo.name, nameNode); } } else if (NodeUtil.isObjectLitKey(n, parent)) { NameInformation ns = createNameInformation(t, n, parent); if (ns!= null) { recordSet(ns.name, n); } } } if (n.isAssign()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null) { if (ns.isPrototype) { recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n); } else { recordSet(ns.name, nameNode); } } } else if (n.isCall()) { Node nameNode = n.getFirstChild(); NameInformation ns = createNameInformation(t, nameNode, n); if (ns!= null && ns.onlyAffectsClassDef) { /* JsName name = getName(ns.name, false); */ if (name!= null) { refNodes.add(new FunctionDefiningClassNode( name, n, parent, parent.getParent())); } } else if (ns.onlyAffectsClassDef) { refNodes.add(new FunctionDefiningFunctionNode( name, n, parent, parent.getParent())); } } } }"
      ]
    },
    "Closure_46_src/com/google/javascript/rhino/jstype/RecordType.java_142-145": {
      "loc": "142-145",
      "input": "<s> @Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ <mask> RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); } </s> java",
      "function range": "140,3-155,3",
      "output": [
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ JSType result = super.getLeastSupertype(that); RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return getPropertyNode(property); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.isRecordType()) { return that.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.isRecordType()) { return getLeastSupertype(that.toMaybeRecordType()); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property)) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))); { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ if (that.isRecordType()) { return super.getLeastSupertype(that); } RecordTypeBuilder builder = new RecordTypeBuilder(registry); for (String property : properties.keySet()) { if (that.toMaybeRecordType().hasProperty(property) && that.toMaybeRecordType().getPropertyType(property).isEquivalentTo( getPropertyType(property))) { builder.addProperty(property, getPropertyType(property), getPropertyNode(property)); } } return builder.build(); }",
        "@Override public JSType getLeastSupertype(JSType that) { /* if (!that.isRecordType()) { return super.getLeastSupertype(that); } */ JSType result = super.getLeastSupertype(that); return result; }"
      ]
    },
    "Closure_77_src/com/google/javascript/jscomp/CodeGenerator.java_967-967": {
      "loc": "967-967",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ <mask> case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "function range": "956,3-1025,3",
      "output": [
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\f': sb.append(\"\\\\f\"); break; /* case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\f': sb.append(\"\\\\f\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; /* case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\f': sb.append(\"\\\\f\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\n': sb.append(\"\\\\n\"); break; /* case '\\r': sb.append(\"\\\\r\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c <= 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); sb.toString(); }"
      ]
    },
    "Closure_119_src/com/google/javascript/jscomp/GlobalNamespace.java_366-366": {
      "loc": "366-366",
      "input": "<s> public void collect(JSModule module, Scope scope, Node n) { Node parent = n.getParent(); String name; boolean isSet = false; Name.Type type = Name.Type.OTHER; boolean isPropAssign = false; switch (n.getType()) { case Token.GETTER_DEF: case Token.SETTER_DEF: case Token.STRING_KEY: name = null; if (parent != null && parent.isObjectLit()) { name = getNameForObjLitKey(n); } if (name == null) { return; } isSet = true; switch (n.getType()) { case Token.STRING_KEY: type = getValueType(n.getFirstChild()); break; case Token.GETTER_DEF: type = Name.Type.GET; break; case Token.SETTER_DEF: type = Name.Type.SET; break; default: throw new IllegalStateException(\"unexpected:\" + n); } break; case Token.NAME: if (parent != null) { switch (parent.getType()) { case Token.VAR: isSet = true; Node rvalue = n.getFirstChild(); type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue); break; case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet = true; type = getValueType(n.getNext()); } break; case Token.GETPROP: return; case Token.FUNCTION: Node gramps = parent.getParent(); if (gramps == null || NodeUtil.isFunctionExpression(parent)) { return; } isSet = true; type = Name.Type.FUNCTION; break; /* case Token.INC: */ <mask> case Token.DEC: isSet = true; type = Name.Type.OTHER; break; default: if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet = true; type = Name.Type.OTHER; } } } name = n.getString(); break; case Token.GETPROP: if (parent != null) { switch (parent.getType()) { case Token.ASSIGN: if (parent.getFirstChild() == n) { isSet = true; type = getValueType(n.getNext()); isPropAssign = true; } break; case Token.INC: case Token.DEC: isSet = true; type = Name.Type.OTHER; break; case Token.GETPROP: return; default: if (NodeUtil.isAssignmentOp(parent) && parent.getFirstChild() == n) { isSet = true; type = Name.Type.OTHER; } } } name = n.getQualifiedName(); if (name == null) { return; } break; default: return; } if (!isGlobalNameReference(name, scope)) { return; } if (isSet) { if (isGlobalScope(scope)) { handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type); } else { handleSetFromLocal(module, scope, n, parent, name); } } else { handleGet(module, scope, n, parent, name); } } </s> java",
      "function range": "306,5-430,5"
    },
    "Closure_123_src/com/google/javascript/jscomp/CodeGenerator.java_285-286": {
      "loc": "285-286",
      "input": "<s> void add(Node n, Context context) { if (!cc.continueProcessing()) { return; } int type = n.getType(); String opstr = NodeUtil.opToStr(type); int childCount = n.getChildCount(); Node first = n.getFirstChild(); Node last = n.getLastChild(); if (opstr != null && first != last) { Preconditions.checkState( childCount == 2, \"Bad binary operator \\\"%s\\\": expected 2 arguments but got %s\", opstr, childCount); int p = NodeUtil.precedence(type); Context rhsContext = getContextForNoInOperator(context); if (last.getType() == type && NodeUtil.isAssociative(type)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else if (NodeUtil.isAssignmentOp(n) && NodeUtil.isAssignmentOp(last)) { addExpr(first, p, context); cc.addOp(opstr, true); addExpr(last, p, rhsContext); } else { unrollBinaryOperator(n, type, opstr, context, rhsContext, p, p + 1); } return; } cc.startSourceMapping(n); switch (type) { case Token.TRY: { Preconditions.checkState(first.getNext().isBlock() && !first.getNext().hasMoreThanOneChild()); Preconditions.checkState(childCount >= 2 && childCount <= 3); add(\"try\"); add(first, Context.PRESERVE_BLOCK); Node catchblock = first.getNext().getFirstChild(); if (catchblock != null) { add(catchblock); } if (childCount == 3) { add(\"finally\"); add(last, Context.PRESERVE_BLOCK); } break; } case Token.CATCH: Preconditions.checkState(childCount == 2); add(\"catch(\"); add(first); add(\")\"); add(last, Context.PRESERVE_BLOCK); break; case Token.THROW: Preconditions.checkState(childCount == 1); add(\"throw\"); add(first); cc.endStatement(true); break; case Token.RETURN: add(\"return\"); if (childCount == 1) { add(first); } else { Preconditions.checkState(childCount == 0); } cc.endStatement(); break; case Token.VAR: if (first != null) { add(\"var \"); addList(first, false, getContextForNoInOperator(context)); } break; case Token.LABEL_NAME: Preconditions.checkState(!n.getString().isEmpty()); addIdentifier(n.getString()); break; case Token.NAME: if (first == null || first.isEmpty()) { addIdentifier(n.getString()); } else { Preconditions.checkState(childCount == 1); addIdentifier(n.getString()); cc.addOp(\"=\", true); if (first.isComma()) { addExpr(first, NodeUtil.precedence(Token.ASSIGN), Context.OTHER); } else { addExpr(first, 0, getContextForNoInOperator(context)); } } break; case Token.ARRAYLIT: add(\"[\"); addArrayList(first); add(\"]\"); break; case Token.PARAM_LIST: add(\"(\"); addList(first); add(\")\"); break; case Token.COMMA: Preconditions.checkState(childCount == 2); unrollBinaryOperator(n, Token.COMMA, \",\", context, getContextForNoInOperator(context), 0, 0); break; case Token.NUMBER: Preconditions.checkState(childCount == 0); cc.addNumber(n.getDouble()); break; case Token.TYPEOF: case Token.VOID: case Token.NOT: case Token.BITNOT: case Token.POS: { Preconditions.checkState(childCount == 1); cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); break; } case Token.NEG: { Preconditions.checkState(childCount == 1); if (n.getFirstChild().isNumber()) { cc.addNumber(-n.getFirstChild().getDouble()); } else { cc.addOp(NodeUtil.opToStrNoFail(type), false); addExpr(first, NodeUtil.precedence(type), Context.OTHER); } break; } case Token.HOOK: { Preconditions.checkState(childCount == 3); int p = NodeUtil.precedence(type); /* Context rhsContext = Context.OTHER; */ <mask> addExpr(first, p + 1, context); cc.addOp(\"?\", true); addExpr(first.getNext(), 1, rhsContext); cc.addOp(\":\", true); addExpr(last, 1, rhsContext); break; } case Token.REGEXP: if (!first.isString() || !last.isString()) { throw new Error(\"Expected children to be strings\"); } String regexp = regexpEscape(first.getString(), outputCharsetEncoder); if (childCount == 2) { add(regexp + last.getString()); } else { Preconditions.checkState(childCount == 1); add(regexp); } break; case Token.FUNCTION: if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } Preconditions.checkState(childCount == 3); boolean funcNeedsParens = (context == Context.START_OF_EXPR); if (funcNeedsParens) { add(\"(\"); } add(\"function\"); add(first); add(first.getNext()); add(last, Context.PRESERVE_BLOCK); cc.endFunction(context == Context.STATEMENT); if (funcNeedsParens) { add(\")\"); } break; case Token.GETTER_DEF: case Token.SETTER_DEF: Preconditions.checkState(n.getParent().isObjectLit()); Preconditions.checkState(childCount == 1); Preconditions.checkState(first.isFunction()); Preconditions.checkState(first.getFirstChild().getString().isEmpty()); if (type == Token.GETTER_DEF) { Preconditions.checkState(!first.getChildAtIndex(1).hasChildren()); add(\"get \"); } else { Preconditions.checkState(first.getChildAtIndex(1).hasOneChild()); add(\"set \"); } String name = n.getString(); Node fn = first; Node parameters = fn.getChildAtIndex(1); Node body = fn.getLastChild(); if (!n.isQuotedString() && TokenStream.isJSIdentifier(name) && NodeUtil.isLatin(name)) { add(name); } else { double d = getSimpleNumber(name); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addJsString(n); } } add(parameters); add(body, Context.PRESERVE_BLOCK); break; case Token.SCRIPT: case Token.BLOCK: { if (n.getClass() != Node.class) { throw new Error(\"Unexpected Node subclass.\"); } boolean preserveBlock = context == Context.PRESERVE_BLOCK; if (preserveBlock) { cc.beginBlock(); } boolean preferLineBreaks = type == Token.SCRIPT || (type == Token.BLOCK && !preserveBlock && n.getParent() != null && n.getParent().isScript()); for (Node c = first; c != null; c = c.getNext()) { add(c, Context.STATEMENT); if (c.isVar()) { cc.endStatement(); } if (c.isFunction()) { cc.maybeLineBreak(); } if (preferLineBreaks) { cc.notePreferredLineBreak(); } } if (preserveBlock) { cc.endBlock(cc.breakAfterBlockFor(n, context == Context.STATEMENT)); } break; } case Token.FOR: if (childCount == 4) { add(\"for(\"); if (first.isVar()) { add(first, Context.IN_FOR_INIT_CLAUSE); } else { addExpr(first, 0, Context.IN_FOR_INIT_CLAUSE); } add(\";\"); add(first.getNext()); add(\";\"); add(first.getNext().getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { Preconditions.checkState(childCount == 3); add(\"for(\"); add(first); add(\"in\"); add(first.getNext()); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } break; case Token.DO: Preconditions.checkState(childCount == 2); add(\"do\"); addNonEmptyStatement(first, Context.OTHER, false); add(\"while(\"); add(last); add(\")\"); cc.endStatement(); break; case Token.WHILE: Preconditions.checkState(childCount == 2); add(\"while(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.EMPTY: Preconditions.checkState(childCount == 0); break; case Token.GETPROP: { Preconditions.checkState( childCount == 2, \"Bad GETPROP: expected 2 children, but got %s\", childCount); Preconditions.checkState( last.isString(), \"Bad GETPROP: RHS should be STRING\"); boolean needsParens = (first.isNumber()); if (needsParens) { add(\"(\"); } addExpr(first, NodeUtil.precedence(type), context); if (needsParens) { add(\")\"); } if (this.languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(last.getString())) { add(\"[\"); add(last); add(\"]\"); } else { add(\".\"); addIdentifier(last.getString()); } break; } case Token.GETELEM: Preconditions.checkState( childCount == 2, \"Bad GETELEM: expected 2 children but got %s\", childCount); addExpr(first, NodeUtil.precedence(type), context); add(\"[\"); add(first.getNext()); add(\"]\"); break; case Token.WITH: Preconditions.checkState(childCount == 2); add(\"with(\"); add(first); add(\")\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); break; case Token.INC: case Token.DEC: { Preconditions.checkState(childCount == 1); String o = type == Token.INC ? \"++\" : \"--\"; int postProp = n.getIntProp(Node.INCRDECR_PROP); if (postProp != 0) { addExpr(first, NodeUtil.precedence(type), context); cc.addOp(o, false); } else { cc.addOp(o, false); add(first); } break; } case Token.CALL: if (isIndirectEval(first) || n.getBooleanProp(Node.FREE_CALL) && NodeUtil.isGet(first)) { add(\"(0,\"); addExpr(first, NodeUtil.precedence(Token.COMMA), Context.OTHER); add(\")\"); } else { addExpr(first, NodeUtil.precedence(type), context); } add(\"(\"); addList(first.getNext()); add(\")\"); break; case Token.IF: boolean hasElse = childCount == 3; boolean ambiguousElseClause = context == Context.BEFORE_DANGLING_ELSE && !hasElse; if (ambiguousElseClause) { cc.beginBlock(); } add(\"if(\"); add(first); add(\")\"); if (hasElse) { addNonEmptyStatement( first.getNext(), Context.BEFORE_DANGLING_ELSE, false); add(\"else\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), false); } else { addNonEmptyStatement(first.getNext(), Context.OTHER, false); Preconditions.checkState(childCount == 2); } if (ambiguousElseClause) { cc.endBlock(); } break; case Token.NULL: Preconditions.checkState(childCount == 0); cc.addConstant(\"null\"); break; case Token.THIS: Preconditions.checkState(childCount == 0); add(\"this\"); break; case Token.FALSE: Preconditions.checkState(childCount == 0); cc.addConstant(\"false\"); break; case Token.TRUE: Preconditions.checkState(childCount == 0); cc.addConstant(\"true\"); break; case Token.CONTINUE: Preconditions.checkState(childCount <= 1); add(\"continue\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.DEBUGGER: Preconditions.checkState(childCount == 0); add(\"debugger\"); cc.endStatement(); break; case Token.BREAK: Preconditions.checkState(childCount <= 1); add(\"break\"); if (childCount == 1) { if (!first.isLabelName()) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(\" \"); add(first); } cc.endStatement(); break; case Token.EXPR_RESULT: Preconditions.checkState(childCount == 1); add(first, Context.START_OF_EXPR); cc.endStatement(); break; case Token.NEW: add(\"new \"); int precedence = NodeUtil.precedence(type); if (NodeUtil.containsType( first, Token.CALL, NodeUtil.MATCH_NOT_FUNCTION)) { precedence = NodeUtil.precedence(first.getType()) + 1; } addExpr(first, precedence, Context.OTHER); Node next = first.getNext(); if (next != null) { add(\"(\"); addList(next); add(\")\"); } break; case Token.STRING_KEY: Preconditions.checkState( childCount == 1, \"Object lit key must have 1 child\"); addJsString(n); break; case Token.STRING: Preconditions.checkState( childCount == 0, \"A string may not have children\"); addJsString(n); break; case Token.DELPROP: Preconditions.checkState(childCount == 1); add(\"delete \"); add(first); break; case Token.OBJECTLIT: { boolean needsParens = (context == Context.START_OF_EXPR); if (needsParens) { add(\"(\"); } add(\"{\"); for (Node c = first; c != null; c = c.getNext()) { if (c != first) { cc.listSeparator(); } if (c.isGetterDef() || c.isSetterDef()) { add(c); } else { Preconditions.checkState(c.isStringKey()); String key = c.getString(); if (!c.isQuotedString() && !(languageMode == LanguageMode.ECMASCRIPT3 && TokenStream.isKeyword(key)) && TokenStream.isJSIdentifier(key) && NodeUtil.isLatin(key)) { add(key); } else { double d = getSimpleNumber(key); if (!Double.isNaN(d)) { cc.addNumber(d); } else { addExpr(c, 1, Context.OTHER); } } add(\":\"); addExpr(c.getFirstChild(), 1, Context.OTHER); } } add(\"}\"); if (needsParens) { add(\")\"); } break; } case Token.SWITCH: add(\"switch(\"); add(first); add(\")\"); cc.beginBlock(); addAllSiblings(first.getNext()); cc.endBlock(context == Context.STATEMENT); break; case Token.CASE: Preconditions.checkState(childCount == 2); add(\"case \"); add(first); addCaseBody(last); break; case Token.DEFAULT_CASE: Preconditions.checkState(childCount == 1); add(\"default\"); addCaseBody(first); break; case Token.LABEL: Preconditions.checkState(childCount == 2); if (!first.isLabelName()) { throw new Error(\"Unexpected token type. Should be LABEL_NAME.\"); } add(first); add(\":\"); addNonEmptyStatement( last, getContextForNonEmptyExpression(context), true); break; case Token.CAST: add(\"(\"); add(first); add(\")\"); break; default: throw new Error(\"Unknown type \" + type + \"\\n\" + n.toStringTree()); } cc.endSourceMapping(n); } </s> java",
      "function range": "107,3-771,3"
    },
    "Lang_10_src/main/java/org/apache/commons/lang3/time/FastDateParser.java_307-314": {
      "loc": "307-314",
      "input": "<s> private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ <mask> wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; } </s> java",
      "function range": "303,5-343,5",
      "output": [
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*-\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isDigit(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\d+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isDigit(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*\\\\\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(!unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isLetter(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isLetterOrDigit(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } wasWhite= false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }",
        "private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) { boolean wasWhite= false; for(int i= 0; i<value.length(); ++i) { char c= value.charAt(i); /* if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*+\"); } continue; } */ if(Character.isWhitespace(c)) { if(!wasWhite) { wasWhite= true; regex.append(\"\\\\s*\"); } continue; } wasWhite = false; switch(c) { case '\\'': if(unquote) { if(++i==value.length()) { return regex; } c= value.charAt(i); } break; case '?': case '[': case ']': case '(': case ')': case '{': case '}': case '\\\\': case '|': case '*': case '+': case '^': case '$': case '.': regex.append('\\\\'); } regex.append(c); } return regex; }"
      ]
    },
    "Lang_24_src/main/java/org/apache/commons/lang3/math/NumberUtils.java_1413-1414": {
      "loc": "1413-1414",
      "input": "<s> public static boolean isNumber(String str) { if (StringUtils.isEmpty(str)) { return false; } char[] chars = str.toCharArray(); int sz = chars.length; boolean hasExp = false; boolean hasDecPoint = false; boolean allowSigns = false; boolean foundDigit = false; int start = (chars[0] == '-') ? 1 : 0; if (sz > start + 1) { if (chars[start] == '0' && chars[start + 1] == 'x') { int i = start + 2; if (i == sz) { return false; } for (; i < chars.length; i++) { if ((chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f') && (chars[i] < 'A' || chars[i] > 'F')) { return false; } } return true; } } sz--; int i = start; while (i < sz || (i < sz + 1 && allowSigns && !foundDigit)) { if (chars[i] >= '0' && chars[i] <= '9') { foundDigit = true; allowSigns = false; } else if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } hasDecPoint = true; } else if (chars[i] == 'e' || chars[i] == 'E') { if (hasExp) { return false; } if (!foundDigit) { return false; } hasExp = true; allowSigns = true; } else if (chars[i] == '+' || chars[i] == '-') { if (!allowSigns) { return false; } allowSigns = false; foundDigit = false; } else { return false; } i++; } if (i < chars.length) { if (chars[i] >= '0' && chars[i] <= '9') { return true; } if (chars[i] == 'e' || chars[i] == 'E') { return false; } if (chars[i] == '.') { if (hasDecPoint || hasExp) { return false; } return foundDigit; } if (!allowSigns && (chars[i] == 'd' || chars[i] == 'D' || chars[i] == 'f' || chars[i] == 'F')) { return foundDigit; } if (chars[i] == 'l' || chars[i] == 'L') { /* return foundDigit && !hasExp; */ <mask> } return false; } return !allowSigns && foundDigit; } </s> java",
      "function range": "1319,5-1421,5"
    },
    "Lang_38_src/java/org/apache/commons/lang3/time/FastDateFormat.java_872-872": {
      "loc": "872-872",
      "input": "<s> public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ <mask> calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); } </s> java",
      "function range": "870,5-876,5",
      "output": [
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZoneForced); } else { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZoneForced); } else { calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ mTimeZone = TimeZone.getDefault(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ if (mTimeZone!= null) calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar = calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZone); } else { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZoneForced); } else { calendar = (Calendar) Calendar.getInstance(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf); }",
        "public StringBuffer format(Calendar calendar, StringBuffer buf) { if (mTimeZoneForced) { /* calendar = (Calendar) calendar.clone(); */ calendar.setTimeZone(mTimeZoneForced); } else { calendar = (Calendar) calendar.clone(); calendar.setTimeZone(mTimeZone); } return applyRules(calendar, buf) }"
      ]
    },
    "Math_65_src/main/java/org/apache/commons/math/optimization/general/AbstractLeastSquaresOptimizer.java_258-259": {
      "loc": "258-259",
      "input": "<s> public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ <mask> } return chiSquare; } </s> java",
      "function range": "254,5-261,5",
      "output": [
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= residualsWeights[i]; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare *= residualsWeights[i]; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= residualsWeights[i] ; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= Math.sqrt(residualsWeights[i]); } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ } if ( chiSquare < 0 ) { chiSquare = 0 ; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ } if ( chiSquare == 0.0) { chiSquare = 1.0; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ } if ( chiSquare == 0.0) { chiSquare = 0.0; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= Math.sqrt(residualsWeights[i]) ; } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= Math.sqrt(residualsWeights[i] * residualsWeights[i]); } return chiSquare; }",
        "public double getChiSquare() { double chiSquare = 0; for (int i = 0; i < rows; ++i) { final double residual = residuals[i]; /* chiSquare += residual * residual / residualsWeights[i]; */ chiSquare /= Math.sqrt(residualsWeights[i] * residualsWeightsWeights[i]); } return chiSquare; }"
      ]
    },
    "Math_79_src/main/java/org/apache/commons/math/util/MathUtils.java_1624-1625": {
      "loc": "1624-1625",
      "input": "<s> public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ <mask> for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); } </s> java",
      "function range": "1623,5-1630,5",
      "output": [
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ double sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ final int p1 = p1; final int p2 = p2; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ for (int i = 0; i < p2.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ final int p1 = p1; final int p2 = p2; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math. sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ final int p1 = p1; final int p2 = p2; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum); }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ final int p1 = p1; final int p2 = p2; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum) }",
        "public static double distance(int[] p1, int[] p2) { /* int sum = 0; */ int sum = 0; for (int i = 0; i < p1.length; i++) { final int dp = p1[i] - p2[i]; sum += dp * dp; } return Math.sqrt(sum) }"
      ]
    },
    "Math_98_src/java/org/apache/commons/math/linear/BigMatrixImpl.java_991-992": {
      "loc": "991-992",
      "input": "<s> public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length != this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ <mask> for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; } </s> java",
      "function range": "985,5-1000,5",
      "output": [
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ BigDecimal[] data = this.getData(); for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ final BigDecimal[] data = this.getData(); for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int column = 0; column < nCols; column++) { out[column] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int col = 0; col < nCols; col++) { out[col] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ BigDecimal [ ] data = this.getData(); for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int column = 0; column < v.length; column++) { out[column] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int col = 0; col < v.length; col++) { out[col] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out[row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int column = 0; column < nCols; column++) { out[column] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out [row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int col = 0; col < nCols; col++) { out[col] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out [row] = sum; } return out; }",
        "public BigDecimal[] operate(BigDecimal[] v) throws IllegalArgumentException { if (v.length!= this.getColumnDimension()) { throw new IllegalArgumentException(\"vector has wrong length\"); } final int nRows = this.getRowDimension(); final int nCols = this.getColumnDimension(); /* final BigDecimal[] out = new BigDecimal[v.length]; */ for (int column = 0; column < v.length; column++) { out[column] = ZERO; } for (int row = 0; row < nRows; row++) { BigDecimal sum = ZERO; for (int i = 0; i < nCols; i++) { sum = sum.add(data[row][i].multiply(v[i])); } out [row] = sum; } return out; }"
      ]
    },
    "Chart_1_/source/org/jfree/chart/renderer/category/AbstractCategoryItemRenderer.java_1797-1798": {
      "loc": "1797-1798",
      "input": "<s> public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset != null) { */ <mask> return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item != null) { result.add(item); } } } } return result; } </s> java",
      "function range": "1790,5-1822,5",
      "output": [
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (plot == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { result.add(getLegendItem(index)); } } */ if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { result.add(getLegendItem(index)); } else { result.add(getLegendItem(index)); } return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (plot == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (plot == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } } return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ result.addAll(dataset.getLegendItems()); } */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } DEDENT return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { result.add(getLegendItem(index)); } } */ if (dataset == null) { return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } DEDENT return result; }",
        "public LegendItemCollection getLegendItems() { LegendItemCollection result = new LegendItemCollection(); if (this.plot == null) { return result; } int index = this.plot.getIndexOf(this); CategoryDataset dataset = this.plot.getDataset(index); /* if (dataset!= null) { */ if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { result.add(getLegendItem(index)); } else { result.add(getLegendItem(index)); } return result; } int seriesCount = dataset.getRowCount(); if (plot.getRowRenderingOrder().equals(SortOrder.ASCENDING)) { for (int i = 0; i < seriesCount; i++) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } } else { for (int i = seriesCount - 1; i >= 0; i--) { if (isSeriesVisibleInLegend(i)) { LegendItem item = getLegendItem(index, i); if (item!= null) { result.add(item); } } } DEDENT return result; }"
      ]
    },
    "Chart_3_/source/org/jfree/data/time/TimeSeries.java_1057-1058": {
      "loc": "1057-1058",
      "input": "<s> public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ <mask> if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; } </s> java",
      "function range": "1048,5-1072,5",
      "output": [
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new TimeSeriesDataItem(start, end)); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList(this.data)); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new TimeSeriesDataItem(start, end)); copy.data.add(new TimeSeriesDataItem(start, end)); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(this.data.get(start)); copy.data.add(this.data.get(end)); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem ) item.clone(); try { copy.add(clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(Clone); } catch (SeriesException e) { e.printStackTrace(); } } } return copy; }",
        "public TimeSeries createCopy(int start, int end) throws CloneNotSupportedException { if (start < 0) { throw new IllegalArgumentException(\"Requires start >= 0.\"); } if (end < start) { throw new IllegalArgumentException(\"Requires start <= end.\"); } TimeSeries copy = (TimeSeries) super.clone(); /* copy.data = new java.util.ArrayList(); */ copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); copy.data.add(new java.util.ArrayList()); if (this.data.size() > 0) { for (int index = start; index <= end; index++) { TimeSeriesDataItem item = (TimeSeriesDataItem) this.data.get(index); TimeSeriesDataItem clone = (TimeSeriesDataItem) item.clone(); try { copy.add(clone); } catch (SeriesException e ) { e.printStackTrace(); } } } return copy; }"
      ]
    },
    "Chart_6_/source/org/jfree/chart/util/ShapeList.java_111-112": {
      "loc": "111-112",
      "input": "<s> public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ <mask> } </s> java",
      "function range": "103,5-113,5",
      "output": [
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return true; }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return false; }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return super.equals(obj); }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj instanceof ShapeList; }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj == this; }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj.getClass() == this.getClass(); }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj instanceof ShapeList && super.equals(obj); }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj.getClass() == ShapeList.class; }",
        "public boolean equals(Object obj) { if (obj == this) { return true; } if (!(obj instanceof ShapeList)) { return false; } /* return super.equals(obj); */ return obj.getClass().equals(this.getClass()); }"
      ]
    },
    "Chart_8_/source/org/jfree/data/time/Week.java_175-176": {
      "loc": "175-176",
      "input": "<s> public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ <mask> } </s> java",
      "function range": "173,5-176,5",
      "output": [
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.zone = zone; }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.timezone = zone; }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.setTimeZone(zone); }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.setZone(zone); }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ setZone(zone); }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ super(time, zone); }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ setTimeZone(zone); }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.time = time; }",
        "public Week(Date time, TimeZone zone) { /* this(time, RegularTimePeriod.DEFAULT_TIME_ZONE, Locale.getDefault()); */ this.zone = zone; } }"
      ]
    },
    "Chart_9_/source/org/jfree/data/time/TimeSeries.java_944-945": {
      "loc": "944-945",
      "input": "<s> public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null 'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ <mask> emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } } </s> java",
      "function range": "918,5-956,5",
      "output": [
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); if (endIndex == this.data.size()) { emptyRange = true; } } */ if (startIndex == endIndex) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ if (endIndex == this.data.size()) { emptyRange = true; } } else { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ if (endIndex == this.data.size()) { emptyRange = true; } } */ if (startIndex == endIndex) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); } */ if (endIndex == this.data.size()) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); } if (endIndex == this.data.size()) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); if (endIndex == this.data.size()) { emptyRange = true; } } */ if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); if (endIndex == this.data.size()) { emptyRange = true; } } */ if (startIndex == endIndex) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); if (endIndex == this.data.size()) { emptyRange = true; } } */ if (startIndex == endIndex) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); copy.data.add(start); copy.data.add(end); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ if (endIndex == this.data.size()) { emptyRange = true; } } else { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); copy.data.add(start); copy.data.add(end); copy.data.add(start); copy.data.add(end); return copy; } else { return createCopy(startIndex, endIndex); } }",
        "public TimeSeries createCopy(RegularTimePeriod start, RegularTimePeriod end) throws CloneNotSupportedException { if (start == null) { throw new IllegalArgumentException(\"Null'start' argument.\"); } if (end == null) { throw new IllegalArgumentException(\"Null 'end' argument.\"); } if (start.compareTo(end) > 0) { throw new IllegalArgumentException( \"Requires start on or before end.\"); } boolean emptyRange = false; int startIndex = getIndex(start); if (startIndex < 0) { startIndex = -(startIndex + 1); if (startIndex == this.data.size()) { emptyRange = true; } } int endIndex = getIndex(end); if (endIndex < 0) { endIndex = -(endIndex + 1); endIndex = endIndex - 1; } /* if (endIndex < 0) { */ endIndex = -(endIndex + 1); } if (endIndex == this.data.size()) { emptyRange = true; } if (emptyRange) { TimeSeries copy = (TimeSeries) super.clone(); copy.data = new java.util.ArrayList(); copy.data.add(start); copy.data.add(end); copy.data.add(start); copy.data.add(end); return copy; } else { return createCopy(startIndex, endIndex); } }"
      ]
    },
    "Chart_10_/source/org/jfree/chart/imagemap/StandardToolTipTagFragmentGenerator.java_65-66": {
      "loc": "65-66",
      "input": "<s> public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ <mask> + \"\\\" alt=\\\"\\\"\"; } </s> java",
      "function range": "64,5-67,5",
      "output": [
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" <img src=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" < img src=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" alt=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" text=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" src=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" content=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" href=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return toolTipText + \"\\\" alt=\\\"\\\"\"; }",
        "public String generateToolTipFragment(String toolTipText) { /* return \" title=\\\"\" + toolTipText */ return \" title=\\\"\" + toolTipText + \"\\\" alt=\\\"\\\"\"; }"
      ]
    },
    "Chart_11_/source/org/jfree/chart/util/ShapeUtilities.java_275-276": {
      "loc": "275-276",
      "input": "<s> public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule() != p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ <mask> double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone() != iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1 != seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; } </s> java",
      "function range": "264,5-296,5",
      "output": [
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ /* PathIterator iterator3 = p2.getPathIterator(null); */ double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ PathIterator iterator3 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ double[] arrays = new double[6]; double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ if (iterator2 == null) { return false; } double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ if (iterator1 == null || iterator2 == null) { return false; } double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ PathIterator iterator2 = p2.getPathIterator(null); double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() and iterator2.isDone(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ /* PathIterator iterator3 = p2.getPathIterator(null); */ double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone()(); } return true; }",
        "public static boolean equal(GeneralPath p1, GeneralPath p2) { if (p1 == null) { return (p2 == null); } if (p2 == null) { return false; } if (p1.getWindingRule()!= p2.getWindingRule()) { return false; } PathIterator iterator1 = p1.getPathIterator(null); /* PathIterator iterator2 = p1.getPathIterator(null); */ if (iterator1 == null || iterator2 == null) { return false; } double[] d1 = new double[6]; double[] d2 = new double[6]; boolean done = iterator1.isDone() && iterator2.isDone(); while (!done) { if (iterator1.isDone()!= iterator2.isDone()) { return false; } int seg1 = iterator1.currentSegment(d1); int seg2 = iterator2.currentSegment(d2); if (seg1!= seg2) { return false; } if (!Arrays.equals(d1, d2)) { return false; } iterator1.next(); iterator2.next(); done = iterator1.isDone() && iterator2.isDone(); } return True; }"
      ]
    },
    "Chart_12_/source/org/jfree/chart/plot/MultiplePiePlot.java_145-146": {
      "loc": "145-146",
      "input": "<s> public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ <mask> PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } </s> java",
      "function range": "143,5-158,5",
      "output": [
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { super(); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ this.categoryDataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { super(); // PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { super(); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { super(); PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ this.categoryDataset = dataset; PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ } public MultiplePiePlot() { super(); // PiePlot piePlot = new PiePlot(null); this.pieChart = new JFreeChart(piePlot); this.pieChart.removeLegend(); this.dataExtractOrder = TableOrder.BY_COLUMN; this.pieChart.setBackgroundPaint(null); TextTitle seriesTitle = new TextTitle(\"Series Title\", new Font(\"SansSerif\", Font.BOLD, 12)); seriesTitle.setPosition(RectangleEdge.BOTTOM); this.pieChart.setTitle(seriesTitle); this.aggregatedItemsKey = \"Other\"; this.aggregatedItemsPaint = Color.lightGray; this.sectionPaints = new HashMap(); } }",
        "public MultiplePiePlot(CategoryDataset dataset) { super(); /* this.dataset = dataset; */ }"
      ]
    },
    "Chart_13_/source/org/jfree/chart/block/BorderArrangement.java_455-456": {
      "loc": "455-456",
      "input": "<s> protected Size2D arrangeFF(BlockContainer container, Graphics2D g2, RectangleConstraint constraint) { double[] w = new double[5]; double[] h = new double[5]; w[0] = constraint.getWidth(); if (this.topBlock != null) { RectangleConstraint c1 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight()), LengthConstraintType.RANGE); Size2D size = this.topBlock.arrange(g2, c1); h[0] = size.height; } w[1] = w[0]; if (this.bottomBlock != null) { RectangleConstraint c2 = new RectangleConstraint(w[0], null, LengthConstraintType.FIXED, 0.0, new Range(0.0, constraint.getHeight() - h[0]), LengthConstraintType.RANGE); Size2D size = this.bottomBlock.arrange(g2, c2); h[1] = size.height; } h[2] = constraint.getHeight() - h[1] - h[0]; if (this.leftBlock != null) { RectangleConstraint c3 = new RectangleConstraint(0.0, new Range(0.0, constraint.getWidth()), LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.leftBlock.arrange(g2, c3); w[2] = size.width; } h[3] = h[2]; if (this.rightBlock != null) { RectangleConstraint c4 = new RectangleConstraint(0.0, /* new Range(0.0, constraint.getWidth() - w[2]), */ <mask> LengthConstraintType.RANGE, h[2], null, LengthConstraintType.FIXED); Size2D size = this.rightBlock.arrange(g2, c4); w[3] = size.width; } h[4] = h[2]; w[4] = constraint.getWidth() - w[3] - w[2]; RectangleConstraint c5 = new RectangleConstraint(w[4], h[4]); if (this.centerBlock != null) { this.centerBlock.arrange(g2, c5); } if (this.topBlock != null) { this.topBlock.setBounds(new Rectangle2D.Double(0.0, 0.0, w[0], h[0])); } if (this.bottomBlock != null) { this.bottomBlock.setBounds(new Rectangle2D.Double(0.0, h[0] + h[2], w[1], h[1])); } if (this.leftBlock != null) { this.leftBlock.setBounds(new Rectangle2D.Double(0.0, h[0], w[2], h[2])); } if (this.rightBlock != null) { this.rightBlock.setBounds(new Rectangle2D.Double(w[2] + w[4], h[0], w[3], h[3])); } if (this.centerBlock != null) { this.centerBlock.setBounds(new Rectangle2D.Double(w[2], h[0], w[4], h[4])); } return new Size2D(constraint.getWidth(), constraint.getHeight()); } </s> java",
      "function range": "422,5-489,5"
    },
    "Chart_17_/source/org/jfree/data/time/TimeSeries.java_857-858": {
      "loc": "857-858",
      "input": "<s> public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ <mask> return clone; } </s> java",
      "function range": "856,5-859,5",
      "output": [
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone(); return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone ( ) ; return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone(clone); return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone ( clone ) ; return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ if ( clone == null) throw new CloneNotSupportedException(); return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone ( clone); return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ super. clone() ; return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ if ( clone!= null ) { return clone; } return clone; }",
        "public Object clone() throws CloneNotSupportedException { /* Object clone = createCopy(0, getItemCount() - 1); */ if ( clone!= null ) { return clone; }"
      ]
    },
    "Chart_20_/source/org/jfree/chart/plot/ValueMarker.java_95-96": {
      "loc": "95-96",
      "input": "<s> public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ <mask> this.value = value; } </s> java",
      "function range": "93,5-97,5",
      "output": [
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.stroke = stroke; this.outlinePaint = outlinePaint; this.outlineStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.outlinePaint = outlinePaint; this.outlineStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.stroke = stroke; this.strokePaint = outlinePaint; this.strokeStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.stroke = stroke; this.strokePaint = outlinePaint; this.outlineStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.outlinePaint = outlinePaint; this.outlineStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.stroke = stroke; this.strokePaint = outlinePaint; this.strokeStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.outlinePaint = outlinePaint; this.outlineStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.stroke = stroke; this.outlinePaint = outlinePaint; this.strokeStroke = outlineStroke; this.value = value; }",
        "public ValueMarker(double value, Paint paint, Stroke stroke, Paint outlinePaint, Stroke outlineStroke, float alpha) { /* super(paint, stroke, paint, stroke, alpha); */ this.paint = paint; this.stroke = stroke; this.strokeStroke = outlineStroke; this.value = value; }",
        "public ValueMarker() { super(); }"
      ]
    },
    "Chart_24_/source/org/jfree/chart/renderer/GrayPaintScale.java_126-127": {
      "loc": "126-127",
      "input": "<s> public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ <mask> - this.lowerBound) * 255.0); return new Color(g, g, g); } </s> java",
      "function range": "123,5-129,5",
      "output": [
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0); */ g = (int) ((value - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0); */ g = (int) ((v - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0 ) + (value - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ ) * 255.0); g = (int) ((value - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0); g = (int) ((value - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0); g = (int) ((v - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ ) * 255.0); g = (int) ((v - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ this.upperBound) * 255.0); g = (int) ((value - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * (v - this.lowerBound) * 255.0); return new Color(g, g, g); }",
        "public Paint getPaint(double value) { double v = Math.max(value, this.lowerBound); v = Math.min(v, this.upperBound); /* int g = (int) ((value - this.lowerBound) / (this.upperBound */ * 255.0); */ g = (int) ((value - this.lowerBound) * 255.0); return new Color(g, g, g); }"
      ]
    },
    "Cli_4_/src/java/org/apache/commons/cli/Parser.java_298-299": {
      "loc": "298-299",
      "input": "<s> private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ <mask> while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } } </s> java",
      "function range": "290,5-309,5",
      "output": [
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next().toString()); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(\" \"); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } if (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(\"\\n\"); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } if (iter.hasNext()) { buff.append(\",\"); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } else if (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } if (iter.hasNext()) { buff.append(\",\"); } if (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()); } }",
        "private void checkRequiredOptions() throws MissingOptionException { if (requiredOptions.size() > 0) { Iterator iter = requiredOptions.iterator(); /* StringBuffer buff = new StringBuffer(); */ if (iter.hasNext()) { buff.append(iter.next()); } while (iter.hasNext()) { buff.append(iter.next()); } throw new MissingOptionException(buff.toString()) } }"
      ]
    },
    "Cli_8_/src/java/org/apache/commons/cli/HelpFormatter.java_812-813": {
      "loc": "812-813",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ <mask> if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "function range": "792,5-823,5",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ pos = findWrapPos(text, width, pos); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ pos = findWrapPos(text, width, nextLineTabStop); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ pos = findWrapPos(text, width, nextLineTabStop + 1); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ final int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ sb.append(rtrim(text)); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ pos = findWrapPos(text, width, nextLineTabStop); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine; } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); /* pos = findWrapPos(text, width, nextLineTabStop); */ sb.append(rtrim(text)); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine; } }"
      ]
    },
    "Cli_11_/src/java/org/apache/commons/cli/HelpFormatter.java_632-633": {
      "loc": "632-633",
      "input": "<s> private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt() != null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName() != null)) */ <mask> { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } } </s> java",
      "function range": "613,5-642,5",
      "output": [
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.hasArg() && (option.getArgName()!= null)) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArgName()!= null) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.hasArg()) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null && option.getArgName().length() > 0) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null && (option.getArgName()!= null)) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null) { buff.append(\"<\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null && (option.getArgName() instanceof String)) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.getArg()!= null) { buff.append(\" <\").append(option.getArg()).append(\">\"); } else { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff.append(\"]\"); } }",
        "private static void appendOption(final StringBuffer buff, final Option option, final boolean required) { if (!required) { buff.append(\"[\"); } if (option.getOpt()!= null) { buff.append(\"-\").append(option.getOpt()); } else { buff.append(\"--\").append(option.getLongOpt()); } /* if (option.hasArg() && (option.getArgName()!= null)) */ if (option.hasArg() && (option.getArgName()!= null)) { buff.append(\" <\").append(option.getArgName()).append(\">\"); } if (!required) { buff. append(\"]\"); } }"
      ]
    },
    "Cli_24_/src/java/org/apache/commons/cli/HelpFormatter.java_825-827": {
      "loc": "825-827",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ <mask> } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "function range": "809,5-852,5",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } if (text.length() < nextLineTabStop) { sb.append(rtrim(text)); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, nextLineTabStop - 1)).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, nextLineTabStop - 1)).append(defaultNewLine)); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ sb.append(rtrim(text.substring(0, nextLineTabStop - 1)).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text. substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* throw new IllegalStateException(\"Total width is less than the width of the argument and indent \" + \"- no room for the description\"); */ } else { sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine; } }"
      ]
    },
    "Cli_25_/src/java/org/apache/commons/cli/HelpFormatter.java_825-826": {
      "loc": "825-826",
      "input": "<s> protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ <mask> } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } } </s> java",
      "function range": "809,5-851,5",
      "output": [
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, nextLineTabStop))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ nextLineTabStop = width - 1; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, nextLineTabStop)); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, nextLineTabStop - 1)).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, nextLineTabStop))).append(defaultNewLine); } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, nextLineTabStop))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text. substring(0, pos))).append(defaultNewLine); } }",
        "protected StringBuffer renderWrappedText(StringBuffer sb, int width, int nextLineTabStop, String text) { int pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(rtrim(text)); return sb; } sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); if (nextLineTabStop >= width) { /* nextLineTabStop = width - 1; */ sb.append(rtrim(text.substring(0, pos))).append(defaultNewLine); return sb; } final String padding = createPadding(nextLineTabStop); while (true) { text = padding + text.substring(pos).trim(); pos = findWrapPos(text, width, 0); if (pos == -1) { sb.append(text); return sb; } if ( (text.length() > width) && (pos == nextLineTabStop - 1) ) { pos = width; } sb.append(rtrim(text. substring(0, pos))).append(defaultNewLine); } }"
      ]
    },
    "Cli_28_/src/java/org/apache/commons/cli/Parser.java_290-291": {
      "loc": "290-291",
      "input": "<s> protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ <mask> } cmd.addOption(opt); } } } </s> java",
      "function range": "252,5-296,5",
      "output": [
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ opt.addValueForProcessing(value); } else { opt.addValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ } else { opt.addValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ cmd.addOption(opt); } else { cmd.addOption(opt); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ } if (opt.getValues() == null || opt.getValues().length == 0) { opt.addValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ } else if (opt.getValues() == null || opt.getValues().length == 0) { opt.addValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ if (opt.getValues() == null || opt.getValues().length == 0) { opt.addValueForProcessing(value); } } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ if (opt.getValues() == null || opt.getValues().length == 0) { opt.addValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ opt.setValueForProcessing(value); } else { opt.setValueForProcessing(value); } cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ cmd.addOption(opt); } else { cmd.addOption(opt); } } else { cmd.addOption(opt); } } }",
        "protected void processProperties(Properties properties) { if (properties == null) { return; } for (Enumeration e = properties.propertyNames(); e.hasMoreElements();) { String option = e.nextElement().toString(); if (!cmd.hasOption(option)) { Option opt = getOptions().getOption(option); String value = properties.getProperty(option); if (opt.hasArg()) { if (opt.getValues() == null || opt.getValues().length == 0) { try { opt.addValueForProcessing(value); } catch (RuntimeException exp) { } } } else if (!(\"yes\".equalsIgnoreCase(value) || \"true\".equalsIgnoreCase(value) || \"1\".equalsIgnoreCase(value))) { /* break; */ opt.addValueForProcessing(value); } else { opt.addValueForProcessing(value); } } cmd.addOption(opt); } } }"
      ]
    },
    "Cli_32_/src/main/java/org/apache/commons/cli/HelpFormatter.java_937-942": {
      "loc": "937-942",
      "input": "<s> protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos)) != -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos)) != -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos)) != ' ') && (c != '\\n') && (c != '\\r')) { ++pos; } */ <mask> return pos == text.length() ? -1 : pos; } </s> java",
      "function range": "902,5-943,5",
      "output": [
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos > text.length()) { return pos; } return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos < text.length()) { return pos; } return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos == text.length()) { return pos; } return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos >= text.length()) { return pos; } return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos <= text.length()) { return pos; } return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ return pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos > text.length()) { return pos; } else { return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos == text.length()) { return pos; } else { return pos == text.length()? -1 : pos; }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos > text.length()) { return pos; } else { return pos == text.length()? -1 : pos; } }",
        "protected int findWrapPos(String text, int width, int startPos) { int pos; if (((pos = text.indexOf('\\n', startPos))!= -1 && pos <= width) || ((pos = text.indexOf('\\t', startPos))!= -1 && pos <= width)) { return pos + 1; } else if (startPos + width >= text.length()) { return -1; } pos = startPos + width; char c; while ((pos >= startPos) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { --pos; } if (pos > startPos) { return pos; } pos = startPos + width; /* while ((pos <= text.length()) && ((c = text.charAt(pos))!='') && (c!= '\\n') && (c!= '\\r')) { ++pos; } */ if (pos == text.length()) { return pos; } else { return pos == text.length()? -1 : pos; } }"
      ]
    },
    "Cli_40_/src/main/java/org/apache/commons/cli/TypeHandler.java_103-104": {
      "loc": "103-104",
      "input": "<s> @SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ <mask> } } </s> java",
      "function range": "62,5-105,5",
      "output": [
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ return null; } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ } } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ return null; } } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ throw new ParseException(str); } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ return (T) createValue(str, clazz); } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ return (T) createValue(str, clazz); } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ throw new ParseException(str, ParseException.class); } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ return (T) createObject(str); } }",
        "@SuppressWarnings(\"unchecked\") public static <T> T createValue(final String str, final Class<T> clazz) throws ParseException { if (PatternOptionBuilder.STRING_VALUE == clazz) { return (T) str; } else if (PatternOptionBuilder.OBJECT_VALUE == clazz) { return (T) createObject(str); } else if (PatternOptionBuilder.NUMBER_VALUE == clazz) { return (T) createNumber(str); } else if (PatternOptionBuilder.DATE_VALUE == clazz) { return (T) createDate(str); } else if (PatternOptionBuilder.CLASS_VALUE == clazz) { return (T) createClass(str); } else if (PatternOptionBuilder.FILE_VALUE == clazz) { return (T) createFile(str); } else if (PatternOptionBuilder.EXISTING_FILE_VALUE == clazz) { return (T) openFile(str); } else if (PatternOptionBuilder.FILES_VALUE == clazz) { return (T) createFiles(str); } else if (PatternOptionBuilder.URL_VALUE == clazz) { return (T) createURL(str); } else { /* return null; */ throw new ParseException (str, ParseException.class); } }"
      ]
    },
    "Closure_1_/src/com/google/javascript/jscomp/RemoveUnusedVars.java_379-380": {
      "loc": "379-380",
      "input": "<s> private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ <mask> Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); if (!modifyCallers) { Node lastArg; while ((lastArg = argList.getLastChild()) != null) { Var var = fnScope.getVar(lastArg.getString()); if (!referenced.contains(var)) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { break; } } } else { callSiteOptimizer.optimize(fnScope, referenced); } } </s> java",
      "function range": "369,3-406,3",
      "output": [
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getString()); Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); if (!modifyCallers) { Node lastArg; while ((lastArg = argList.getLastChild())!= null) { Var var = fnScope.getVar(lastArg.getString()); if (!referenced.contains(var)) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { break; } } } else { callSiteOptimizer.optimize(fnScope, referenced); } }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVarName()); Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); if (!modifyCallers) { Node lastArg; while ((lastArg = argList.getLastChild())!= null) { Var var = fnScope.getVar(lastArg.getString()); if (!referenced.contains(var)) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { break; } } } else { callSiteOptimizer.optimize(fnScope, referenced); } }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getString()); Preconditions.checkState(referenced.contains(fnScope.getVar(fnScope.getString()))); Node function = fnScope.getRootNode(); Preconditions.checkState(function.isFunction()); if (NodeUtil.isGetOrSetKey(function.getParent())) { return; } Node argList = getFunctionArgList(function); boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function); if (!modifyCallers) { Node lastArg; while ((lastArg = argList.getLastChild())!= null) { Var var = fnScope.getVar(lastArg.getString()); if (!referenced.contains(var)) { argList.removeChild(lastArg); compiler.reportCodeChange(); } else { break; } } } else { callSiteOptimizer.optimize(fnScope, referenced); } }",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.get",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fnScope.getVar(fnScope.getVar(fn",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fnScope.getVar(fn",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fn",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fn",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fn",
        "private void removeUnreferencedFunctionArgs(Scope fnScope) { /* */ Node referenced = fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fnScope.getVar(fn"
      ]
    },
    "Closure_5_/src/com/google/javascript/jscomp/InlineObjectLiterals.java_176-177": {
      "loc": "176-177",
      "input": "<s> private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ <mask> String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child != null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; } </s> java",
      "function range": "155,5-253,5",
      "output": [
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild() == gramps) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); Preconditions.checkState(parent.getLastChild() == gramps); String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild().isCall()) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild() == gramps) { return false; } } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.getLastChild().isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); Preconditions.checkState(parent.getLastChild() == gramps); String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.getLastChild().isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild().isCall()) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild() == gramps) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { return false; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); Preconditions.checkState(parent.getLastChild() == gramps); String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { return false; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.getLastChild().isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild().isCall()) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } ret = true; } return ret; }",
        "private boolean isInlinableObject(List<Reference> refs) { boolean ret = false; Set<String> validProperties = Sets.newHashSet(); for (Reference ref : refs) { Node name = ref.getNode(); Node parent = ref.getParent(); Node gramps = ref.getGrandparent(); if (parent.isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (gramps.isCall() && gramps.getFirstChild() == parent) { return false; } /* */ } if (parent.getLastChild().isGetProp()) { Preconditions.checkState(parent.getFirstChild() == name); if (parent.getLastChild().isCall()) { return false; } String propName = parent.getLastChild().getString(); if (!validProperties.contains(propName)) { if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) { validProperties.add(propName); } else { return false; } } continue; } if (!isVarOrAssignExprLhs(name)) { return false; } Node val = ref.getAssignedValue(); if (val == null) { continue; } if (!val.isObjectLit()) { return false; } for (Node child = val.getFirstChild(); child!= null; child = child.getNext()) { if (child.isGetterDef() || child.isSetterDef()) { return false; } validProperties.add(child.getString()); Node childVal = child.getFirstChild(); for (Reference t : refs) { Node refNode = t.getParent(); while (!NodeUtil.isStatementBlock(refNode)) { if (refNode == childVal) { return false; } refNode = refNode.getParent(); } } } ret = true; } return ret; } return ret; }"
      ]
    },
    "Closure_10_/src/com/google/javascript/jscomp/NodeUtil.java_1417-1418": {
      "loc": "1417-1418",
      "input": "<s> static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ <mask> } else { return mayBeStringHelper(n); } } </s> java",
      "function range": "1415,3-1421,3",
      "output": [
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ return mayBeStringHelper(n); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ return mayBeStringHelper(n, MAY_BE_STRING_PREDICATE); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ return mayBeStringHelper(n, recurse); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ /* return mayBeStringHelper(n); */ } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ return true; } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ } else if (allResultsMatch(n, MAY_BE_STRING_PREDICATE)) { return mayBeStringHelper(n); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ } else if (mayBeStringHelper(n)) { return mayBeStringHelper(n, true); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ } else if (mayBeStringHelper(n)) { return mayBeStringHelper(n, recurse); } else { return mayBeStringHelper(n); } }",
        "static boolean mayBeString(Node n, boolean recurse) { if (recurse) { /* return allResultsMatch(n, MAY_BE_STRING_PREDICATE); */ } else if (mayBeStringHelper(n)) { return mayBeStringHelper(n); } else { return mayBeStringHelper(n); } }"
      ]
    },
    "Closure_11_/src/com/google/javascript/jscomp/TypeCheck.java_1314-1316": {
      "loc": "1314-1316",
      "input": "<s> private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType() != null && parent.isAssign()) { return; */ <mask> } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); } </s> java",
      "function range": "1303,3-1321,3",
      "output": [
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ checkPropertyAccess(childType, property.getString(), t, n); } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"assign\"); /* } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ checkPropertyAccess(childType, property.getString(), t, n); return; } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"assign\"); } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ } else if (childType.isString()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"string\"); } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"object\"); /* } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"Assign\"); /* } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"object\"); } else if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }",
        "private void visitGetProp(NodeTraversal t, Node n, Node parent) { Node property = n.getLastChild(); Node objNode = n.getFirstChild(); JSType childType = getJSType(objNode); if (childType.isDict()) { report(t, property, TypeValidator.ILLEGAL_PROPERTY_ACCESS, \"'.'\", \"dict\"); /* } else if (n.getJSType()!= null && parent.isAssign()) { return; */ if (validator.expectNotNullOrUndefined(t, n, childType, \"No properties on this expression\", getNativeType(OBJECT_TYPE))) { checkPropertyAccess(childType, property.getString(), t, n); } ensureTyped(t, n); }"
      ]
    },
    "Closure_14_/src/com/google/javascript/jscomp/ControlFlowAnalysis.java_767-768": {
      "loc": "767-768",
      "input": "<s> private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext() != null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa != null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ <mask> } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling != null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling != null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } </s> java",
      "function range": "692,3-789,3",
      "output": [
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ return computeFollowNode(fromNode, parent, cfa); } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } }",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.is",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ break; } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null &&",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ return finallyNode; } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!=",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ return null; } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ return computeFollowNode(fromNode, parent, cfa); } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } return parent; }",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!=",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ } } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null &&",
        "private static Node computeFollowNode( Node fromNode, Node node, ControlFlowAnalysis cfa) { Node parent = node.getParent(); if (parent == null || parent.isFunction() || (cfa!= null && node == cfa.root)) { return null; } switch (parent.getType()) { case Token.IF: return computeFollowNode(fromNode, parent, cfa); case Token.CASE: case Token.DEFAULT_CASE: if (parent.getNext()!= null) { if (parent.getNext().isCase()) { return parent.getNext().getFirstChild().getNext(); } else if (parent.getNext().isDefaultCase()) { return parent.getNext().getFirstChild(); } else { Preconditions.checkState(false, \"Not reachable\"); } } else { return computeFollowNode(fromNode, parent, cfa); } break; case Token.FOR: if (NodeUtil.isForIn(parent)) { return parent; } else { return parent.getFirstChild().getNext().getNext(); } case Token.WHILE: case Token.DO: return parent; case Token.TRY: if (parent.getFirstChild() == node) { if (NodeUtil.hasFinally(parent)) { return computeFallThrough(parent.getLastChild()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (NodeUtil.getCatchBlock(parent) == node){ if (NodeUtil.hasFinally(parent)) { return computeFallThrough(node.getNext()); } else { return computeFollowNode(fromNode, parent, cfa); } } else if (parent.getLastChild() == node){ if (cfa!= null) { for (Node finallyNode : cfa.finallyMap.get(parent)) { /* cfa.createEdge(fromNode, Branch.UNCOND, finallyNode); */ if (finallyNode!= null) { return finallyNode; } } } return computeFollowNode(fromNode, parent, cfa); } } Node nextSibling = node.getNext(); while (nextSibling!= null && nextSibling.isFunction()) { nextSibling = nextSibling.getNext(); } if (nextSibling!= null) { return computeFallThrough(nextSibling); } else { return computeFollowNode(fromNode, parent, cfa); } }"
      ]
    },
    "Closure_15_/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java_102-103": {
      "loc": "102-103",
      "input": "<s> @Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ <mask> for (Node c = n.getFirstChild(); c != null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; } </s> java",
      "function range": "83,7-109,7",
      "output": [
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (ControlFlowGraph.isEnteringNewCfgNode(n)) { return true; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (n.getNext() == null) { return false; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (!ControlFlowGraph.isEnteringNewCfgNode(n)) { return true; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (n.getFirstChild() == null) { return false; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (n.getNext() == null) { return true; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (!ControlFlowGraph.isEnteringNewCfgNode(n)) { return false; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (ControlFlowGraph.isEnteringNewCfgNode(n)) { return false; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (ControlFlowGraph.isEnteringCfgNode(n)) { return true; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) { return true; } } return false; }",
        "@Override public boolean apply(Node n) { if (n == null) { return false; } if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) { return true; } if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) { return true; } /* */ if (ControlFlowGraph.isEnteringNewCfgNode(n)) { return true; } for (Node c = n.getFirstChild(); c!= null; c = c.getNext()) { if (!ControlFlowGraph.isEnteringNewCfgNode(c)) { return true; } } return false; }"
      ]
    },
    "Closure_18_/src/com/google/javascript/jscomp/Compiler.java_1288-1289": {
      "loc": "1288-1289",
      "input": "<s> Node parseInputs() { boolean devMode = options.devMode != DevMode.OFF; if (externsRoot != null) { externsRoot.detachChildren(); } if (jsRoot != null) { jsRoot.detachChildren(); } jsRoot = IR.block(); jsRoot.setIsSyntheticBlock(true); externsRoot = IR.block(); externsRoot.setIsSyntheticBlock(true); externAndJsRoot = IR.block(externsRoot, jsRoot); externAndJsRoot.setIsSyntheticBlock(true); if (options.tracer.isOn()) { tracker = new PerformanceTracker(jsRoot, options.tracer); addChangeHandler(tracker.getCodeChangeHandler()); } Tracer tracer = newTracer(\"parseInputs\"); try { for (CompilerInput input : externs) { Node n = input.getAstRoot(this); if (hasErrors()) { return null; } externsRoot.addChildToBack(n); } if (options.transformAMDToCJSModules || options.processCommonJSModules) { processAMDAndCommonJSModules(); } hoistExterns(externsRoot); boolean staleInputs = false; /* if (options.dependencyOptions.needsManagement() && options.closurePass) { */ <mask> for (CompilerInput input : inputs) { for (String provide : input.getProvides()) { getTypeRegistry().forwardDeclareType(provide); } } try { inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph) .manageDependencies(options.dependencyOptions, inputs); staleInputs = true; } catch (CircularDependencyException e) { report(JSError.make( JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage())); if (hasErrors()) { return null; } } catch (MissingProvideException e) { report(JSError.make( MISSING_ENTRY_ERROR, e.getMessage())); if (hasErrors()) { return null; } } } hoistNoCompileFiles(); if (staleInputs) { repartitionInputs(); } for (CompilerInput input : inputs) { Node n = input.getAstRoot(this); if (n == null) { continue; } if (devMode) { runSanityCheck(); if (hasErrors()) { return null; } } if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) { SourceInformationAnnotator sia = new SourceInformationAnnotator( input.getName(), options.devMode != DevMode.OFF); NodeTraversal.traverse(this, n, sia); } jsRoot.addChildToBack(n); } if (hasErrors()) { return null; } return externAndJsRoot; } finally { stopTracer(tracer, \"parseInputs\"); } } </s> java",
      "function range": "1240,3-1362,3"
    },
    "Closure_20_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_220-221": {
      "loc": "220-221",
      "input": "<s> private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget != null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value != null) { */ <mask> Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; } </s> java",
      "function range": "208,3-230,3",
      "output": [
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ reportCodeChange(); return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return n; } Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ n.getParent().replaceChild(n, value); reportCodeChange(); return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return IR.string(\"\").srcref(callTarget); } Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } else { return n; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } else { return null; } } return n; }",
        "private Node tryFoldSimpleFunctionCall(Node n) { Preconditions.checkState(n.isCall()); Node callTarget = n.getFirstChild(); if (callTarget!= null && callTarget.isName() && callTarget.getString().equals(\"String\")) { Node value = callTarget.getNext(); /* if (value!= null) { */ if (value.isName()) { return value; } else { Node addition = IR.add( IR.string(\"\").srcref(callTarget), value.detachFromParent()); n.getParent().replaceChild(n, addition); reportCodeChange(); return addition; } } return n; } else { return n; } }"
      ]
    },
    "Closure_31_/src/com/google/javascript/jscomp/Compiler.java_1285-1286": {
      "loc": "1285-1286",
      "input": "<s> Node parseInputs() { boolean devMode = options.devMode != DevMode.OFF; if (externsRoot != null) { externsRoot.detachChildren(); } if (jsRoot != null) { jsRoot.detachChildren(); } jsRoot = IR.block(); jsRoot.setIsSyntheticBlock(true); externsRoot = IR.block(); externsRoot.setIsSyntheticBlock(true); externAndJsRoot = IR.block(externsRoot, jsRoot); externAndJsRoot.setIsSyntheticBlock(true); if (options.tracer.isOn()) { tracker = new PerformanceTracker(jsRoot, options.tracer); addChangeHandler(tracker.getCodeChangeHandler()); } Tracer tracer = newTracer(\"parseInputs\"); try { for (CompilerInput input : externs) { Node n = input.getAstRoot(this); if (hasErrors()) { return null; } externsRoot.addChildToBack(n); } if (options.transformAMDToCJSModules || options.processCommonJSModules) { processAMDAndCommonJSModules(); } boolean staleInputs = false; if (options.dependencyOptions.needsManagement() && /* !options.skipAllPasses && */ <mask> options.closurePass) { for (CompilerInput input : inputs) { for (String provide : input.getProvides()) { getTypeRegistry().forwardDeclareType(provide); } } try { inputs = (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph) .manageDependencies(options.dependencyOptions, inputs); staleInputs = true; } catch (CircularDependencyException e) { report(JSError.make( JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage())); if (hasErrors()) { return null; } } catch (MissingProvideException e) { report(JSError.make( MISSING_ENTRY_ERROR, e.getMessage())); if (hasErrors()) { return null; } } } for (CompilerInput input : inputs) { Node n = input.getAstRoot(this); if (n == null) { continue; } if (n.getJSDocInfo() != null) { JSDocInfo info = n.getJSDocInfo(); if (info.isExterns()) { externsRoot.addChildToBack(n); input.setIsExtern(true); input.getModule().remove(input); externs.add(input); staleInputs = true; } else if (info.isNoCompile()) { input.getModule().remove(input); staleInputs = true; } } } if (staleInputs) { fillEmptyModules(modules); rebuildInputsFromModules(); } for (CompilerInput input : inputs) { Node n = input.getAstRoot(this); if (n == null) { continue; } if (devMode) { runSanityCheck(); if (hasErrors()) { return null; } } if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) { SourceInformationAnnotator sia = new SourceInformationAnnotator( input.getName(), options.devMode != DevMode.OFF); NodeTraversal.traverse(this, n, sia); } jsRoot.addChildToBack(n); } if (hasErrors()) { return null; } return externAndJsRoot; } finally { stopTracer(tracer, \"parseInputs\"); } } </s> java",
      "function range": "1236,3-1387,3"
    },
    "Closure_33_/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java_557-558": {
      "loc": "557-558",
      "input": "<s> @Override public void matchConstraint(ObjectType constraintObj) { /* */ <mask> if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE) .getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } } </s> java",
      "function range": "554,3-580,3",
      "output": [
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj!= null) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ super.matchConstraint(constraintObj); if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ super.matchConstraint(constraintObj); if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isObjectType()) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isPropertyType()) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isObjectType()) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj!= null) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isObjectType()) { if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } } }",
        "@Override public void matchConstraint(ObjectType constraintObj) { /* */ if (constraintObj.isRecordType()) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!hasProperty(prop)) { typeToInfer = getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType); } defineInferredProperty(prop, typeToInfer, null); } } } } }"
      ]
    },
    "Closure_35_/src/com/google/javascript/jscomp/TypeInference.java_1121-1136": {
      "loc": "1121-1136",
      "input": "<s> private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj != null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType != null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ <mask> } } </s> java",
      "function range": "1113,3-1137,3",
      "output": [
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ return; } else { return; } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ } else { return; } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ if (constraintObj == null) { return; } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ } else { if (type == null) { return; } } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ } else { if (type == null) { return; } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ for (String prop : constraintObj.getOwnPropertyNames()) { inferPropertyTypesToMatchConstraint(type, constraintObj.getPropertyType(prop)); } } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ if (constraintObj!= null && constraintObj.isRecordType()) { inferPropertyTypesToMatchConstraint(objType, constraintObj); } } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ if (constraintObj!= null && constraintObj.isRecordType()) { inferPropertyTypesToMatchConstraint(type, constraintObj); } } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ for (String prop : constraintObj.getOwnPropertyNames()) { inferPropertyTypesToMatchConstraint(prop, constraintObj.getPropertyType(prop)); } } }",
        "private void inferPropertyTypesToMatchConstraint( JSType type, JSType constraint) { if (type == null || constraint == null) { return; } ObjectType constraintObj = ObjectType.cast(constraint.restrictByNotNullOrUndefined()); /* if (constraintObj!= null && constraintObj.isRecordType()) { ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined()); if (objType!= null) { for (String prop : constraintObj.getOwnPropertyNames()) { JSType propType = constraintObj.getPropertyType(prop); if (!objType.isPropertyTypeDeclared(prop)) { JSType typeToInfer = propType; if (!objType.hasProperty(prop)) { typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(propType); } objType.defineInferredProperty(prop, typeToInfer, null); } } } */ for (String prop : constraintObj.getOwnPropertyNames()) { inferPropertyTypesToMatchConstraint(type, constraintObj.getPropertyType(prop)); } }"
      ]
    },
    "Closure_36_/src/com/google/javascript/jscomp/InlineVariables.java_575-576": {
      "loc": "575-576",
      "input": "<s> private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) || !isValidInitialization(initialization) || !isValidReference(reference)) { return false; } if (declaration != initialization && !initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock() != initialization.getBasicBlock() || declaration.getBasicBlock() != reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value != null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship != null) { return false; } /* } */ <mask> } return canMoveAggressively(value) || canMoveModerately(initialization, reference); } </s> java",
      "function range": "519,5-580,5",
      "output": [
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } else { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ return true; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } if (reference.getParent().getFirstChild() == reference.getNode()) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } else if (reference.getParent().isCall()) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } if (reference.getParent().isCall()) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } if (reference.getParent().getFirstChild() == callNode) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ if (reference.getParent().getFirstChild() == callNode) { return false; } } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ return canMoveAggressively(value) || canMoveModerately(initialization, reference); } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ if (reference.getParent().getFirstChild() == callNode) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization, reference); }",
        "private boolean canInline( Reference declaration, Reference initialization, Reference reference) { if (!isValidDeclaration(declaration) ||!isValidInitialization(initialization) ||!isValidReference(reference)) { return false; } if (declaration!= initialization &&!initialization.getGrandparent().isExprResult()) { return false; } if (declaration.getBasicBlock()!= initialization.getBasicBlock() || declaration.getBasicBlock()!= reference.getBasicBlock()) { return false; } Node value = initialization.getAssignedValue(); Preconditions.checkState(value!= null); if (value.isGetProp() && reference.getParent().isCall() && reference.getParent().getFirstChild() == reference.getNode()) { return false; } if (value.isFunction()) { Node callNode = reference.getParent(); if (reference.getParent().isCall()) { CodingConvention convention = compiler.getCodingConvention(); SubclassRelationship relationship = convention.getClassesDefinedByCall(callNode); if (relationship!= null) { return false; } /* } */ } if (reference.getParent().isCall()) { return false; } return canMoveAggressively(value) || canMoveModerately(initialization) || canMoveModerately(reference); }"
      ]
    },
    "Closure_38_/src/com/google/javascript/jscomp/CodeConsumer.java_245-246": {
      "loc": "245-246",
      "input": "<s> void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ <mask> add(\" \"); } if ((long) x == x && !negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } } </s> java",
      "function range": "240,3-267,3",
      "output": [
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\"-\"); } else { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" - \"); } else if (x > 0 && prev == '+') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\"-\"); } else if (x > 0 && prev == '+') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" -\"); } else if (x > 0 && prev == '+') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" - \"); } if (x > 0 && prev == '+') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" - \"); } else if (x > 0 && prev == '1' &&!negativeZero) { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(String.valueOf(x)); } else { add(String.valueOf(x)); } if (x < 0 && prev == '-') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(String.valueOf(x)); } else { add(String.valueOf(prev)); } if (x == 0 &&!negativeZero) { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x)); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" - \"); } else if (x > 0 && prev == '+') { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x); } }",
        "void addNumber(double x) { char prev = getLastChar(); boolean negativeZero = isNegativeZero(x); /* if (x < 0 && prev == '-') { */ add(\" - \"); } else if (x > 0 && prev == '1' &&!negativeZero) { add(\" \"); } if ((long) x == x &&!negativeZero) { long value = (long) x; long mantissa = value; int exp = 0; if (Math.abs(x) >= 100) { while (mantissa / 10 * Math.pow(10, exp + 1) == value) { mantissa /= 10; exp++; } } if (exp > 2) { add(Long.toString(mantissa) + \"E\" + Integer.toString(exp)); } else { add(Long.toString(value)); } } else { add(String.valueOf(x); } }"
      ]
    },
    "Closure_52_/src/com/google/javascript/jscomp/CodeGenerator.java_745-746": {
      "loc": "745-746",
      "input": "<s> static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ <mask> } </s> java",
      "function range": "737,3-746,3",
      "output": [
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return true; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return s.length() == len; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return len == s.length(); }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return s.length() > 0; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return false; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return s.length() > len; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ if (len == 0) { return true; } return false; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return s.length() == len - 1; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return len == s.length() - 1; }",
        "static boolean isSimpleNumber(String s) { int len = s.length(); for (int index = 0; index < len; index++) { char c = s.charAt(index); if (c < '0' || c > '9') { return false; } } /* return len > 0; */ return s.length() == len - 1 ; }"
      ]
    },
    "Closure_55_/src/com/google/javascript/jscomp/FunctionRewriter.java_117-118": {
      "loc": "117-118",
      "input": "<s> private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ <mask> } </s> java",
      "function range": "116,3-118,3",
      "output": [
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableFunctionExpression; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return false; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return true; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableFunctionNode; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableFunctionExpressionNode; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableFunctionExpression ; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableNode; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return NodeUtil.isReduceableFunctionExpression(n); }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return n instanceof ReduceableFunctionExpressionNode ; }",
        "private static boolean isReduceableFunctionExpression(Node n) { /* return NodeUtil.isFunctionExpression(n); */ return NodeUtil.isFunctionExpression(n); }"
      ]
    },
    "Closure_57_/src/com/google/javascript/jscomp/ClosureCodingConvention.java_197-198": {
      "loc": "197-198",
      "input": "<s> private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee != null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target != null) { */ <mask> className = target.getString(); } } } } return className; } </s> java",
      "function range": "188,3-204,3",
      "output": [
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.STRING) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.NAME) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.TEXT) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.GETPROP) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.CALL) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getNodeType() == Token.STRING) { className = target.getString(); } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.STRING) { className = target.getString(); } } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.NAME) { className = target.getString(); } } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getType() == Token.TEXT) { className = target.getString(); } } } } } return className; }",
        "private static String extractClassNameIfGoog(Node node, Node parent, String functionName){ String className = null; if (NodeUtil.isExprCall(parent)) { Node callee = node.getFirstChild(); if (callee!= null && callee.getType() == Token.GETPROP) { String qualifiedName = callee.getQualifiedName(); if (functionName.equals(qualifiedName)) { Node target = callee.getNext(); /* if (target!= null) { */ if (target.getNodeType() == Token.TEXT) { className = target.getString(); } } } } return className; }"
      ]
    },
    "Closure_59_/src/com/google/javascript/jscomp/Compiler.java_255-256": {
      "loc": "255-256",
      "input": "<s> public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ <mask> options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols && !composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; } </s> java",
      "function range": "226,3-288,3",
      "output": [
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } else { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOff()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } else if (options.checkGlobalThisLevel.isOff()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } else if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOff()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } */ if (options.checkGlobalThisLevel.isOff()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.OFF); } if (options.checkGlobalThisLevel.isOn()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } if (options.checkGlobalThisLevel.isOff()) { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }",
        "public void initOptions(CompilerOptions options) { this.options = options; if (errorManager == null) { if (outStream == null) { setErrorManager( new LoggerErrorManager(createMessageFormatter(), logger)); } else { PrintStreamErrorManager printer = new PrintStreamErrorManager(createMessageFormatter(), outStream); printer.setSummaryDetailLevel(options.summaryDetailLevel); setErrorManager(printer); } } if (options.enables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = true; } else if (options.disables(DiagnosticGroups.CHECK_TYPES)) { options.checkTypes = false; } else if (!options.checkTypes) { options.setWarningLevel( DiagnosticGroup.forType( RhinoErrorReporter.TYPE_PARSE_ERROR), CheckLevel.OFF); } /* if (options.checkGlobalThisLevel.isOn()) { */ options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, CheckLevel.ON); } else { options.setWarningLevel( DiagnosticGroups.GLOBAL_THIS, options.checkGlobalThisLevel); } if (options.getLanguageIn() == LanguageMode.ECMASCRIPT5_STRICT) { options.setWarningLevel( DiagnosticGroups.ES5_STRICT, CheckLevel.ERROR); } List<WarningsGuard> guards = Lists.newArrayList(); guards.add( new SuppressDocWarningsGuard( getDiagnosticGroups().getRegisteredGroups())); guards.add(options.getWarningsGuard()); ComposeWarningsGuard composedGuards = new ComposeWarningsGuard(guards); if (!options.checkSymbols &&!composedGuards.enables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.ON)); } if (options.checkSymbols &&!composedGuards.disables(DiagnosticGroups.CHECK_VARIABLES)) { composedGuards.addGuard(new DiagnosticGroupWarningsGuard( DiagnosticGroups.CHECK_VARIABLES, CheckLevel.OFF)); } this.warningsGuard = composedGuards; }"
      ]
    },
    "Closure_62_/src/com/google/javascript/jscomp/LightweightMessageFormatter.java_98-99": {
      "loc": "98-99",
      "input": "<s> private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null ? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName != null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning ? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt != null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ <mask> for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); } </s> java",
      "function range": "66,3-111,3",
      "output": [
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(sourceExcerpt); b.append('\\n'); } else { b.append(excerpt); b.append('\\n'); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(sourceExcerpt); b.append('\\n'); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); } if (sourceExcerpt!= null) { b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); } if (sourceExcerpt.length() > charno) { b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); for (int i = 0; i < charno; i++) { char c = sourceExcerpt.charAt(i); if (Character.isWhitespace(c)) { b.append(c); } else { b.append(' '); } } b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); } } return b.toString(); }",
        "private String format(JSError error, boolean warning) { SourceExcerptProvider source = getSource(); String sourceExcerpt = source == null? null : excerpt.get( source, error.sourceName, error.lineNumber, excerptFormatter); StringBuilder b = new StringBuilder(); if (error.sourceName!= null) { b.append(error.sourceName); if (error.lineNumber > 0) { b.append(':'); b.append(error.lineNumber); } b.append(\": \"); } b.append(getLevelName(warning? CheckLevel.WARNING : CheckLevel.ERROR)); b.append(\" - \"); b.append(error.description); b.append('\\n'); if (sourceExcerpt!= null) { b.append(sourceExcerpt); b.append('\\n'); int charno = error.getCharno(); if (excerpt.equals(LINE) /* && 0 <= charno && charno < sourceExcerpt.length()) { */ b.append(\"^\\n\"); } else { b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); b.append(\"^\\n\"); } } return b.toString(); }"
      ]
    },
    "Closure_65_/src/com/google/javascript/jscomp/CodeGenerator.java_1015-1016": {
      "loc": "1015-1016",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ <mask> case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "function range": "1005,3-1075,3",
      "output": [
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\r': sb.append(\"\\\\r\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\f': sb.append(\"\\\\f\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\b': sb.append(\"\\\\b\"); break; case '\\f': sb.append(\"\\\\f\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\t': sb.append(\"\\\\t\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\n': sb.append(\"\\\\n\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\b': sb.append(\"\\\\b\"); break; case '\\c': sb.append(\"\\\\c\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { /* case '\\0': sb.append(\"\\\\0\"); break; */ case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { if (c > 0x1f && c < 0x7f) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } sb.append(c); } sb.append(quote); return sb.toString(); }"
      ]
    },
    "Closure_67_/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java_318-319": {
      "loc": "318-319",
      "input": "<s> private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ <mask> boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; } </s> java",
      "function range": "314,5-334,5",
      "output": [
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } else { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ if (n.getFirstChild().getType() == Token.STRING) { return true; } boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } else if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) ) { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) ) { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ if (n.getFirstChild().getType() == Token.STRING && n.getFirstChild().getNext().getType() == Token.STRING) { return true; } boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } else if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.STRING) { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ if (n.getFirstChild().getType() == Token.STRING) { return true; } boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\" prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ return true; } if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP) { boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString()).equals(\"prototype\")) { return true; } } } return false; }",
        "private boolean isPrototypePropertyAssign(Node assign) { Node n = assign.getFirstChild(); if (n!= null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP /* ) { */ if (n.getFirstChild().getType() == Token.STRING && n.getFirstChild().getNext().getType() == Token.STRING) { return true; } boolean isChainedProperty = n.getFirstChild().getType() == Token.GETPROP; if (isChainedProperty) { Node child = n.getFirstChild().getFirstChild().getNext(); if (child.getType() == Token.STRING && child.getString().equals(\" prototype\")) { return true; } } } return false; }"
      ]
    },
    "Closure_70_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1745-1746": {
      "loc": "1745-1746",
      "input": "<s> private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType != null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters != null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter != null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ <mask> jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } </s> java",
      "function range": "1734,5-1753,5",
      "output": [
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } if (jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } if (jsDocParameter.getNext()!= null && jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } else if (body!= null) { defineSlot(body, functionNode, null, true); } jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } else if (body!= null) { defineSlot(body, functionNode, null, true); } jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } } if (jsDocParameter!= null && jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } } if (jsDocParameter!= null && jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } if (jsDocParameter.getNext()!= null && jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } else if (body!= null) { defineSlot(body, functionNode, null, true); } jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } } if (jsDocParameter!= null && jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } }",
        "private void declareArguments(Node functionNode) { Node astParameters = functionNode.getFirstChild().getNext(); Node body = astParameters.getNext(); FunctionType functionType = (FunctionType) functionNode.getJSType(); if (functionType!= null) { Node jsDocParameters = functionType.getParametersNode(); if (jsDocParameters!= null) { Node jsDocParameter = jsDocParameters.getFirstChild(); for (Node astParameter : astParameters.children()) { if (jsDocParameter!= null) { defineSlot(astParameter, functionNode, /* jsDocParameter.getJSType(), true); */ } if (jsDocParameter.getNext()!= null) { jsDocParameter = jsDocParameter.getNext(); } else { defineSlot(astParameter, functionNode, null, true); } } } } } }"
      ]
    },
    "Closure_71_/src/com/google/javascript/jscomp/CheckAccessControls.java_416-417": {
      "loc": "416-417",
      "input": "<s> private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) { ObjectType objectType = ObjectType.cast(dereference(getprop.getFirstChild().getJSType())); String propertyName = getprop.getLastChild().getString(); if (objectType != null) { /* boolean isOverride = t.inGlobalScope() && */ <mask> parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop; if (isOverride) { objectType = objectType.getImplicitPrototype(); } JSDocInfo docInfo = null; for (; objectType != null; objectType = objectType.getImplicitPrototype()) { docInfo = objectType.getOwnPropertyJSDocInfo(propertyName); if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) { break; } } if (objectType == null) { return; } boolean sameInput = t.getInput().getName().equals(docInfo.getSourceName()); Visibility visibility = docInfo.getVisibility(); JSType ownerType = normalizeClassType(objectType); if (isOverride) { JSDocInfo overridingInfo = parent.getJSDocInfo(); Visibility overridingVisibility = overridingInfo == null ? Visibility.INHERITED : overridingInfo.getVisibility(); if (visibility == Visibility.PRIVATE && !sameInput) { compiler.report( t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString())); } else if (overridingVisibility != Visibility.INHERITED && overridingVisibility != visibility) { compiler.report( t.makeError(getprop, VISIBILITY_MISMATCH, visibility.name(), objectType.toString(), overridingVisibility.name())); } } else { if (sameInput) { return; } else if (visibility == Visibility.PRIVATE && (currentClass == null || ownerType.differsFrom(currentClass))) { if (docInfo.isConstructor() && isValidPrivateConstructorAccess(parent)) { return; } compiler.report( t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName( getprop.getFirstChild(), true))); } else if (visibility == Visibility.PROTECTED) { if (currentClass == null || !currentClass.isSubtype(ownerType)) { compiler.report( t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName, validator.getReadableJSTypeName( getprop.getFirstChild(), true))); } } } } } </s> java",
      "function range": "407,3-500,3"
    },
    "Closure_73_/src/com/google/javascript/jscomp/CodeGenerator.java_1045-1046": {
      "loc": "1045-1046",
      "input": "<s> static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder != null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ <mask> sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); } </s> java",
      "function range": "988,3-1058,3",
      "output": [
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { sb.append(c); } } else { sb.append(c); } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { sb.append(c); } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { sb.append(c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } sb.append(c); } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } } sb.append(c); } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { sb.append(c); } } } sb.append(quote); sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { sb.append(c); } } else { sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); } } } sb.append(quote); return sb.toString(); }",
        "static String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape, String backslashEscape, CharsetEncoder outputCharsetEncoder) { StringBuilder sb = new StringBuilder(s.length() + 2); sb.append(quote); for (int i = 0; i < s.length(); i++) { char c = s.charAt(i); switch (c) { case '\\0': sb.append(\"\\\\0\"); break; case '\\n': sb.append(\"\\\\n\"); break; case '\\r': sb.append(\"\\\\r\"); break; case '\\t': sb.append(\"\\\\t\"); break; case '\\\\': sb.append(backslashEscape); break; case '\\\"': sb.append(doublequoteEscape); break; case '\\'': sb.append(singlequoteEscape); break; case '>': if (i >= 2 && ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') || (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) { sb.append(\"\\\\>\"); } else { sb.append(c); } break; case '<': final String END_SCRIPT = \"/script\"; final String START_COMMENT = \"!--\"; if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) { sb.append(\"<\\\\\"); } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) { sb.append(\"<\\\\\"); } else { sb.append(c); } break; default: if (outputCharsetEncoder!= null) { if (outputCharsetEncoder.canEncode(c)) { sb.append(c); } else { appendHexJavaScriptRepresentation(sb, c); } } else { /* if (c > 0x1f && c <= 0x7f) { */ sb.append(c); } else { sb.append(c); } } else { sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); sb.append(c); } } } sb.append(quote); return sb.toString(); }"
      ]
    },
    "Closure_82_/src/com/google/javascript/rhino/jstype/JSType.java_163-164": {
      "loc": "163-164",
      "input": "<s> public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ <mask> } </s> java",
      "function range": "162,3-164,3",
      "output": [
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return false ; }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return true ; }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return super. isEmptyType(); }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return isNoResolvedType(); }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return false; }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return isEmptyType(); }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return true; }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return isNoType(); }",
        "public final boolean isEmptyType() { /* return isNoType() || isNoObjectType() || isNoResolvedType(); */ return isNoObjectType(); }"
      ]
    },
    "Closure_83_/src/com/google/javascript/jscomp/CommandLineRunner.java_334-335": {
      "loc": "334-335",
      "input": "<s> @Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ <mask> if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } } </s> java",
      "function range": "332,7-351,7",
      "output": [
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ Setter setter = new Setter(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ ParameterSetter setter = new ParameterSetter(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ Setter<Boolean> setter = new Setter<Boolean>(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ ValueSetter setter = new ValueSetter(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ if (param == null) { setter.addValue(false); return 0; } else if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ if (param == null) { setter.addValue(false); return 1; } else if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1; } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ Setter setter = new Setter(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1 } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ Setter<Boolean> setter = new Setter<Boolean>(); if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 0; } return 1 } }",
        "@Override public int parseArguments(Parameters params) throws CmdLineException { /* String param = params.getParameter(0); */ if (param == null) { setter.addValue(false); return 0; } else if (param == null) { setter.addValue(true); return 0; } else { String lowerParam = param.toLowerCase(); if (TRUES.contains(lowerParam)) { setter.addValue(true); } else if (FALSES.contains(lowerParam)) { setter.addValue(false); } else { setter.addValue(true); return 1; } return 1; } }"
      ]
    },
    "Closure_86_/src/com/google/javascript/jscomp/NodeUtil.java_2465-2466": {
      "loc": "2465-2466",
      "input": "<s> static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ <mask> case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } } </s> java",
      "function range": "2424,3-2489,3",
      "output": [
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ return isImmutableValue(value) || locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ return evaluatesToLocalValue(value.getFirstChild(), locals); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return false; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:\" + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + '\\n parent:\" + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } return false; } } else { return false; } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:' + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ return isImmutableValue(value) || locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:' + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ return evaluatesToLocalValue(value.getFirstChild(), locals); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + \"\\n parent:' + value.getParent()); } }",
        "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) { switch (value.getType()) { case Token.ASSIGN: return NodeUtil.isImmutableValue(value.getLastChild()) || (locals.apply(value) && evaluatesToLocalValue(value.getLastChild(), locals)); case Token.COMMA: return evaluatesToLocalValue(value.getLastChild(), locals); case Token.AND: case Token.OR: return evaluatesToLocalValue(value.getFirstChild(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.HOOK: return evaluatesToLocalValue(value.getFirstChild().getNext(), locals) && evaluatesToLocalValue(value.getLastChild(), locals); case Token.INC: case Token.DEC: if (value.getBooleanProp(Node.INCRDECR_PROP)) { return evaluatesToLocalValue(value.getFirstChild(), locals); } else { return true; } case Token.THIS: return locals.apply(value); case Token.NAME: return isImmutableValue(value) || locals.apply(value); case Token.GETELEM: case Token.GETPROP: return locals.apply(value); case Token.CALL: return callHasLocalResult(value) || isToStringMethodCall(value) || locals.apply(value); case Token.NEW: /* return true; */ return isImmutableValue(value) || locals.apply(value); case Token.FUNCTION: case Token.REGEXP: case Token.ARRAYLIT: case Token.OBJECTLIT: return true; case Token.IN: return true; default: if (isAssignmentOp(value) || isSimpleOperator(value) || isImmutableValue(value)) { return true; } throw new IllegalStateException( \"Unexpected expression node\" + value + '\\n parent:\" + value.getParent()); } }"
      ]
    },
    "Closure_92_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_789-790": {
      "loc": "789-790",
      "input": "<s> void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition != null && explicitNode != null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ <mask> if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule) .addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode != null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } } </s> java",
      "function range": "747,5-809,5",
      "output": [
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).removeChild(replacementNode); } else if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(firstNode); } else if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ int indexOfDot = namespace.indexOf('.', indexOfDot); if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent();",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(0, indexOfDot)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildBefore( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }",
        "void replace() { if (firstNode == null) { replacementNode = candidateDefinition; return; } if (candidateDefinition!= null && explicitNode!= null) { explicitNode.detachFromParent(); compiler.reportCodeChange(); replacementNode = candidateDefinition; if (NodeUtil.isExpressionNode(candidateDefinition)) { candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true); Node assignNode = candidateDefinition.getFirstChild(); Node nameNode = assignNode.getFirstChild(); if (nameNode.getType() == Token.NAME) { Node valueNode = nameNode.getNext(); assignNode.removeChild(nameNode); assignNode.removeChild(valueNode); nameNode.addChildToFront(valueNode); Node varNode = new Node(Token.VAR, nameNode); varNode.copyInformationFrom(candidateDefinition); candidateDefinition.getParent().replaceChild( candidateDefinition, varNode); nameNode.setJSDocInfo(assignNode.getJSDocInfo()); compiler.reportCodeChange(); replacementNode = varNode; } } } else { replacementNode = createDeclarationNode(); if (firstModule == minimumModule) { firstNode.getParent().addChildBefore(replacementNode, firstNode); } else { /* int indexOfDot = namespace.indexOf('.'); */ if (indexOfDot == -1) { compiler.getNodeForCodeInsertion(minimumModule).addChildToBack(replacementNode); } else { ProvidedName parentName = providedNames.get(namespace.substring(indexOfDot + 1)); Preconditions.checkNotNull(parentName); Preconditions.checkNotNull(parentName.replacementNode); parentName.replacementNode.getParent().addChildAfter( replacementNode, parentName.replacementNode); } } if (explicitNode!= null) { explicitNode.detachFromParent(); } compiler.reportCodeChange(); } }"
      ]
    },
    "Closure_97_/src/com/google/javascript/jscomp/PeepholeFoldConstants.java_698-699": {
      "loc": "698-699",
      "input": "<s> private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt != lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt != rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ <mask> break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } </s> java",
      "function range": "652,3-713,3",
      "output": [
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ break; case Token.SHIFT: result = lvalInt & rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; case Token.SHIFT: result = lvalInt << rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ break; case Token.SHIFT: result = lvalInt << rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; case Token.SHIFT: result = lvalInt | rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ break; case Token.SHIFT: result = lvalInt & rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ break; case Token.SHIFT: result = lvalInt << rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; case Token.SHIFT: result = lvalInt << rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } return n; }",
        "private Node tryFoldShift(Node n, Node left, Node right) { if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) { double result; double lval = left.getDouble(); double rval = right.getDouble(); if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) { error(BITWISE_OPERAND_OUT_OF_RANGE, left); return n; } if (!(rval >= 0 && rval < 32)) { error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right); return n; } int lvalInt = (int) lval; if (lvalInt!= lval) { error(FRACTIONAL_BITWISE_OPERAND, left); return n; } int rvalInt = (int) rval; if (rvalInt!= rval) { error(FRACTIONAL_BITWISE_OPERAND, right); return n; } switch (n.getType()) { case Token.LSH: result = lvalInt << rvalInt; break; case Token.RSH: result = lvalInt >> rvalInt; break; case Token.URSH: /* result = lvalInt >>> rvalInt; */ result = lvalInt & rvalInt; break; case Token.SHIFT: result = lvalInt | rvalInt; break; default: throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType())); } Node newNumber = Node.newNumber(result); n.getParent().replaceChild(n, newNumber); reportCodeChange(); return newNumber; } return n; } return n; }"
      ]
    },
    "Closure_104_/src/com/google/javascript/rhino/jstype/UnionType.java_291-292": {
      "loc": "291-292",
      "input": "<s> JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result != null) { */ <mask> return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } </s> java",
      "function range": "273,3-298,3",
      "output": [
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } return result; } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } */ return result; }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } */ return result; }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } return result; }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } */ return result; }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } */ return result.type; }",
        "JSType meet(JSType that) { UnionTypeBuilder builder = new UnionTypeBuilder(registry); for (JSType alternate : alternates) { if (alternate.isSubtype(that)) { builder.addAlternate(alternate); } } if (that instanceof UnionType) { for (JSType otherAlternate : ((UnionType) that).alternates) { if (otherAlternate.isSubtype(this)) { builder.addAlternate(otherAlternate); } } } else if (that.isSubtype(this)) { builder.addAlternate(that); } JSType result = builder.build(); /* if (result!= null) { */ if (this.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else if (that.isObject() && that.isObject()) { return getNativeType(JSTypeNative.NO_OBJECT_TYPE); } else { return getNativeType(JSTypeNative.NO_TYPE); } } */ return result.isSubtype(that); }"
      ]
    },
    "Closure_109_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_1908-1909": {
      "loc": "1908-1909",
      "input": "<s> private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ <mask> } </s> java",
      "function range": "1907,3-1909,3",
      "output": [
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return token. getFirstChild ( ) ; }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return null; }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeExpression(token); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeName(token); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return token. getFirstChild(); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeName(token.value); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeExpression(token.value); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeName(token. getQualifiedName()); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeName(token.getTokenValue()); }",
        "private Node parseContextTypeExpression(JsDocToken token) { /* return parseTypeName(token); */ return parseTypeExpression(token.getToken()); }"
      ]
    },
    "Closure_111_/src/com/google/javascript/jscomp/type/ClosureReverseAbstractInterpreter.java_54-55": {
      "loc": "54-55",
      "input": "<s> @Override protected JSType caseTopType(JSType topType) { /* return topType; */ <mask> } </s> java",
      "function range": "52,9-55,9",
      "output": [
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return topType; }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return null; }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return this; }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return this.topType; }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return new JSType (topType); }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return topType; } }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return this.getTopType(); }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return topType.getJSType(); }",
        "@Override protected JSType caseTopType(JSType topType) { /* return topType; */ return topType; } } }",
        "; }"
      ]
    },
    "Closure_113_/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java_329-330": {
      "loc": "329-330",
      "input": "<s> private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null || !provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph != null && module != providedModule && !moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided != null) { */ <mask> parent.detachFromParent(); compiler.reportCodeChange(); } } } </s> java",
      "function range": "295,3-334,3",
      "output": [
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); } else { compiler.reportCodeChange(); } } else { if (parent!= null) { parent.detachFromParent(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ if (provided.isExplicitlyProvided()) { compiler.reportCodeChange(); } else { compiler.reportCodeChange(); } } else { parent.detachFromParent(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } else { compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); } else { compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } else { compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); } else { compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } else { compiler.reportCodeChange(); compiler.reportCodeChange(); } } }",
        "private void processRequireCall(NodeTraversal t, Node n, Node parent) { Node left = n.getFirstChild(); Node arg = left.getNext(); if (verifyLastArgumentIsString(t, left, arg)) { String ns = arg.getString(); ProvidedName provided = providedNames.get(ns); if (provided == null ||!provided.isExplicitlyProvided()) { unrecognizedRequires.add( new UnrecognizedRequire(n, ns, t.getSourceName())); } else { JSModule providedModule = provided.explicitModule; Preconditions.checkNotNull(providedModule); JSModule module = t.getModule(); if (moduleGraph!= null && module!= providedModule &&!moduleGraph.dependsOn(module, providedModule)) { compiler.report( t.makeError(n, XMODULE_REQUIRE_ERROR, ns, providedModule.getName(), module.getName())); } } maybeAddToSymbolTable(left); maybeAddStringNodeToSymbolTable(arg); /* if (provided!= null) { */ compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); compiler.reportCodeChange(); } */ } }"
      ]
    },
    "Closure_114_/src/com/google/javascript/jscomp/NameAnalyzer.java_578-579": {
      "loc": "578-579",
      "input": "<s> private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns != null) { if (parent.isFor() && !NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext() != n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ <mask> recordDepScope(recordNode, ns); } } } </s> java",
      "function range": "558,5-588,5",
      "output": [
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ if (parent.getFirstChild().getNext()!= n) { recordDepScope(nameNode, ns); } else { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ } } else { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ } else { recordDepScope(nameNode, ns); } } else { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ } if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ } else { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ recordDepScope(nameNode, ns); } } else { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ } if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } } } }",
        "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) { Node nameNode = n.getFirstChild(); Node parent = n.getParent(); NameInformation ns = createNameInformation(t, nameNode); if (ns!= null) { if (parent.isFor() &&!NodeUtil.isForIn(parent)) { if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } else { recordDepScope(nameNode, ns); } /* } else { */ if (parent.getFirstChild().getNext()!= n) { recordDepScope(recordNode, ns); } } }"
      ]
    },
    "Closure_118_/src/com/google/javascript/jscomp/DisambiguateProperties.java_495-496": {
      "loc": "495-496",
      "input": "<s> private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child != null; child = child.getNext()) { /* */ <mask> String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null ? \"null\" : type.toString()), n.toString(), \"\")); } } } } </s> java",
      "function range": "490,5-513,5",
      "output": [
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child == null) { continue; } String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.isName()) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.isObject()) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.getNodeType() == Token.STRING) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.getType() == null) { continue; } String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.getNodeType() == Node.STRING) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.isName()) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.isObject()) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } } } }",
        "private void handleObjectLit(NodeTraversal t, Node n) { for (Node child = n.getFirstChild(); child!= null; child = child.getNext()) { /* */ if (child.isName()) { String name = child.getString(); T type = typeSystem.getType(getScope(), n, name); Property prop = getProperty(name); if (!prop.scheduleRenaming(child, processProperty(t, prop, type, null))) { if (propertiesToErrorFor.containsKey(name)) { compiler.report(JSError.make( t.getSourceName(), child, propertiesToErrorFor.get(name), Warnings.INVALIDATION, name, (type == null? \"null\" : type.toString()), n.toString(), \"\")); } } }"
      ]
    },
    "Closure_120_/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java_431-432": {
      "loc": "431-432",
      "input": "<s> boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) { if (block.isFunction) { /* break; */ <mask> } else if (block.isLoop) { return false; } } return true; } </s> java",
      "function range": "421,5-438,5",
      "output": [
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isAssignment) { return false; } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isAssignment) { return true; } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ return true; } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isAssignment) { /* continue; */ } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isVariable) { return false; } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isVariable) { /* break; */ } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isAssignment) { /* return true; */ } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isVariable) { /* continue; */ } else if (block.isLoop) { return false; } } return true; }",
        "boolean isAssignedOnceInLifetime() { Reference ref = getOneAndOnlyAssignment(); if (ref == null) { return false; } for (BasicBlock block = ref.getBasicBlock(); block!= null; block = block.getParent()) { if (block.isFunction) { /* break; */ } else if (block.isAssignment) { /* break; */ } else if (block.isLoop) { return false; } } return true; }"
      ]
    },
    "Closure_122_/src/com/google/javascript/jscomp/parsing/IRFactory.java_252-253": {
      "loc": "252-253",
      "input": "<s> private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\") != -1 || comment.getValue().indexOf(\"\\n * @\") != -1) { */ <mask> errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } } </s> java",
      "function range": "251,3-258,3",
      "output": [
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ } else { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } else { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.error( SUSPICIOUS_COMMENT_ERROR, sourceName, comment.getLineno(), \"\", 0); } else { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.warning( SUSPICIOUS_COMMENT_ERROR, sourceName, comment.getLineno(), \"\", 0); } else { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ if (errorReporter!= null) { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ String sourceName = comment.getValue(); errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.error( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } else { errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ String sourceName = comment.getValue().substring(0, comment.getValue().length()-1); errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.error( SUSPICIOUS_COMMENT_ERROR, sourceName, comment.getLineno(), \"\", 0); } else { errorReporter.error( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }",
        "private void handleBlockComment(Comment comment) { /* if (comment.getValue().indexOf(\"/* @\")!= -1 || comment.getValue().indexOf(\"\\n * @\")!= -1) { */ errorReporter.warning( SUSPICIOUS_COMMENT_WARNING, sourceName, comment.getLineno(), \"\", 0); } }"
      ]
    },
    "Closure_125_/src/com/google/javascript/jscomp/TypeCheck.java_1661-1662": {
      "loc": "1661-1662",
      "input": "<s> private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType != null) { */ <mask> visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } } </s> java",
      "function range": "1656,3-1671,3",
      "output": [
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitConstructor(t, n, fnType); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ report(t, n, NOT_A_CONSTRUCTOR); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ if (fnType.isConstructor()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitConstructor(t, n, fnType); ensureTyped(t, n, fnType); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitConstructor(t, n, fnType); ensureTyped(t, n, fnType.getConstructorType()); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitConstructor(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getConstructorType()); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ report(t, n, NOT_A_CONSTRUCTOR); visitParameterList(t, n, fnType); ensureTyped(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } }",
        "private void visitNew(NodeTraversal t, Node n) { Node constructor = n.getFirstChild(); JSType type = getJSType(constructor).restrictByNotNullOrUndefined(); if (type.isConstructor() || type.isEmptyType() || type.isUnknownType()) { FunctionType fnType = type.toMaybeFunctionType(); /* if (fnType!= null) { */ if (fnType.isConstructor()) { visitParameterList(t, n, fnType); ensureTyped(t, n, fnType.getInstanceType()); } else { ensureTyped(t, n); } } else { report(t, n, NOT_A_CONSTRUCTOR); ensureTyped(t, n); } } }"
      ]
    },
    "Closure_126_/src/com/google/javascript/jscomp/MinimizeExitPoints.java_141-145": {
      "loc": "141-145",
      "input": "<s> void tryMinimizeExits(Node n, int exitType, String labelName) { if (matchingExitNode(n, exitType, labelName)) { NodeUtil.removeChild(n.getParent(), n); compiler.reportCodeChange(); return; } if (n.isIf()) { Node ifBlock = n.getFirstChild().getNext(); tryMinimizeExits(ifBlock, exitType, labelName); Node elseBlock = ifBlock.getNext(); if (elseBlock != null) { tryMinimizeExits(elseBlock, exitType, labelName); } return; } if (n.isTry()) { Node tryBlock = n.getFirstChild(); tryMinimizeExits(tryBlock, exitType, labelName); Node allCatchNodes = NodeUtil.getCatchBlock(n); if (NodeUtil.hasCatchHandler(allCatchNodes)) { Preconditions.checkState(allCatchNodes.hasOneChild()); Node catchNode = allCatchNodes.getFirstChild(); Node catchCodeBlock = catchNode.getLastChild(); tryMinimizeExits(catchCodeBlock, exitType, labelName); } /* if (NodeUtil.hasFinally(n)) { Node finallyBlock = n.getLastChild(); tryMinimizeExits(finallyBlock, exitType, labelName); } */ <mask> } if (n.isLabel()) { Node labelBlock = n.getLastChild(); tryMinimizeExits(labelBlock, exitType, labelName); } if (!n.isBlock() || n.getLastChild() == null) { return; } for (Node c : n.children()) { if (c.isIf()) { Node ifTree = c; Node trueBlock, falseBlock; trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName); trueBlock = ifTree.getFirstChild().getNext(); falseBlock = trueBlock.getNext(); if (falseBlock != null) { tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName); } } if (c == n.getLastChild()) { break; } } for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) { tryMinimizeExits(c, exitType, labelName); if (c == n.getLastChild()) { break; } } } </s> java",
      "function range": "106,3-201,3"
    },
    "Closure_129_/src/com/google/javascript/jscomp/PrepareAst.java_166-167": {
      "loc": "166-167",
      "input": "<s> private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ <mask> if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } } </s> java",
      "function range": "158,5-177,5",
      "output": [
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first == null) { return; } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName() && \"call\".equals(first.getString())) { n.putBooleanProp(Node.CALL, true); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ Preconditions.checkState(first.isName()); if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName()) { n.putBooleanProp(Node.FREE_CALL, true); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName()) { n.putBooleanProp(Node.CALL, true); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ n.putBooleanProp(Node.FREE_CALL, false); if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName() && \"call\".equals(first.getString())) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName() && \"call\".equals(first.getString())) { n.putBooleanProp(Node.CALL, true); } if (!NodeUtil.isGet(first)) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } }",
        "private void annotateCalls(Node n) { Preconditions.checkState(n.isCall()); Node first = n.getFirstChild(); /* */ if (first.isName() && \"call\".equals(first.getString())) { n.putBooleanProp(Node.FREE_CALL, true); } if (first.isName() && \"eval\".equals(first.getString())) { first.putBooleanProp(Node.DIRECT_EVAL, true); } if (n.isCall()) { n.putBooleanProp(Node.FREE_CALL, true); } }"
      ]
    },
    "Closure_130_/src/com/google/javascript/jscomp/CollapseProperties.java_172-173": {
      "loc": "172-173",
      "input": "<s> private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ <mask> name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) { workList.addAll(name.props); } } } </s> java",
      "function range": "161,3-197,3",
      "output": [
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets > 0 && name.localSets > 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets > 1 && name.localSets > 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets == 1 && name.localSets == 1 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.aliasingSets > 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets > 1 && name.localSets > 1 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ name.aliasingGets == 0 && name.props!= null && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets > 0 && name.localSets == 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.aliasingSets > 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } } }",
        "private void inlineAliases(GlobalNamespace namespace) { Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest()); while (!workList.isEmpty()) { Name name = workList.pop(); if (name.type == Name.Type.GET || name.type == Name.Type.SET) { continue; } /* if (name.globalSets == 1 && name.localSets == 0 && */ if (name.globalSets > 0 && name.localSets > 0 && name.aliasingGets > 0) { List<Ref> refs = Lists.newArrayList(name.getRefs()); for (Ref ref : refs) { if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) { if (inlineAliasIfPossible(ref, namespace)) { name.removeRef(ref); } } } } if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props!= null) { workList.addAll(name.props); } } } }"
      ]
    },
    "Closure_132_/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java_782-783": {
      "loc": "782-783",
      "input": "<s> private Node tryMinimizeIf(Node n) { Node parent = n.getParent(); Node cond = n.getFirstChild(); if (NodeUtil.isLiteralValue(cond, true)) { return n; } Node thenBranch = cond.getNext(); Node elseBranch = thenBranch.getNext(); if (elseBranch == null) { if (isFoldableExpressBlock(thenBranch)) { Node expr = getBlockExpression(thenBranch); if (!late && isPropertyAssignmentInExpression(expr)) { return n; } if (cond.isNot()) { if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), OR_PRECEDENCE)) { return n; } Node or = IR.or( cond.removeFirstChild(), expr.removeFirstChild()).srcref(n); Node newExpr = NodeUtil.newExpr(or); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(expr.getFirstChild(), AND_PRECEDENCE)) { return n; } n.removeChild(cond); Node and = IR.and(cond, expr.removeFirstChild()).srcref(n); Node newExpr = NodeUtil.newExpr(and); parent.replaceChild(n, newExpr); reportCodeChange(); return newExpr; } else { if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild()) { Node innerIf = thenBranch.getFirstChild(); if (innerIf.isIf()) { Node innerCond = innerIf.getFirstChild(); Node innerThenBranch = innerCond.getNext(); Node innerElseBranch = innerThenBranch.getNext(); if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) && isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) { n.detachChildren(); n.addChildToBack( IR.and( cond, innerCond.detachFromParent()) .srcref(cond)); n.addChildrenToBack(innerThenBranch.detachFromParent()); reportCodeChange(); return n; } } } } return n; } tryRemoveRepeatedStatements(n); if (cond.isNot() && !consumesDanglingElse(elseBranch)) { n.replaceChild(cond, cond.removeFirstChild()); n.removeChild(thenBranch); n.addChildToBack(thenBranch); reportCodeChange(); return n; } if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) { Node thenExpr = getBlockReturnExpression(thenBranch); Node elseExpr = getBlockReturnExpression(elseBranch); n.removeChild(cond); thenExpr.detachFromParent(); elseExpr.detachFromParent(); Node returnNode = IR.returnNode( IR.hook(cond, thenExpr, elseExpr) .srcref(n)); parent.replaceChild(n, returnNode); reportCodeChange(); return returnNode; } boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch); boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch); if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) { Node thenOp = getBlockExpression(thenBranch).getFirstChild(); Node elseOp = getBlockExpression(elseBranch).getFirstChild(); if (thenOp.getType() == elseOp.getType()) { if (NodeUtil.isAssignmentOp(thenOp)) { Node lhs = thenOp.getFirstChild(); if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && /* !mayEffectMutableState(lhs)) { */ <mask> n.removeChild(cond); Node assignName = thenOp.removeFirstChild(); Node thenExpr = thenOp.removeFirstChild(); Node elseExpr = elseOp.getLastChild(); elseOp.removeChild(elseExpr); Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n); Node assign = new Node(thenOp.getType(), assignName, hookNode) .srcref(thenOp); Node expr = NodeUtil.newExpr(assign); parent.replaceChild(n, expr); reportCodeChange(); return expr; } } } n.removeChild(cond); thenOp.detachFromParent(); elseOp.detachFromParent(); Node expr = IR.exprResult( IR.hook(cond, thenOp, elseOp).srcref(n)); parent.replaceChild(n, expr); reportCodeChange(); return expr; } boolean thenBranchIsVar = isVarBlock(thenBranch); boolean elseBranchIsVar = isVarBlock(elseBranch); if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) { Node var = getBlockVar(thenBranch); Node elseAssign = getBlockExpression(elseBranch).getFirstChild(); Node name1 = var.getFirstChild(); Node maybeName2 = elseAssign.getFirstChild(); if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) { Node thenExpr = name1.removeChildren(); Node elseExpr = elseAssign.getLastChild().detachFromParent(); cond.detachFromParent(); Node hookNode = IR.hook(cond, thenExpr, elseExpr) .srcref(n); var.detachFromParent(); name1.addChildrenToBack(hookNode); parent.replaceChild(n, var); reportCodeChange(); return var; } } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) { Node var = getBlockVar(elseBranch); Node thenAssign = getBlockExpression(thenBranch).getFirstChild(); Node maybeName1 = thenAssign.getFirstChild(); Node name2 = var.getFirstChild(); if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) { Node thenExpr = thenAssign.getLastChild().detachFromParent(); Node elseExpr = name2.removeChildren(); cond.detachFromParent(); Node hookNode = IR.hook(cond, thenExpr, elseExpr) .srcref(n); var.detachFromParent(); name2.addChildrenToBack(hookNode); parent.replaceChild(n, var); reportCodeChange(); return var; } } return n; } </s> java",
      "function range": "636,3-868,3"
    },
    "Closure_133_/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java_2401-2402": {
      "loc": "2401-2402",
      "input": "<s> private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ <mask> } </s> java",
      "function range": "2399,3-2402,3",
      "output": [
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return result; }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return result ; }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return null; }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return result.trim(); }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ stream.close(); return result; }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return result == null? null : result; }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return stream.getRemainingJSDocLine(); }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ }",
        "private String getRemainingJSDocLine() { String result = stream.getRemainingJSDocLine(); /* return result; */ return result; } }",
        "private String getRemainingJSDocLine() { return stream.getRemainingJSDocLine(); /* return result; */ }"
      ]
    },
    "Closure_146_/src/com/google/javascript/rhino/jstype/JSType.java_706-707": {
      "loc": "706-707",
      "input": "<s> public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ <mask> case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); } </s> java",
      "function range": "696,3-715,3",
      "output": [
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(null, that); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: /* return new TypePair(null, that); */ case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(this, that); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(null, null); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(that, that); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(null, this); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(null, that); case TRUE: case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ return new TypePair(null, that); case FALSE: case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case FALSE: case UNKNOWN: return new TypePair(null, that); case UNKNOWN: return new TypePair(this, that); } throw new IllegalStateException(); }",
        "public TypePair getTypesUnderInequality(JSType that) { if (that instanceof UnionType) { TypePair p = that.getTypesUnderInequality(this); return new TypePair(p.typeB, p.typeA); } switch (this.testForEquality(that)) { case TRUE: /* return new TypePair(null, null); */ case UNKNOWN: return new TypePair(null, that); case TRUE: case FALSE: case UNKNOWN: return new TypePair(this, that); } return new IllegalStateException(); }"
      ]
    },
    "Closure_150_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1451-1466": {
      "loc": "1451-1466",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ <mask> } </s> java",
      "function range": "1443,5-1466,5",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ handleFunctionInputs(parent); }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } handleFunctionOutputs(parent); }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } handleFunctionInputs(parent); }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (n.getType() == Token.LP) { handleFunctionInputs(parent); return; } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } else { handleFunctionInputs(parent); } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (n == scope.getRootNode()) return; if (n.getType() == Token.LP && parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } /* attachLiteralTypes(n); switch (n.getType()) { case Token.FUNCTION: if (parent.getType() == Token.NAME) { return; } defineDeclaredFunction(n, parent); break; case Token.CATCH: defineCatch(n, parent); break; case Token.VAR: defineVar(n, parent); break; } */ if (parent == scope.getRootNode()) { handleFunctionInputs(parent); return; } else { handleFunctionOutputs(parent); } }"
      ]
    },
    "Closure_152_/src/com/google/javascript/rhino/jstype/FunctionType.java_871-872": {
      "loc": "871-872",
      "input": "<s> @Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ <mask> boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface != iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes != null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); } </s> java",
      "function range": "861,3-892,3",
      "output": [
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface!= iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes!= null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ return super.resolveInternal(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ return this; }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis!= prototype) { return typeOfThis; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface!= iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes!= null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); if (typeOfThis!= prototype) { typeOfThis = prototype; } boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface!= iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes!= null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); boolean changed = false; ImmutableList.Builder<ObjectType> resolvedInterfaces = ImmutableList.builder(); for (ObjectType iface : implementedInterfaces) { ObjectType resolvedIface = (ObjectType ) iface.resolve(t, scope); resolvedInterfaces.add(resolvedIface); changed |= (resolvedIface!= iface); } if (changed) { implementedInterfaces = resolvedInterfaces.build(); } if (subTypes!= null) { for (int i = 0; i < subTypes.size(); i++) { subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope)); } } return super.resolveInternal(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); return typeOfThis; }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (FunctionType) safeResolve(typeOfThis, t, scope); return typeOfThis; }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); return typeOfThis.resolve(t, scope); }",
        "@Override JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) { setResolvedTypeInternal(this); call = (ArrowType) safeResolve(call, t, scope); prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope); /* typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope); */ typeOfThis = (FunctionType) safeResolve(typeOfThis, t, scope); setResolvedTypeInternal(this); return typeOfThis; }"
      ]
    },
    "Closure_159_/src/com/google/javascript/jscomp/InlineFunctions.java_777-781": {
      "loc": "777-781",
      "input": "<s> private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed != null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ <mask> } } for (Node c = node.getFirstChild(); c != null; c = c.getNext()) { findCalledFunctions(c, changed); } } </s> java",
      "function range": "773,3-787,3",
      "output": [
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } else { changed.add(child.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } } else { changed.add(node.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } else if (child.getType() == Token.VALUE) { changed.add(child.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ findCalledFunctions(child, changed); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } else if (child.getType() == Token.PARAMETER) { changed.add(child.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } } else { Preconditions.checkArgument(node.getType() == Token.CALL); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed); } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } } else { changed.add(node.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed) ; } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } else if (child.getType() == Token.VALUE) { changed.add(child.getString()); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed) } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } } else { Preconditions.checkArgument(node.getType() == Token.CALL); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed) ; } }",
        "private void findCalledFunctions( Node node, Set<String> changed) { Preconditions.checkArgument(changed!= null); /* if (node.getType() == Token.CALL) { Node child = node.getFirstChild(); if (child.getType() == Token.NAME) { changed.add(child.getString()); */ } } else { Preconditions.checkArgument(node.getType() == Token.CALL); } } for (Node c = node.getFirstChild(); c!= null; c = c.getNext()) { findCalledFunctions(c, changed) } }"
      ]
    },
    "Closure_168_/src/com/google/javascript/jscomp/TypedScopeCreator.java_1996-1997": {
      "loc": "1996-1997",
      "input": "<s> @Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild() != null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ <mask> return; } if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var != null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope != ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var != null) { Scope ownerScope = var.getScope(); if (scope != ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()) .recordEscapedQualifiedName(n.getQualifiedName()); } } } } </s> java",
      "function range": "1987,5-2038,5",
      "output": [
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ if (n.isGetProp() && n.isUnscopedQualifiedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { data.get(t.getScopeRoot()).recordUnscopedQualifiedName(n.getQualifiedName()); } } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ if (n.isGetProp() && n.isUnscopedQualifiedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { data.get(t.getScopeRoot()).recordUnscopedQualifiedName(n.getQualifiedName()); } } else if (n.isGetProp() && n.isUnscopedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isName() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ data.get(t.getScopeRoot()).recordNonEmptyReturn(); return; } if (n.isName() && NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } }",
        "@Override public void visit(NodeTraversal t, Node n, Node parent) { if (t.inGlobalScope()) { return; } if (n.isReturn() && n.getFirstChild()!= null) { data.get(t.getScopeRoot()).recordNonEmptyReturn(); } /* if (t.getScopeDepth() <= 2) { */ if (n.isGetProp() && n.isUnscopedQualifiedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { data.get(t.getScopeRoot()).recordUnscopedQualifiedName(n.getQualifiedName()); } } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&!NodeUtil.isLValue(n) &&!NodeUtil.isBleedingFunctionName(n)) { String name = n.getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordAssignedName(name); } if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedVarName(name); } } } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) { String name = NodeUtil.getRootOfQualifiedName(n).getString(); Scope scope = t.getScope(); Var var = scope.getVar(name); if (var!= null) { Scope ownerScope = var.getScope(); if (scope!= ownerScope && ownerScope.isLocal()) { data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName()); } } } }"
      ]
    },
    "Codec_2_/src/java/org/apache/commons/codec/binary/Base64.java_446-447": {
      "loc": "446-447",
      "input": "<s> void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ <mask> System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } </s> java",
      "function range": "414,5-473,5",
      "output": [
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= lineSeparator.length) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= pos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= lineSeparator.length) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= pos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ if (lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } }",
        "void encode(byte[] in, int inPos, int inAvail) { if (eof) { return; } if (inAvail < 0) { eof = true; if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } switch (modulus) { case 1: buf[pos++] = encodeTable[(x >> 2) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 4) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; buf[pos++] = PAD; } break; case 2: buf[pos++] = encodeTable[(x >> 10) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 4) & MASK_6BITS]; buf[pos++] = encodeTable[(x << 2) & MASK_6BITS]; if (encodeTable == STANDARD_ENCODE_TABLE) { buf[pos++] = PAD; } break; } /* if (lineLength > 0) { */ System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; } } else { for (int i = 0; i < inAvail; i++) { if (buf == null || buf.length - pos < encodeSize) { resizeBuf(); } modulus = (++modulus) % 3; int b = in[inPos++]; if (b < 0) { b += 256; } x = (x << 8) + b; if (0 == modulus) { buf[pos++] = encodeTable[(x >> 18) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 12) & MASK_6BITS]; buf[pos++] = encodeTable[(x >> 6) & MASK_6BITS]; buf[pos++] = encodeTable[x & MASK_6BITS]; currentLinePos += 4; if (lineLength > 0 && lineLength <= currentLinePos) { System.arraycopy(lineSeparator, 0, buf, pos, lineSeparator.length); pos += lineSeparator.length; currentLinePos = 0; } } } } } }"
      ]
    },
    "Codec_3_/src/java/org/apache/commons/codec/language/DoubleMetaphone.java_455-456": {
      "loc": "455-456",
      "input": "<s> private int handleG(String value, DoubleMetaphoneResult result, int index, boolean slavoGermanic) { if (charAt(value, index + 1) == 'H') { index = handleGH(value, result, index); } else if (charAt(value, index + 1) == 'N') { if (index == 1 && isVowel(charAt(value, 0)) && !slavoGermanic) { result.append(\"KN\", \"N\"); } else if (!contains(value, index + 2, 2, \"EY\") && charAt(value, index + 1) != 'Y' && !slavoGermanic) { result.append(\"N\", \"KN\"); } else { result.append(\"KN\"); } index = index + 2; } else if (contains(value, index + 1, 2, \"LI\") && !slavoGermanic) { result.append(\"KL\", \"L\"); index += 2; } else if (index == 0 && (charAt(value, index + 1) == 'Y' || contains(value, index + 1, 2, ES_EP_EB_EL_EY_IB_IL_IN_IE_EI_ER))) { result.append('K', 'J'); index += 2; } else if ((contains(value, index + 1, 2, \"ER\") || charAt(value, index + 1) == 'Y') && !contains(value, 0, 6, \"DANGER\", \"RANGER\", \"MANGER\") && !contains(value, index - 1, 1, \"E\", \"I\") && !contains(value, index - 1, 3, \"RGY\", \"OGY\")) { result.append('K', 'J'); index += 2; } else if (contains(value, index + 1, 1, \"E\", \"I\", \"Y\") || contains(value, index - 1, 4, \"AGGI\", \"OGGI\")) { if ((contains(value, 0 ,4, \"VAN \", \"VON \") || contains(value, 0, 3, \"SCH\")) || contains(value, index + 1, 2, \"ET\")) { result.append('K'); /* } else if (contains(value, index + 1, 4, \"IER\")) { */ <mask> result.append('J'); } else { result.append('J', 'K'); } index += 2; } else if (charAt(value, index + 1) == 'G') { index += 2; result.append('K'); } else { index++; result.append('K'); } return index; } </s> java",
      "function range": "418,5-469,5"
    },
    "Codec_4_/src/java/org/apache/commons/codec/binary/Base64.java_225-226": {
      "loc": "225-226",
      "input": "<s> public Base64() { /* this(false); */ <mask> } </s> java",
      "function range": "224,5-226,5",
      "output": [
        "public Base64() { /* this(false); */ }",
        "public Base64() { /* this(false); */ this(true); }",
        "public Base64() { /* this(false); */ this (true); }",
        "public Base64() { /* this(false); */ super(); }",
        "public Base64() { /* this(false); */ this(false); }",
        "public Base64() { /* this(false); */ super ( ) ; }",
        "public Base64() { /* this(false); */ this (false); }",
        "public Base64() { /* this(false); */ base64 = true; }",
        "public Base64() { /* this(false); */ base64 = false; }",
        "public Base64() { /* this(false); */ } }"
      ]
    },
    "Codec_7_/src/java/org/apache/commons/codec/binary/Base64.java_670-671": {
      "loc": "670-671",
      "input": "<s> public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ <mask> } </s> java",
      "function range": "669,5-671,5",
      "output": [
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return StringUtils.newStringUtf8(encodeBase64(binaryData, false)); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return StringUtils.newStringUtf8(encodeBase64(binaryData, false)); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return new String(encodeBase64(binaryData, false)); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return StringUtils.newStringUtf8(encodeBase64(binaryData)); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return encodeBase64(binaryData, false); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return StringUtils.newStringUtf8(encodeBase64(binaryData, false))); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return encodeBase64String(binaryData, false); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return StringUtils.newStringUtf8 (encodeBase64(binaryData, false)); }",
        "public static String encodeBase64String(byte[] binaryData) { /* return StringUtils.newStringUtf8(encodeBase64(binaryData, true)); */ return null; }"
      ]
    },
    "Codec_9_/src/java/org/apache/commons/codec/binary/Base64.java_827-828": {
      "loc": "827-828",
      "input": "<s> public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ <mask> if (len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked ? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); } </s> java",
      "function range": "822,5-837,5",
      "output": [
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len < 0 || len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if ( len < 0 || len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len <= 0 || len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len == 0) { return binaryData; } if (len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len < MIME_CHUNK_SIZE || len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len < MIME_CHUNK_SIZE) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len < MIME_CHUNK_SIZE) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + MIME_CHUNK_SIZE + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData); }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len < 0 || len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData; }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len == 0) { return binaryData; } if (len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode(binaryData; }",
        "public static byte[] encodeBase64(byte[] binaryData, boolean isChunked, boolean urlSafe, int maxResultSize) { if (binaryData == null || binaryData.length == 0) { return binaryData; } /* long len = getEncodeLength(binaryData, MIME_CHUNK_SIZE, CHUNK_SEPARATOR); */ if (len == 0) { return binaryData; } if (len > maxResultSize) { throw new IllegalArgumentException(\"Input array too big, the output array would be bigger (\" + len + \") than the specified maxium size of \" + maxResultSize); } Base64 b64 = isChunked? new Base64(urlSafe) : new Base64(0, CHUNK_SEPARATOR, urlSafe); return b64.encode (binaryData); }"
      ]
    },
    "Codec_10_/src/java/org/apache/commons/codec/language/Caverphone.java_76-77": {
      "loc": "76-77",
      "input": "<s> public String caverphone(String txt) { if( txt == null || txt.length() == 0 ) { return \"1111111111\"; } txt = txt.toLowerCase(java.util.Locale.ENGLISH); txt = txt.replaceAll(\"[^a-z]\", \"\"); txt = txt.replaceAll(\"e$\", \"\"); txt = txt.replaceAll(\"^cough\", \"cou2f\"); txt = txt.replaceAll(\"^rough\", \"rou2f\"); txt = txt.replaceAll(\"^tough\", \"tou2f\"); txt = txt.replaceAll(\"^enough\", \"enou2f\"); txt = txt.replaceAll(\"^trough\", \"trou2f\"); txt = txt.replaceAll(\"^gn\", \"2n\"); /* txt = txt.replaceAll(\"^mb\", \"m2\"); */ <mask> txt = txt.replaceAll(\"cq\", \"2q\"); txt = txt.replaceAll(\"ci\", \"si\"); txt = txt.replaceAll(\"ce\", \"se\"); txt = txt.replaceAll(\"cy\", \"sy\"); txt = txt.replaceAll(\"tch\", \"2ch\"); txt = txt.replaceAll(\"c\", \"k\"); txt = txt.replaceAll(\"q\", \"k\"); txt = txt.replaceAll(\"x\", \"k\"); txt = txt.replaceAll(\"v\", \"f\"); txt = txt.replaceAll(\"dg\", \"2g\"); txt = txt.replaceAll(\"tio\", \"sio\"); txt = txt.replaceAll(\"tia\", \"sia\"); txt = txt.replaceAll(\"d\", \"t\"); txt = txt.replaceAll(\"ph\", \"fh\"); txt = txt.replaceAll(\"b\", \"p\"); txt = txt.replaceAll(\"sh\", \"s2\"); txt = txt.replaceAll(\"z\", \"s\"); txt = txt.replaceAll(\"^[aeiou]\", \"A\"); txt = txt.replaceAll(\"[aeiou]\", \"3\"); txt = txt.replaceAll(\"j\", \"y\"); txt = txt.replaceAll(\"^y3\", \"Y3\"); txt = txt.replaceAll(\"^y\", \"A\"); txt = txt.replaceAll(\"y\", \"3\"); txt = txt.replaceAll(\"3gh3\", \"3kh3\"); txt = txt.replaceAll(\"gh\", \"22\"); txt = txt.replaceAll(\"g\", \"k\"); txt = txt.replaceAll(\"s+\", \"S\"); txt = txt.replaceAll(\"t+\", \"T\"); txt = txt.replaceAll(\"p+\", \"P\"); txt = txt.replaceAll(\"k+\", \"K\"); txt = txt.replaceAll(\"f+\", \"F\"); txt = txt.replaceAll(\"m+\", \"M\"); txt = txt.replaceAll(\"n+\", \"N\"); txt = txt.replaceAll(\"w3\", \"W3\"); txt = txt.replaceAll(\"wh3\", \"Wh3\"); txt = txt.replaceAll(\"w$\", \"3\"); txt = txt.replaceAll(\"w\", \"2\"); txt = txt.replaceAll(\"^h\", \"A\"); txt = txt.replaceAll(\"h\", \"2\"); txt = txt.replaceAll(\"r3\", \"R3\"); txt = txt.replaceAll(\"r$\", \"3\"); txt = txt.replaceAll(\"r\", \"2\"); txt = txt.replaceAll(\"l3\", \"L3\"); txt = txt.replaceAll(\"l$\", \"3\"); txt = txt.replaceAll(\"l\", \"2\"); txt = txt.replaceAll(\"2\", \"\"); txt = txt.replaceAll(\"3$\", \"A\"); txt = txt.replaceAll(\"3\", \"\"); txt = txt + \"111111\" + \"1111\"; return txt.substring(0, 10); } </s> java",
      "function range": "50,5-142,5"
    },
    "Codec_17_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_339-340": {
      "loc": "339-340",
      "input": "<s> public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ <mask> } </s> java",
      "function range": "338,5-340,5",
      "output": [
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return new String(bytes, Charsets.ISO_8859_1); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return new String(bytes, Charsets.UTF_8); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return new String (bytes, Charsets.ISO_8859_1); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return \"8859_1\"; }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return new String (bytes, Charsets.UTF_8); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return new String(bytes); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ } return new String(bytes, Charsets.UTF_8); }",
        "public static String newStringIso8859_1(final byte[] bytes) { /* return new String(bytes, Charsets.ISO_8859_1); */ return null; }",
        "public static String newStringIso8859_1() { /* return new String(bytes, Charsets.ISO_8859_1); */ }"
      ]
    },
    "Codec_18_/src/main/java/org/apache/commons/codec/binary/StringUtils.java_81-82": {
      "loc": "81-82",
      "input": "<s> public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ <mask> } </s> java",
      "function range": "71,5-82,5",
      "output": [
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return false; }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return true; }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return cs1.equals(cs2); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, Math.max(cs1.length(), cs2.length())); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return cs1.toString().equals(cs2.toString()); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return cs1.equals(cs2) && cs2.equals(cs1); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, Math.max(cs1.length(), cs2.length())); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ if (cs1.length()!= cs2.length()) { return false; } return true; }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, Math.min(cs1.length(), cs2.length())); }",
        "public static boolean equals(final CharSequence cs1, final CharSequence cs2) { if (cs1 == cs2) { return true; } if (cs1 == null || cs2 == null) { return false; } if (cs1 instanceof String && cs2 instanceof String) { return cs1.equals(cs2); } /* return CharSequenceUtils.regionMatches(cs1, false, 0, cs2, 0, Math.max(cs1.length(), cs2.length())); */ return CharSequenceUtils.equals(cs1, cs2); }"
      ]
    },
    "Collections_26_/src/main/java/org/apache/commons/collections4/keyvalue/MultiKey.java_277-278": {
      "loc": "277-278",
      "input": "<s> /* private Object readResolve() { */ <mask> calculateHashCode(keys); return this; } </s> java",
      "function range": "277,5-280,5",
      "output": [
        "/* private Object readResolve() { */ hashCode = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ int hashCode = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ this.keys = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ hashcode = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ int hashcode = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ int hash = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ hash = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ this.hash = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ this.keysHashCode = calculateHashCode(keys); return this; }",
        "/* private Object readResolve() { */ this.keys = calculateKeys(keys); this.hashCode = calculateHashCode(keys); return this; }"
      ]
    },
    "Compress_5_/src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java_239-241": {
      "loc": "239-241",
      "input": "<s> public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead ? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ <mask> } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); } </s> java",
      "function range": "191,5-246,5",
      "output": [
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ } if (read == length && inf.needsInput()) { fill(); } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ } else if (read == length && inf.needsInput()) { fill(); } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; read += read; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; read = read; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; bytesReadFromStream += read; } crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; readBytesOfEntry += read; crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; read += read; crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; readBytesOfEntry += read; crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); }",
        "public int read(byte[] buffer, int start, int length) throws IOException { if (closed) { throw new IOException(\"The stream is closed\"); } if (inf.finished() || current == null) { return -1; } if (start <= buffer.length && length >= 0 && start >= 0 && buffer.length - start >= length) { if (current.getMethod() == ZipArchiveOutputStream.STORED) { int csize = (int) current.getSize(); if (readBytesOfEntry >= csize) { return -1; } if (offsetInBuffer >= lengthOfLastRead) { offsetInBuffer = 0; if ((lengthOfLastRead = in.read(buf)) == -1) { return -1; } count(lengthOfLastRead); bytesReadFromStream += lengthOfLastRead; } int toRead = length > lengthOfLastRead? lengthOfLastRead - offsetInBuffer : length; if ((csize - readBytesOfEntry) < toRead) { toRead = csize - readBytesOfEntry; } System.arraycopy(buf, offsetInBuffer, buffer, start, toRead); offsetInBuffer += toRead; readBytesOfEntry += toRead; crc.update(buffer, start, toRead); return toRead; } if (inf.needsInput()) { fill(); if (lengthOfLastRead > 0) { bytesReadFromStream += lengthOfLastRead; } } int read = 0; try { read = inf.inflate(buffer, start, length); } catch (DataFormatException e) { throw new ZipException(e.getMessage()); } /* if (read == 0 && inf.finished()) { return -1; */ System.arraycopy(buf, offsetInBuffer, buffer, start, read); offsetInBuffer += read; read += read; crc.update(buffer, start, read); return read; } throw new ArrayIndexOutOfBoundsException(); } return read; }"
      ]
    },
    "Compress_12_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveInputStream.java_198-199": {
      "loc": "198-199",
      "input": "<s> public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry != null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ <mask> entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; } </s> java",
      "function range": "172,5-238,5",
      "output": [
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()){ paxHeader(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()) { paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()) { paxHeaders(); } if (currEntry.isGNUSparse()) { readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()){ paxHeader(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ entryOffset = 0; entrySize = currEntry.getSize(); if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } if (currEntry.isGNULongNameEntry()) { StringBuffer longName = new StringBuffer(); byte[] buf = new byte[SMALL_BUFFER_SIZE]; int length = 0; while ((length = read(buf)) >= 0) { longName.append(new String(buf, 0, length)); } getNextEntry(); if (currEntry == null) { return null; } if (longName.length() > 0 && longName.charAt(longName.length() - 1) == 0) { longName.deleteCharAt(longName.length() - 1); } currEntry.setName(longName.toString()); } if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ entryOffset = 0; entrySize = currEntry.getSize(); return currEntry; }",
        "public TarArchiveEntry getNextTarEntry() throws IOException { if (hasHitEOF) { return null; } if (currEntry!= null) { long numToSkip = entrySize - entryOffset; while (numToSkip > 0) { long skipped = skip(numToSkip); if (skipped <= 0) { throw new RuntimeException(\"failed to skip current tar entry\"); } numToSkip -= skipped; } readBuf = null; } byte[] headerBuf = getRecord(); if (hasHitEOF) { currEntry = null; return null; } /* currEntry = new TarArchiveEntry(headerBuf); */ if (currEntry.isPaxHeader()){ paxHeaders(); } if (currEntry.isGNUSparse()){ readGNUSparse(); } entryOffset = 0; entrySize = currEntry.getSize(); return currEntry; }"
      ]
    },
    "Compress_14_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_65-73": {
      "loc": "65-73",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i] != 0){ allNUL = false; break; } } if (allNUL) { */ <mask> return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer == ' '){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "function range": "56,5-112,5",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); return result; } else { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7''){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7' || currentByte <'' || currentByte > '8') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer; trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } else { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, end-1, trailer)); } trailer = buffer[end-1]; if (trailer == 0 || trailer ==''){ end--; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'; } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } /* boolean allNUL = true; for (int i = start; i < end; i++){ if (buffer[i]!= 0){ allNUL = false; break; } } if (allNUL) { */ result = (result << 3) + (buffer[start] - '0'); } else { result = (result << 3) + (buffer[start] - '0'); } return result; }"
      ]
    },
    "Compress_19_/src/main/java/org/apache/commons/compress/archivers/zip/Zip64ExtendedInformationExtraField.java_259-260": {
      "loc": "259-260",
      "input": "<s> public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData != null) { int expectedLength = (hasUncompressedSize ? DWORD : 0) + (hasCompressedSize ? DWORD : 0) + (hasRelativeHeaderOffset ? DWORD : 0) + (hasDiskStart ? WORD : 0); /* if (rawCentralDirectoryData.length != expectedLength) { */ <mask> throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } } </s> java",
      "function range": "249,5-287,5",
      "output": [
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length < expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length!= expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length > expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ throw new ZipException(\"Central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length == expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length \" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length < expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } }",
        "public void reparseCentralDirectoryData(boolean hasUncompressedSize, boolean hasCompressedSize, boolean hasRelativeHeaderOffset, boolean hasDiskStart) throws ZipException { if (rawCentralDirectoryData!= null) { int expectedLength = (hasUncompressedSize? DWORD : 0) + (hasCompressedSize? DWORD : 0) + (hasRelativeHeaderOffset? DWORD : 0) + (hasDiskStart? WORD : 0); /* if (rawCentralDirectoryData.length!= expectedLength) { */ if (rawCentralDirectoryData.length!= expectedLength) { throw new ZipException(\"central directory zip64 extended\" + \" information extra field's length\" + \" doesn't match central directory\" + \" data. Expected length \" + expectedLength + \" but is \" + rawCentralDirectoryData.length); } int offset = 0; if (hasUncompressedSize) { size = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasCompressedSize) { compressedSize = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasRelativeHeaderOffset) { relativeHeaderOffset = new ZipEightByteInteger(rawCentralDirectoryData, offset); offset += DWORD; } if (hasDiskStart) { diskStart = new ZipLong(rawCentralDirectoryData, offset); offset += WORD; } } } }"
      ]
    },
    "Compress_23_/src/main/java/org/apache/commons/compress/archivers/sevenz/Coders.java_112-113": {
      "loc": "112-113",
      "input": "<s> @Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ <mask> } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); } </s> java",
      "function range": "106,9-118,9",
      "output": [
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize < LZMAInputStream.DICT_SIZE_MIN) { throw new IOException(\"Dictionary smaller than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize <= LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize < LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize == LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } dictSize <<= 8; } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, 0, propsByte, (int) dictSize); }",
        "@Override InputStream decode(final InputStream in, final Coder coder, byte[] password) throws IOException { byte propsByte = coder.properties[0]; long dictSize = coder.properties[1]; for (int i = 1; i < 4; i++) { /* dictSize |= (coder.properties[i + 1] << (8 * i)); */ } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } if (dictSize > LZMAInputStream.DICT_SIZE_MAX) { throw new IOException(\"Dictionary larger than 4GiB maximum size\"); } return new LZMAInputStream(in, -1, propsByte, (int) dictSize); } }"
      ]
    },
    "Compress_27_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_133-137": {
      "loc": "133-137",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ <mask> for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "function range": "102,5-150,5",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ result = (result << 3) + (trailer - '0'); for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, buffer[start]); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ result = (result << 3) + (buffer[start] - trailer); for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (trailer == 0) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, buffer[start]); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, buffer[end - 1]); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (trailer == 0) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, buffer[end - 1]); } for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } result = (result << 3) + (trailer - '0'); for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ result = (result << 3) + (buffer[start] - trailer); return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } /* if (start == end) { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, trailer)); } */ if (buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] =='' || buffer[start] == '0'); for ( ;start < end; start++) { final byte currentByte = buffer[start]; if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }"
      ]
    },
    "Compress_31_/src/main/java/org/apache/commons/compress/archivers/tar/TarUtils.java_135-138": {
      "loc": "135-138",
      "input": "<s> public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] == ' '){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer == ' ')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ <mask> if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; } </s> java",
      "function range": "101,5-148,5",
      "output": [
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ result = (result << 3) + (currentByte - '0'); if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } else if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte == '0') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } else if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0' || currentByte > '7') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0'); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ if (currentByte < '0') { throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } else if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }",
        "public static long parseOctal(final byte[] buffer, final int offset, final int length) { long result = 0; int end = offset + length; int start = offset; if (length < 2){ throw new IllegalArgumentException(\"Length \"+length+\" must be at least 2\"); } if (buffer[start] == 0) { return 0L; } while (start < end){ if (buffer[start] ==''){ start++; } else { break; } } byte trailer = buffer[end - 1]; while (start < end && (trailer == 0 || trailer =='')) { end--; trailer = buffer[end - 1]; } for ( ;start < end; start++) { final byte currentByte = buffer[start]; /* if (currentByte == 0) { break; } */ result = (result << 3) + (currentByte - '0'); if (currentByte < '0' || currentByte > '7'){ throw new IllegalArgumentException( exceptionMessage(buffer, offset, length, start, currentByte)); } result = (result << 3) + (currentByte - '0''); } return result; }"
      ]
    },
    "Compress_38_/src/main/java/org/apache/commons/compress/archivers/tar/TarArchiveEntry.java_859-860": {
      "loc": "859-860",
      "input": "<s> @Override public boolean isDirectory() { if (file != null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ <mask> return true; } return false; } </s> java",
      "function range": "849,5-864,5",
      "output": [
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } */ if (getName().startsWith(\"/\")) { return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return false; } else if (getName().startsWith(\"/\")) { return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } if (getName().startsWith(\"/\")) { return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } else if (getName().startsWith(\"/\")) { */ return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } else if (getName().startsWith(\"/\")) { return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } if (getName().startsWith(\"/\")) { */ return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return false; } else if (getName().startsWith(\"/\")) { */ return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } */ if (getName().endsWith(\"/\")) { return true; } return false; }",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } /* if (getName().endsWith(\".\")) { */ return true; } return false;",
        "@Override public boolean isDirectory() { if (file!= null) { return file.isDirectory(); } if (linkFlag == LF_DIR) { return true; } /* if (getName().endsWith(\"/\")) { */ return true; } else if (getName().startsWith(\"/\")) { return true; } return false; } }"
      ]
    },
    "Compress_46_/src/main/java/org/apache/commons/compress/archivers/zip/X5455_ExtendedTimestamp.java_529-531": {
      "loc": "529-531",
      "input": "<s> private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ <mask> throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); } </s> java",
      "function range": "528,5-534,5",
      "output": [
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ l -= TWO_TO_32; } else { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l < TWO_TO_32) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l < TWO_TO_32) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ return new ZipLong(l - TWO_TO_32); } else if (l < 0x5455) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l <= TWO_TO_32) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l < TWO_TO_32 ) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l <= TWO_TO_32) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }",
        "private static ZipLong unixTimeToZipLong(long l) { /* final long TWO_TO_32 = 0x100000000L; if (l >= TWO_TO_32) { */ throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } else if (l <= TWO_TO_32 ) { throw new IllegalArgumentException(\"X5455 timestamps must fit in a signed 32 bit integer: \" + l); } return new ZipLong(l); }"
      ]
    },
    "Csv_1_/src/main/java/org/apache/commons/csv/ExtendedBufferedReader.java_58-59": {
      "loc": "58-59",
      "input": "<s> @Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ <mask> lineCounter++; } lastChar = current; return lastChar; } </s> java",
      "function range": "55,5-63,5",
      "output": [
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ current = super.read(); lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ } else { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ } */ if (current == '\\n') { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ return lineCounter; } */ if (current == '\\n') { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ lineCounter = 0; } else { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ return 0; } */ if (current == '\\n') { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ lineCounter = 0; } */ if (current == '\\n') { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ return lineCounter; } */ if (current == '\\r') { lineCounter++; } lastChar = current; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ return lineCounter; } */ if (current == '\\n') { lineCounter++; } lastChar = current ; return lastChar; }",
        "@Override public int read() throws IOException { int current = super.read(); /* if (current == '\\n') { */ return lineCounter; } */ if (current == '\\n') { lineCounter++; } lastChar = current; return lastChar ; }"
      ]
    },
    "Csv_4_/src/main/java/org/apache/commons/csv/CSVParser.java_288-289": {
      "loc": "288-289",
      "input": "<s> public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ <mask> } </s> java",
      "function range": "287,5-289,5",
      "output": [
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this.headerMap; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ } return this.headerMap; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this.headerMap ; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this.map; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this._headerMap; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ } return this.headerMap ; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this.headersMap; }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return this.headerMap.copy(); }",
        "public Map<String, Integer> getHeaderMap() { /* return new LinkedHashMap<String, Integer>(this.headerMap); */ return new LinkedHashMap<String, Integer>(); }"
      ]
    },
    "Csv_11_/src/main/java/org/apache/commons/csv/CSVParser.java_384-385": {
      "loc": "384-385",
      "input": "<s> private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader != null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord != null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord != null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ <mask> if (containsHeader && (!emptyHeader || (emptyHeader && !this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } </s> java",
      "function range": "359,5-394,5",
      "output": [
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.put(header, Integer.valueOf(i)); } else if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.remove(header); } else if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { header = header.trim(); } if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.put(header, Integer.valueOf(i)); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.remove(header); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.remove(header); } else { hdrMap.remove(header); } if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.put(header, Integer.valueOf(i)); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.put(header, Integer.valueOf(i)); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } } return hdrMap; }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.remove(header); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } else { return null; } }",
        "private Map<String, Integer> initializeHeader() throws IOException { Map<String, Integer> hdrMap = null; final String[] formatHeader = this.format.getHeader(); if (formatHeader!= null) { hdrMap = new LinkedHashMap<String, Integer>(); String[] headerRecord = null; if (formatHeader.length == 0) { final CSVRecord nextRecord = this.nextRecord(); if (nextRecord!= null) { headerRecord = nextRecord.values(); } } else { if (this.format.getSkipHeaderRecord()) { this.nextRecord(); } headerRecord = formatHeader; } if (headerRecord!= null) { for (int i = 0; i < headerRecord.length; i++) { final String header = headerRecord[i]; final boolean containsHeader = hdrMap.containsKey(header); /* final boolean emptyHeader = header.trim().isEmpty(); */ if (containsHeader) { hdrMap.remove(header); } else { if (containsHeader && (!emptyHeader || (emptyHeader &&!this.format.getIgnoreEmptyHeaders()))) { throw new IllegalArgumentException(\"The header contains a duplicate name: \\\"\" + header + \"\\\" in \" + Arrays.toString(headerRecord)); } hdrMap.put(header, Integer.valueOf(i)); } } } return hdrMap; } return hdrMap; }"
      ]
    },
    "Csv_14_/src/main/java/org/apache/commons/csv/CSVFormat.java_1039-1040": {
      "loc": "1039-1040",
      "input": "<s> private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ <mask> quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); } </s> java",
      "function range": "1001,5-1106,5",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = pos - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ if (quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = pos + 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = end - 1; c = value.charAt(pos); if (c == quoteChar || c == delimChar) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = end - 1; c = value.charAt(pos); if (c == CR || c == quoteChar || c == delimChar) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP || c == quoteChar || c == delimChar) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ if (quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP && c == quoteChar || c == delimChar) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < '0' || c > '9' && c < 'A' || c > 'Z' && c < 'a' || c > 'z')) { */ pos = pos + 1; c = value.charAt(pos); if (c == quoteChar || c == delimChar) { quote = true; } else if (c <= COMMENT) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }"
      ]
    },
    "Csv_15_/src/main/java/org/apache/commons/csv/CSVFormat.java_1189-1192": {
      "loc": "1189-1192",
      "input": "<s> private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote = !(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ <mask> quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); } </s> java",
      "function range": "1151,5-1256,5",
      "output": [
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == quoteChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (quote) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == CR || c == quoteChar || c == delimChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == quoteChar || c == delimChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar); } }",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == quoteChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar);",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar);",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == CR || c == quoteChar || c == delimChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar);",
        "private void printAndQuote(final Object object, final CharSequence value, final int offset, final int len, final Appendable out, final boolean newRecord) throws IOException { boolean quote = false; int start = offset; int pos = offset; final int end = offset + len; final char delimChar = getDelimiter(); final char quoteChar = getQuoteCharacter().charValue(); QuoteMode quoteModePolicy = getQuoteMode(); if (quoteModePolicy == null) { quoteModePolicy = QuoteMode.MINIMAL; } switch (quoteModePolicy) { case ALL: case ALL_NON_NULL: quote = true; break; case NON_NUMERIC: quote =!(object instanceof Number); break; case NONE: printAndEscape(value, offset, len, out); return; case MINIMAL: if (len <= 0) { if (newRecord) { quote = true; } } else { char c = value.charAt(pos); /* if (newRecord && (c < 0x20 || c > 0x21 && c < 0x23 || c > 0x2B && c < 0x2D || c > 0x7E)) { quote = true; } else if (c <= COMMENT) { */ quote = true; } else if (c == quoteChar || c == delimChar) { quote = true; } else { while (pos < end) { c = value.charAt(pos); if (c == LF || c == CR || c == quoteChar || c == delimChar) { quote = true; break; } pos++; } if (!quote) { pos = end - 1; c = value.charAt(pos); if (c <= SP) { quote = true; } } } } if (!quote) { out.append(value, start, end); return; } break; default: throw new IllegalStateException(\"Unexpected Quote value: \" + quoteModePolicy); } if (!quote) { out.append(value, start, end); return; } out.append(quoteChar); while (pos < end) { final char c = value.charAt(pos); if (c == quoteChar) { out.append(value, start, pos + 1); start = pos; } pos++; } out.append(value, start, pos); out.append(quoteChar);"
      ]
    },
    "Gson_10_/gson/src/main/java/com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java_122-124": {
      "loc": "122-124",
      "input": "<s> @SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ <mask> t.write(writer, fieldValue); } </s> java",
      "function range": "118,7-125,7",
      "output": [
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ if (t!= null) t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ fieldValue = t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ if (t == null) return; t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ if (t == null) { return; } t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ if (t!= null) t.write(writer, fieldValue); else t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ writer.writeTypeAdapter(t); writer.writeTypeAdapter(t); t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ if (t == null) { t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter); } t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ writer.writeTypeAdapter(t); writer.writeTypeAdapter(t); writer.writeTypeAdapter(t); t.write(writer, fieldValue); }",
        "@SuppressWarnings({\"unchecked\", \"rawtypes\"}) @Override void write(JsonWriter writer, Object value) throws IOException, IllegalAccessException { Object fieldValue = field.get(value); /* TypeAdapter t = new TypeAdapterRuntimeTypeWrapper(context, typeAdapter, fieldType.getType()); */ writer.writeTypeAdapter(t); writer.writeTypeAdapter(typeAdapter); t.write(writer, fieldValue); }"
      ]
    },
    "Gson_13_/gson/src/main/java/com/google/gson/stream/JsonReader.java_731-732": {
      "loc": "731-732",
      "input": "<s> private int peekNumber() throws IOException { char[] buffer = this.buffer; int p = pos; int l = limit; long value = 0; boolean negative = false; boolean fitsInLong = true; int last = NUMBER_CHAR_NONE; int i = 0; charactersOfNumber: for (; true; i++) { if (p + i == l) { if (i == buffer.length) { return PEEKED_NONE; } if (!fillBuffer(i + 1)) { break; } p = pos; l = limit; } char c = buffer[p + i]; switch (c) { case '-': if (last == NUMBER_CHAR_NONE) { negative = true; last = NUMBER_CHAR_SIGN; continue; } else if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case '+': if (last == NUMBER_CHAR_EXP_E) { last = NUMBER_CHAR_EXP_SIGN; continue; } return PEEKED_NONE; case 'e': case 'E': if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT) { last = NUMBER_CHAR_EXP_E; continue; } return PEEKED_NONE; case '.': if (last == NUMBER_CHAR_DIGIT) { last = NUMBER_CHAR_DECIMAL; continue; } return PEEKED_NONE; default: if (c < '0' || c > '9') { if (!isLiteral(c)) { break charactersOfNumber; } return PEEKED_NONE; } if (last == NUMBER_CHAR_SIGN || last == NUMBER_CHAR_NONE) { value = -(c - '0'); last = NUMBER_CHAR_DIGIT; } else if (last == NUMBER_CHAR_DIGIT) { if (value == 0) { return PEEKED_NONE; } long newValue = value * 10 - (c - '0'); fitsInLong &= value > MIN_INCOMPLETE_INTEGER || (value == MIN_INCOMPLETE_INTEGER && newValue < value); value = newValue; } else if (last == NUMBER_CHAR_DECIMAL) { last = NUMBER_CHAR_FRACTION_DIGIT; } else if (last == NUMBER_CHAR_EXP_E || last == NUMBER_CHAR_EXP_SIGN) { last = NUMBER_CHAR_EXP_DIGIT; } } } /* if (last == NUMBER_CHAR_DIGIT && fitsInLong && (value != Long.MIN_VALUE || negative)) { */ <mask> peekedLong = negative ? value : -value; pos += i; return peeked = PEEKED_LONG; } else if (last == NUMBER_CHAR_DIGIT || last == NUMBER_CHAR_FRACTION_DIGIT || last == NUMBER_CHAR_EXP_DIGIT) { peekedNumberLength = i; return peeked = PEEKED_NUMBER; } else { return PEEKED_NONE; } } </s> java",
      "function range": "641,3-742,3"
    },
    "Gson_15_/gson/src/main/java/com/google/gson/stream/JsonWriter.java_495-496": {
      "loc": "495-496",
      "input": "<s> public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ <mask> throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; } </s> java",
      "function range": "493,3-501,3",
      "output": [
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ } else { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ return this; } else { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ return this; } if (Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ value = Double.NaN; } else { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ } else if (Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ return this; } if (Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ return this; } else { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ } else if (Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value); return this; }",
        "public JsonWriter value(double value) throws IOException { writeDeferredName(); /* if (Double.isNaN(value) || Double.isInfinite(value)) { */ return this; } if (Double.isInfinite(value)) { throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value); } beforeValue(); out.append(Double.toString(value)); return this ; }"
      ]
    },
    "Gson_17_/gson/src/main/java/com/google/gson/DefaultDateTypeAdapter.java_99-101": {
      "loc": "99-101",
      "input": "<s> @Override public Date read(JsonReader in) throws IOException { /* if (in.peek() != JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ <mask> } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } } </s> java",
      "function range": "97,3-113,3",
      "output": [
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } if (in.peek()!= JsonToken.NUMBER) { throw new JsonParseException(\"The date should be a number value\"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } if (in.peek()!= JsonToken.NUMBER) { throw new JsonParseException(\"The date should be a number\"); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } if (in.peek() == JsonToken.STRING) { return deserializeToDate(in.nextString()); } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Timestamp.class || dateType == java.sql.Date.class) { return new java.sql.Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Timestamp.class || dateType == java.sql.Date.class) { return new java.sql.Timestamp(date.getTime()); } else if (dateType == java.sql.Timestamp.class || dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else { throw new AssertionError(); } }",
        "@Override public Date read(JsonReader in) throws IOException { /* if (in.peek()!= JsonToken.STRING) { throw new JsonParseException(\"The date should be a string value\"); */ } Date date = deserializeToDate(in.nextString()); if (dateType == Date.class) { return date; } else if (dateType == Timestamp.class) { return new Timestamp(date.getTime()); } else if (dateType == java.sql.Date.class) { return new java.sql.Date(date.getTime()); } else if (dateType == java.sql.Timestamp.class) { return new java.sql.Timestamp(date.getTime()); } else { throw new AssertionError(); } }"
      ]
    },
    "JacksonCore_5_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-194": {
      "loc": "193-194",
      "input": "<s> private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ <mask> if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); } </s> java",
      "function range": "185,5-205,5",
      "output": [
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c > '0' || c < '0') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '7' || c < '8' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9' ) { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str);",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c < '0' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str) }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } for (int i = 0; i < len; ++i) { /* char c = str.charAt(i++); */ if (c > '0' || c < '0') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str)"
      ]
    },
    "JacksonCore_6_/src/main/java/com/fasterxml/jackson/core/JsonPointer.java_193-195": {
      "loc": "193-195",
      "input": "<s> private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ <mask> if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); } </s> java",
      "function range": "185,5-206,5",
      "output": [
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c < '0' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c > '0' || c < '0') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c < '0' || c > '7' || c < '8' || c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c < '0' || c > '9') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c < '0' || c > '9') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c > '0' || c < '0') { return -1; } else if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c < '0' || c > '9' ) { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c > '0' || c < '0') { return i; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }",
        "private final static int _parseIndex(String str) { final int len = str.length(); if (len == 0 || len > 10) { return -1; } /* for (int i = 0; i < len; ++i) { char c = str.charAt(i); */ if (c > '0' || c < '0') { return -1; } if (c > '9' || c < '0') { return -1; } } if (len == 10) { long l = NumberInput.parseLong(str); if (l > Integer.MAX_VALUE) { return -1; } } return NumberInput.parseInt(str); }"
      ]
    },
    "JacksonCore_8_/src/main/java/com/fasterxml/jackson/core/util/TextBuffer.java_307-308": {
      "loc": "307-308",
      "input": "<s> public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray != null) return _resultArray; if (_resultString != null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ <mask> return contentsAsArray(); } </s> java",
      "function range": "298,5-310,5",
      "output": [
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_resultString!= null) return _resultString.toCharArray(); return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ return _currentSegment; }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ _currentSegment = 0; return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_currentSegment!= null) return _currentSegment.toCharArray(); return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_currentSegment!= null) return _currentSegment; return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_resultString!= null) return _resultString.toCharArray(); else return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_currentSegment == null) return contentsAsArray(); else return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_currentSegment == null) return contentsAsArray(); return contentsAsArray(); }",
        "public char[] getTextBuffer() { if (_inputStart >= 0) return _inputBuffer; if (_resultArray!= null) return _resultArray; if (_resultString!= null) { return (_resultArray = _resultString.toCharArray()); } /* if (!_hasSegments) return _currentSegment; */ if (_resultString == null) return contentsAsArray(); else return contentsAsArray(); }"
      ]
    },
    "JacksonCore_20_/src/main/java/com/fasterxml/jackson/core/JsonGenerator.java_1330-1331": {
      "loc": "1330-1331",
      "input": "<s> public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ <mask> this); } </s> java",
      "function range": "1328,5-1332,5",
      "output": [
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ throw new JsonGenerationException(\"No native support for writing embedded objects\", this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ throw new UnsupportedOperationException(\"No native support for writing embedded objects\", this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ object.toString(), this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ ). writeEmbeddedObject(object, this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ ). writeEmbeddedObject ( object, this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ ). writeEmbeddedObject ( object, this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ ) ; object. writeEmbeddedObject ( this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ ) ; object. writeEmbeddedObject( this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ throw new JsonGenerationException(\"No native support for writing embedded objects.\", this); }",
        "public void writeEmbeddedObject(Object object) throws IOException { /* throw new JsonGenerationException(\"No native support for writing embedded objects\", */ throw new UnsupportedOperationException(\"No native support for writing embedded objects.\", this); }"
      ]
    },
    "JacksonCore_25_/src/main/java/com/fasterxml/jackson/core/json/ReaderBasedJsonParser.java_1963-1964": {
      "loc": "1963-1964",
      "input": "<s> private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ <mask> if (codes[i] != 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } </s> java",
      "function range": "1948,5-1990,5",
      "output": [
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ ++_inputPtr; if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i] == 0) { break; } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i] == 0) { break; } } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i]!= 0) { break; } } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } return null; }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ ++_inputPtr; if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); } } return null; }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i] == 0) { break; } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len); } }",
        "private String _handleOddName2(int startPtr, int hash, int[] codes) throws IOException { _textBuffer.resetWithShared(_inputBuffer, startPtr, (_inputPtr - startPtr)); char[] outBuf = _textBuffer.getCurrentSegment(); int outPtr = _textBuffer.getCurrentSegmentSize(); final int maxCode = codes.length; while (true) { if (_inputPtr >= _inputEnd) { if (!_loadMore()) { break; } } char c = _inputBuffer[_inputPtr]; int i = (int) c; /* if (i <= maxCode) { */ if (codes[i] == 0) { break; } else if (codes[i]!= 0) { break; } } else if (!Character.isJavaIdentifierPart(c)) { break; } ++_inputPtr; hash = (hash * CharsToNameCanonicalizer.HASH_MULT) + i; outBuf[outPtr++] = c; if (outPtr >= outBuf.length) { outBuf = _textBuffer.finishCurrentSegment(); outPtr = 0; } } _textBuffer.setCurrentLength(outPtr); { TextBuffer tb = _textBuffer; char[] buf = tb.getTextBuffer(); int start = tb.getTextOffset(); int len = tb.size(); return _symbols.findSymbol(buf, start, len, hash); }"
      ]
    },
    "JacksonDatabind_12_/src/main/java/com/fasterxml/jackson/databind/deser/std/MapDeserializer.java_303-304": {
      "loc": "303-304",
      "input": "<s> @Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ <mask> && (_ignorableProperties == null); } </s> java",
      "function range": "298,5-305,5",
      "output": [
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return _valueTypeDeserializer!= null && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return _valueTypeDeserializer == null && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return (_valueType == null && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return super. isCachable() && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return (_valueType == null) && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return _valueTypeSerializer == null && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return (_valueTypeSerializer == null) && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return (_valueTypeSerializer == null && (_ignorableProperties == null); }",
        "@Override public boolean isCachable() { /* return (_valueTypeDeserializer == null) */ return (_valueTypeDeserializer!= null && (_ignorableProperties == null); }",
        "; }"
      ]
    },
    "JacksonDatabind_16_/src/main/java/com/fasterxml/jackson/databind/introspect/AnnotationMap.java_112-113": {
      "loc": "112-113",
      "input": "<s> protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous != null) && previous.equals(ann); */ <mask> } </s> java",
      "function range": "107,5-113,5",
      "output": [
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return true; }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return false; }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return super.add(ann); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return _annotations.get(ann.annotationType(), ann); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return _annotations.put(ann.annotationType(), ann); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return _annotations.get(ann.annotationType()); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return _annotations.containsKey(ann.annotationType()); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return ann!= null; }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return!_annotations.containsKey(ann.annotationType()); }",
        "protected final boolean _add(Annotation ann) { if (_annotations == null) { _annotations = new HashMap<Class<? extends Annotation>,Annotation>(); } Annotation previous = _annotations.put(ann.annotationType(), ann); /* return (previous!= null) && previous.equals(ann); */ return (previous!= null) && previous.equals(ann); }"
      ]
    },
    "JacksonDatabind_17_/src/main/java/com/fasterxml/jackson/databind/ObjectMapper.java_180-181": {
      "loc": "180-181",
      "input": "<s> public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ <mask> case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return !t.isFinal() && !TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } } </s> java",
      "function range": "167,9-193,9",
      "output": [
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ default: return (t.getRawClass() == Object.class); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ default: return (t.getRawClass() == Object.class); } case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case CONCRETE_AND_ARRAYS: return!t.isConcrete() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case NON_FINAL_AND_ARRAYS: return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case NON_FINAL_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case NON_FINAL_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class); } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case CONCRETE_AND_ARRAYS: return!t.isConcrete() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class) } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ default: return (t.getRawClass() == Object.class); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class) } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case NON_FINAL_AND_ARRAYS: return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class) } }",
        "public boolean useForType(JavaType t) { switch (_appliesFor) { case NON_CONCRETE_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case OBJECT_AND_NON_CONCRETE: return (t.getRawClass() == Object.class) || (!t.isConcrete() /* || TreeNode.class.isAssignableFrom(t.getRawClass())); */ case NON_FINAL_AND_ARRAYS: while (t.isArrayType()) { t = t.getContentType(); } case NON_FINAL: while (t.isArrayType()) { t = t.getContentType(); } return!t.isFinal() &&!TreeNode.class.isAssignableFrom(t.getRawClass()); default: return (t.getRawClass() == Object.class) } }"
      ]
    },
    "JacksonDatabind_27_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializer.java_794-795": {
      "loc": "794-795",
      "input": "<s> @SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithExternalTypeId(JsonParser p, DeserializationContext ctxt) throws IOException { final ExternalTypeHandler ext = _externalTypeIdHandler.start(); final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { /* if (ext.handlePropertyValue(p, ctxt, propName, buffer)) { */ <mask> ; } else { if (buffer.assignParameter(creatorProp, _deserializeWithErrorWrapping(p, ctxt, creatorProp))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } if (bean.getClass() != _beanType.getRawClass()) { throw ctxt.mappingException(\"Can not create polymorphic instances with unwrapped values\"); } return ext.complete(p, ctxt, bean); } } continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (ext.handlePropertyValue(p, ctxt, propName, null)) { continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } try { return ext.complete(p, ctxt, buffer, creator); } catch (Exception e) { wrapInstantiationProblem(e, ctxt); return null; } } </s> java",
      "function range": "773,5-857,5"
    },
    "JacksonDatabind_33_/src/main/java/com/fasterxml/jackson/databind/introspect/JacksonAnnotationIntrospector.java_748-749": {
      "loc": "748-749",
      "input": "<s> @Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg != null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann != null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ <mask> name = \"\"; } else { return null; } } return PropertyName.construct(name); } </s> java",
      "function range": "730,5-755,5",
      "output": [
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); } else if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ if (name == null) { name = \"\"; } else { return null; } } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonRawValue.class); } else if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); } if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); } else if (_hasAnnotation(a, JsonProperty.class)) { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); } else if (_hasAnnotation(a, JsonProperty.class)) { name = _findAnnotation(a, JsonProperty.class); } else { name = \"\"; } else { return null; } } return PropertyName.construct(name); }",
        "@Override public PropertyName findNameForSerialization(Annotated a) { String name = null; JsonGetter jg = _findAnnotation(a, JsonGetter.class); if (jg!= null) { name = jg.value(); } else { JsonProperty pann = _findAnnotation(a, JsonProperty.class); if (pann!= null) { name = pann.value(); } else if (_hasAnnotation(a, JsonSerialize.class) || _hasAnnotation(a, JsonView.class) /* || _hasAnnotation(a, JsonRawValue.class)) { */ name = _findAnnotation(a, JsonProperty.class); if (name == null) { name = \"\"; } else { return null; } } return PropertyName.construct(name); } return PropertyName.construct(name); }"
      ]
    },
    "JacksonDatabind_34_/src/main/java/com/fasterxml/jackson/databind/ser/std/NumberSerializer.java_81-82": {
      "loc": "81-82",
      "input": "<s> @Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ <mask> } else { visitor.expectNumberFormat(typeHint); } } } </s> java",
      "function range": "73,5-87,5",
      "output": [
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == String.class) { visitor.expectNumberFormat(typeHint); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == BigInteger.class) { visitLongFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == String.class) { visitor.expectStringFormat(typeHint); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == BigInteger.class) { visitor.expectNumberFormat(typeHint); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); visitor.expectNumberFormat(typeHint); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == Integer.class) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == String.class) { visitStringFormat(visitor, typeHint, JsonParser.NumberType.STRING); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitor.expectNumberFormat(typeHint); } else if (h == String.class) { visitStringFormat(visitor, typeHint, JsonParser.NumberType.BIG_STRING); } else { visitor.expectNumberFormat(typeHint); } } }",
        "@Override public void acceptJsonFormatVisitor(JsonFormatVisitorWrapper visitor, JavaType typeHint) throws JsonMappingException { if (_isInt) { visitIntFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else { Class<?> h = handledType(); if (h == BigDecimal.class) { /* visitFloatFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); */ visitDoubleFormat(visitor, typeHint, JsonParser.NumberType.BIG_INTEGER); } else if (h == String.class) { visitStringFormat(visitor, typeHint, JsonParser.NumberType.STRING); } else { visitor.expectNumberFormat(typeHint); } } }"
      ]
    },
    "JacksonDatabind_37_/src/main/java/com/fasterxml/jackson/databind/type/SimpleType.java_135-136": {
      "loc": "135-136",
      "input": "<s> @Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ <mask> _valueHandler, _typeHandler, _asStatic); } </s> java",
      "function range": "119,5-137,5",
      "output": [
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ ); */ return new SimpleType(subclass, _bindings, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ _bindings, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ ) */ return new SimpleType(subclass, _bindings, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ ); */ return new JavaType(subclass, _bindings, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ _valueHandler, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ _typeHandler, _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ _valueHandler, _typeHandler, _asStatic); */ return super.narrow(subclass); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ _valueHandler, _typeHandler, _asStatic); }",
        "@Override protected JavaType _narrow(Class<?> subclass) { if (_class == subclass) { return this; } /* return new SimpleType(subclass, _bindings, _superClass, _superInterfaces, */ ); */ return super.narrow(subclass); }"
      ]
    },
    "JacksonDatabind_45_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_63-64": {
      "loc": "63-64",
      "input": "<s> @Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property != null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format != null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ <mask> TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern() ? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; } </s> java",
      "function range": "49,5-81,5",
      "output": [
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } else { final TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } else { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ final TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.TRUE, null); } else { final TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.TRUE, null); } else { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } */ if (format.getShape() == JsonFormat.Shape.DATE) { final TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } */ if (format.getShape() == JsonFormat.Shape.DATE) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } */ if (format.getShape() == JsonFormat.Shape.TIME) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } */ if (format.getShape() == JsonFormat.Shape.TIME) { final TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { if (property!= null) { JsonFormat.Value format = serializers.getAnnotationIntrospector().findFormat((Annotated)property.getMember()); if (format!= null) { JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } /* if (format.getShape() == JsonFormat.Shape.STRING) { */ return withFormat(Boolean.FALSE, null); } */ if (format.getShape() == JsonFormat.Shape.TIMEZONE) { TimeZone tz = format.getTimeZone(); final String pattern = format.hasPattern()? format.getPattern() : StdDateFormat.DATE_FORMAT_STR_ISO8601; final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(pattern, loc); if (tz == null) { tz = serializers.getTimeZone(); } df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } } } return this; }"
      ]
    },
    "JacksonDatabind_46_/src/main/java/com/fasterxml/jackson/databind/type/ReferenceType.java_156-157": {
      "loc": "156-157",
      "input": "<s> @Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ <mask> return sb; } </s> java",
      "function range": "150,5-158,5",
      "output": [
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb.append('<'); sb = _referencedType.getGenericSignature(sb); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb); sb.append('<'); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb); sb = _referencedType.getGenericSignature(sb); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb, false); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb.append('<'); sb = _referencedType.getGenericSignature(sb); sb.append('<'); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb = _referencedType.getGenericSignature(sb, false); sb.append('<'); return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ return sb; }",
        "@Override public StringBuilder getGenericSignature(StringBuilder sb) { _classSignature(_class, sb, false); sb.append('<'); sb = _referencedType.getGenericSignature(sb); /* sb.append(';'); */ sb.append('<'); sb = _referencedType.getGenericSignature(sb); sb.append(';'); return sb; }"
      ]
    },
    "JacksonDatabind_57_/src/main/java/com/fasterxml/jackson/databind/ObjectReader.java_1441-1442": {
      "loc": "1441-1442",
      "input": "<s> public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders != null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ <mask> true)); } </s> java",
      "function range": "1435,5-1443,5",
      "output": [
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ _dataFormatReaders.findFormat(src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ src, offset, length, true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ true)); */ return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ offset, length, true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ true)); */ return _detectBindAndReadValues(_parserFactory.createParser(src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ false)); */ return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ false)); */ return _detectBindAndReadValues(_parserFactory.createParser(src, offset, length), true)); }",
        "public <T> MappingIterator<T> readValues(byte[] src, int offset, int length) throws IOException, JsonProcessingException { if (_dataFormatReaders!= null) { return _detectBindAndReadValues(_dataFormatReaders.findFormat(src, offset, length), false); } /* return _bindAndReadValues(_considerFilter(_parserFactory.createParser(src), */ offset, length)); */ return _detectBindAndReadValues(_parserFactory.createParser(src, offset, length), true)); }"
      ]
    },
    "JacksonDatabind_70_/src/main/java/com/fasterxml/jackson/databind/deser/impl/BeanPropertyMap.java_440-441": {
      "loc": "440-441",
      "input": "<s> public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ <mask> if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); } </s> java",
      "function range": "426,5-453,5",
      "output": [
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ found = _propsInOrder[_findFromOrdered(prop)]!= null; if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } found = key.equals(propToRm.getName()); if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+\"' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(propToRm.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+' found, can't remove\"); } init(props); }",
        "public void remove(SettableBeanProperty propToRm) { ArrayList<SettableBeanProperty> props = new ArrayList<SettableBeanProperty>(_size); String key = getPropertyName(propToRm); boolean found = false; for (int i = 1, end = _hashArea.length; i < end; i += 2) { SettableBeanProperty prop = (SettableBeanProperty) _hashArea[i]; if (prop == null) { continue; } if (!found) { /* found = key.equals(prop.getName()); */ if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (key.equals(prop.getName())) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } else if (found) { _propsInOrder[_findFromOrdered(prop)] = null; continue; } } props.add(prop); } if (!found) { throw new NoSuchElementException(\"No entry '\"+propToRm.getName()+' found, can't remove\"); } init(props); }"
      ]
    },
    "JacksonDatabind_71_/src/main/java/com/fasterxml/jackson/databind/deser/std/StdKeyDeserializer.java_75-76": {
      "loc": "75-76",
      "input": "<s> public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ <mask> return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); } </s> java",
      "function range": "70,5-116,5",
      "output": [
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ return StringKD.forType(raw); } else if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ return StringKD.forType(raw); } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ return StringKD.forType(raw); } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind); }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw; }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ return StringKD.forType(raw); } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == String.class || raw == Object.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw; }",
        "public static StdKeyDeserializer forType(Class<?> raw) { int kind; /* if (raw == String.class || raw == Object.class) { */ kind = TYPE_STRING; } else if (raw == String.class) { kind = TYPE_STRING; } else if (raw == StringKD.class) { return StringKD.forType(raw); } else if (raw == UUID.class) { kind = TYPE_UUID; } else if (raw == Integer.class) { kind = TYPE_INT; } else if (raw == Long.class) { kind = TYPE_LONG; } else if (raw == Date.class) { kind = TYPE_DATE; } else if (raw == Calendar.class) { kind = TYPE_CALENDAR; } else if (raw == Boolean.class) { kind = TYPE_BOOLEAN; } else if (raw == Byte.class) { kind = TYPE_BYTE; } else if (raw == Character.class) { kind = TYPE_CHAR; } else if (raw == Short.class) { kind = TYPE_SHORT; } else if (raw == Float.class) { kind = TYPE_FLOAT; } else if (raw == Double.class) { kind = TYPE_DOUBLE; } else if (raw == URI.class) { kind = TYPE_URI; } else if (raw == URL.class) { kind = TYPE_URL; } else if (raw == Class.class) { kind = TYPE_CLASS; } else if (raw == Locale.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Locale.class); return new StdKeyDeserializer(TYPE_LOCALE, raw, deser); } else if (raw == Currency.class) { FromStringDeserializer<?> deser = FromStringDeserializer.findDeserializer(Currency.class); return new StdKeyDeserializer(TYPE_CURRENCY, raw, deser); } else { return null; } return new StdKeyDeserializer(kind, raw); } }"
      ]
    },
    "JacksonDatabind_76_/src/main/java/com/fasterxml/jackson/databind/deser/BuilderBasedDeserializer.java_583-604": {
      "loc": "583-604",
      "input": "<s> @SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp != null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass() != _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ <mask> continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop != null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps != null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter != null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { return wrapInstantiationProblem(e, ctxt); } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } </s> java",
      "function range": "565,5-637,5",
      "output": [
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapProblem(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt,",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } Object bean; try",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p,",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapProblem(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } Object bean; try {",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } if (t!= JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapProblem(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { return wrapProblem(e, ctxt); } return _unwrappedPropertyHandler.processUnwrapped(p",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } if (t == JsonToken.FIELD_NAME) { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt, bean); } return _unwrappedPropertyHandler.processUnwrapped(",
        "@SuppressWarnings(\"resource\") protected Object deserializeUsingPropertyBasedWithUnwrapped(JsonParser p, DeserializationContext ctxt) throws IOException, JsonProcessingException { final PropertyBasedCreator creator = _propertyBasedCreator; PropertyValueBuffer buffer = creator.startBuilding(p, ctxt, _objectIdReader); TokenBuffer tokens = new TokenBuffer(p, ctxt); tokens.writeStartObject(); JsonToken t = p.getCurrentToken(); for (; t == JsonToken.FIELD_NAME; t = p.nextToken()) { String propName = p.getCurrentName(); p.nextToken(); SettableBeanProperty creatorProp = creator.findCreatorProperty(propName); if (creatorProp!= null) { /* if (buffer.assignParameter(creatorProp, creatorProp.deserialize(p, ctxt))) { t = p.nextToken(); Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapAndThrow(e, _beanType.getRawClass(), propName, ctxt); continue; } while (t == JsonToken.FIELD_NAME) { p.nextToken(); tokens.copyCurrentStructure(p); t = p.nextToken(); } tokens.writeEndObject(); if (bean.getClass()!= _beanType.getRawClass()) { ctxt.reportMappingException(\"Can not create polymorphic instances with unwrapped values\"); return null; } return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } */ } else { continue; } if (buffer.readIdProperty(propName)) { continue; } SettableBeanProperty prop = _beanProperties.find(propName); if (prop!= null) { buffer.bufferProperty(prop, prop.deserialize(p, ctxt)); continue; } if (_ignorableProps!= null && _ignorableProps.contains(propName)) { handleIgnoredProperty(p, ctxt, handledType(), propName); continue; } tokens.writeFieldName(propName); tokens.copyCurrentStructure(p); if (_anySetter!= null) { buffer.bufferAnyProperty(_anySetter, propName, _anySetter.deserialize(p, ctxt)); } } Object bean; try { bean = creator.build(ctxt, buffer); } catch (Exception e) { wrapInstantiation(e, ctxt); return _unwrappedPropertyHandler.processUnwrapped(p, ctxt, bean, tokens); } return bean; }"
      ]
    },
    "JacksonDatabind_82_/src/main/java/com/fasterxml/jackson/databind/deser/BeanDeserializerFactory.java_495-496": {
      "loc": "495-496",
      "input": "<s> protected void addBeanProps(DeserializationContext ctxt, BeanDescription beanDesc, BeanDeserializerBuilder builder) throws JsonMappingException { final boolean isConcrete = !beanDesc.getType().isAbstract(); final SettableBeanProperty[] creatorProps = isConcrete ? builder.getValueInstantiator().getFromObjectArguments(ctxt.getConfig()) : null; final boolean hasCreatorProps = (creatorProps != null); JsonIgnoreProperties.Value ignorals = ctxt.getConfig() .getDefaultPropertyIgnorals(beanDesc.getBeanClass(), beanDesc.getClassInfo()); Set<String> ignored; if (ignorals != null) { boolean ignoreAny = ignorals.getIgnoreUnknown(); builder.setIgnoreUnknownProperties(ignoreAny); /* ignored = ignorals.getIgnored(); */ <mask> for (String propName : ignored) { builder.addIgnorable(propName); } } else { ignored = Collections.emptySet(); } AnnotatedMethod anySetterMethod = beanDesc.findAnySetter(); AnnotatedMember anySetterField = null; if (anySetterMethod != null) { builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterMethod)); } else { anySetterField = beanDesc.findAnySetterField(); if(anySetterField != null) { builder.setAnySetter(constructAnySetter(ctxt, beanDesc, anySetterField)); } } if (anySetterMethod == null && anySetterField == null) { Collection<String> ignored2 = beanDesc.getIgnoredPropertyNames(); if (ignored2 != null) { for (String propName : ignored2) { builder.addIgnorable(propName); } } } final boolean useGettersAsSetters = ctxt.isEnabled(MapperFeature.USE_GETTERS_AS_SETTERS) && ctxt.isEnabled(MapperFeature.AUTO_DETECT_GETTERS); List<BeanPropertyDefinition> propDefs = filterBeanProps(ctxt, beanDesc, builder, beanDesc.findProperties(), ignored); if (_factoryConfig.hasDeserializerModifiers()) { for (BeanDeserializerModifier mod : _factoryConfig.deserializerModifiers()) { propDefs = mod.updateProperties(ctxt.getConfig(), beanDesc, propDefs); } } for (BeanPropertyDefinition propDef : propDefs) { SettableBeanProperty prop = null; if (propDef.hasSetter()) { JavaType propertyType = propDef.getSetter().getParameterType(0); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (propDef.hasField()) { JavaType propertyType = propDef.getField().getType(); prop = constructSettableProperty(ctxt, beanDesc, propDef, propertyType); } else if (useGettersAsSetters && propDef.hasGetter()) { AnnotatedMethod getter = propDef.getGetter(); Class<?> rawPropertyType = getter.getRawType(); if (Collection.class.isAssignableFrom(rawPropertyType) || Map.class.isAssignableFrom(rawPropertyType)) { prop = constructSetterlessProperty(ctxt, beanDesc, propDef); } } if (hasCreatorProps && propDef.hasConstructorParameter()) { final String name = propDef.getName(); CreatorProperty cprop = null; if (creatorProps != null) { for (SettableBeanProperty cp : creatorProps) { if (name.equals(cp.getName()) && (cp instanceof CreatorProperty)) { cprop = (CreatorProperty) cp; break; } } } if (cprop == null) { List<String> n = new ArrayList<>(); for (SettableBeanProperty cp : creatorProps) { n.add(cp.getName()); } ctxt.reportBadPropertyDefinition(beanDesc, propDef, \"Could not find creator property with name '%s' (known Creator properties: %s)\", name, n); continue; } if (prop != null) { cprop.setFallbackSetter(prop); } prop = cprop; builder.addCreatorProperty(cprop); continue; } if (prop != null) { Class<?>[] views = propDef.findViews(); if (views == null) { if (!ctxt.isEnabled(MapperFeature.DEFAULT_VIEW_INCLUSION)) { views = NO_VIEWS; } } prop.setViews(views); builder.addProperty(prop); } } } </s> java",
      "function range": "472,5-615,5"
    },
    "JacksonDatabind_93_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/SubTypeValidator.java_83-85": {
      "loc": "83-85",
      "input": "<s> public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls != Object.class; cls = cls.getSuperclass()) { */ <mask> String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); } </s> java",
      "function range": "67,5-99,5",
      "output": [
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (cls instanceof AbstractPointcutAdvisor) { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getName()) || \"AbstractApplicationContext\".equals(cls.getName())) { break main_check; } String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (cls.getName().startsWith(PREFIX_STRING)) { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getName()) || \"AbstractApplicationContext\".equals(cls.getName())) { break main_check; } } else { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getName()) || \"AbstractApplicationContext\".equals(cls.getName())) { break main_check; } else { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getSimpleName()) || \"AbstractApplicationContext\".equals(cls.getSimpleName())) { break main_check; } if (\"AbstractPointcutAdvisor\".equals(cls.getSimpleName()) || \"AbstractApplicationContext\".equals(cls.getSimpleName())) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getName()) || \"AbstractApplicationContext\".equals(cls.getName())) { break main_check; } } else { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (cls.getName().startsWith(PREFIX_STRING)) { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", raw)); }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (\"AbstractPointcutAdvisor\".equals(cls.getName()) || \"AbstractApplicationContext\".equals(cls.getName())) { break main_check; } else { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); } }",
        "public void validateSubType(DeserializationContext ctxt, JavaType type) throws JsonMappingException { final Class<?> raw = type.getRawClass(); String full = raw.getName(); main_check: do { if (_cfgIllegalClassNames.contains(full)) { break; } /* if (full.startsWith(PREFIX_STRING)) { for (Class<?> cls = raw; cls!= Object.class; cls = cls.getSuperclass()) { */ if (cls.getName().startsWith(PREFIX_STRING)) { String name = cls.getSimpleName(); if (\"AbstractPointcutAdvisor\".equals(name) || \"AbstractApplicationContext\".equals(name)) { break main_check; } } } return; } while (false); throw JsonMappingException.from(ctxt, String.format(\"Illegal type (%s) to deserialize: prevented for security reasons\", full)); } }"
      ]
    },
    "JacksonDatabind_96_/src/main/java/com/fasterxml/jackson/databind/deser/BasicDeserializerFactory.java_735-736": {
      "loc": "735-736",
      "input": "<s> protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1 != candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName != null) || (injectId != null); if (!useProps && (paramDef != null)) { /* paramName = candidate.findImplicitParamName(0); */ <mask> useProps = (paramName != null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef != null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } } </s> java",
      "function range": "701,5-752,5",
      "output": [
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder ) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructor(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator (creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } DEDENT",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } } }",
        "protected void _addExplicitAnyCreator(DeserializationContext ctxt, BeanDescription beanDesc, CreatorCollector creators, CreatorCandidate candidate) throws JsonMappingException { if (1!= candidate.paramCount()) { int oneNotInjected = candidate.findOnlyParamWithoutInjection(); if (oneNotInjected >= 0) { if (candidate.paramName(oneNotInjected) == null) { _addExplicitDelegatingCreator(ctxt, beanDesc, creators, candidate); return; } } _addExplicitPropertyCreator(ctxt, beanDesc, creators, candidate); return; } AnnotatedParameter param = candidate.parameter(0); JacksonInject.Value injectId = candidate.injection(0); PropertyName paramName = candidate.explicitParamName(0); BeanPropertyDefinition paramDef = candidate.propertyDef(0); boolean useProps = (paramName!= null) || (injectId!= null); if (!useProps && (paramDef!= null)) { /* paramName = candidate.findImplicitParamName(0); */ paramName = candidate.findImplicitParamName(0); paramDef = candidate.propertyDef(paramName); } if (paramDef!= null) { useProps = (paramName!= null) && paramDef.couldSerialize(); } if (useProps) { SettableBeanProperty[] properties = new SettableBeanProperty[] { constructCreatorProperty(ctxt, beanDesc, paramName, 0, param, injectId) }; creators.addPropertyCreator(candidate.creator(), true, properties); return; } _handleSingleArgumentCreator(creators, candidate.creator(), true, true); if (paramDef!= null) { ((POJOPropertyBuilder) paramDef).removeConstructors(); } }"
      ]
    },
    "JacksonDatabind_97_/src/main/java/com/fasterxml/jackson/databind/node/POJONode.java_114-115": {
      "loc": "114-115",
      "input": "<s> @Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ <mask> } } </s> java",
      "function range": "104,5-116,5",
      "output": [
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerialize(gen); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerializeNull(gen); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerializeObject(gen); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerializeObject(gen, _value); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerialize(gen, _value); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.serialize(gen, _value); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerialize(gen, ctxt); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerialize(gen); ctxt.defaultSerialize(gen); } }",
        "@Override public final void serialize(JsonGenerator gen, SerializerProvider ctxt) throws IOException { if (_value == null) { ctxt.defaultSerializeNull(gen); } else if (_value instanceof JsonSerializable) { ((JsonSerializable) _value).serialize(gen, ctxt); } else { /* gen.writeObject(_value); */ ctxt.defaultSerialize(gen); ctxt.defaultSerializeNull(gen); } }"
      ]
    },
    "JacksonDatabind_98_/src/main/java/com/fasterxml/jackson/databind/deser/impl/ExternalTypeHandler.java_298-299": {
      "loc": "298-299",
      "input": "<s> public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp != null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ <mask> } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; } </s> java",
      "function range": "255,5-311,5",
      "output": [
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ values[i] = _deserialize(p, ctxt, i, typeId); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } else { buffer.assignParameter(prop, values[i]); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } else { buffer.assignParameter(typeProp, values[i]); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ values[i] = _deserialize(p, ctxt, i, typeId); } else { values[i] = _deserialize(p, ctxt, i, typeId); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } } else { buffer.assignParameter(extProp, typeId); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } } else { buffer.assignParameter(typeId, values[i]); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ values[i] = _deserialize(p, ctxt, i, typeId); } } else { values[i] = _deserialize(p, ctxt, i, typeId); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } else { buffer.assignParameter(typeProp, values[i]); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ } else { buffer.assignParameter(prop, values[i]); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; } return bean; }",
        "public Object complete(JsonParser p, DeserializationContext ctxt, PropertyValueBuffer buffer, PropertyBasedCreator creator) throws IOException { final int len = _properties.length; Object[] values = new Object[len]; for (int i = 0; i < len; ++i) { String typeId = _typeIds[i]; final ExtTypedProperty extProp = _properties[i]; if (typeId == null) { if (_tokens[i] == null) { continue; } if (!extProp.hasDefaultType()) { ctxt.reportInputMismatch(_beanType, \"Missing external type id property '%s'\", extProp.getTypePropertyName()); } else { typeId = extProp.getDefaultTypeId(); } } else if (_tokens[i] == null) { SettableBeanProperty prop = extProp.getProperty(); ctxt.reportInputMismatch(_beanType, \"Missing property '%s' for external type id '%s'\", prop.getName(), _properties[i].getTypePropertyName()); } values[i] = _deserialize(p, ctxt, i, typeId); final SettableBeanProperty prop = extProp.getProperty(); if (prop.getCreatorIndex() >= 0) { buffer.assignParameter(prop, values[i]); SettableBeanProperty typeProp = extProp.getTypeProperty(); if ((typeProp!= null) && (typeProp.getCreatorIndex() >= 0)) { /* buffer.assignParameter(typeProp, typeId); */ values[i] = _deserialize(p, ctxt, i, typeId); } } } Object bean = creator.build(ctxt, buffer); for (int i = 0; i < len; ++i) { SettableBeanProperty prop = _properties[i].getProperty(); if (prop.getCreatorIndex() < 0) { prop.set(bean, values[i]); } } return bean; } return bean; }"
      ]
    },
    "JacksonDatabind_102_/src/main/java/com/fasterxml/jackson/databind/ser/std/DateTimeSerializerBase.java_67-70": {
      "loc": "67-70",
      "input": "<s> @Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ <mask> JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale() ? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone() ? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale && !hasTZ && !asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz != null) && !newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); } </s> java",
      "function range": "61,5-136,5",
      "output": [
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final Type handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final Type handledType = property.getType(); JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final Class handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getBeanType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df); }",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getBeanType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getBeanType().getName(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df);",
        "@Override public JsonSerializer<?> createContextual(SerializerProvider serializers, BeanProperty property) throws JsonMappingException { /* if (property == null) { return this; } */ final String handledType = property.getType(); final JsonFormat.Value format = findFormatOverrides(serializers, property, handledType()); if (format == null) { return this; } JsonFormat.Shape shape = format.getShape(); if (shape.isNumeric()) { return withFormat(Boolean.TRUE, null); } if (format.hasPattern()) { final Locale loc = format.hasLocale()? format.getLocale() : serializers.getLocale(); SimpleDateFormat df = new SimpleDateFormat(format.getPattern(), loc); TimeZone tz = format.hasTimeZone()? format.getTimeZone() : serializers.getTimeZone(); df.setTimeZone(tz); return withFormat(Boolean.FALSE, df); } final boolean hasLocale = format.hasLocale(); final boolean hasTZ = format.hasTimeZone(); final boolean asString = (shape == JsonFormat.Shape.STRING); if (!hasLocale &&!hasTZ &&!asString) { return this; } DateFormat df0 = serializers.getConfig().getDateFormat(); if (df0 instanceof StdDateFormat) { StdDateFormat std = (StdDateFormat) df0; if (format.hasLocale()) { std = std.withLocale(format.getLocale()); } if (format.hasTimeZone()) { std = std.withTimeZone(format.getTimeZone()); } return withFormat(Boolean.FALSE, std); } if (!(df0 instanceof SimpleDateFormat)) { serializers.reportBadDefinition(handledType(), String.format( \"Configured `DateFormat` (%s) not a `SimpleDateFormat`; cannot configure `Locale` or `TimeZone`\", df0.getClass().getName())); } SimpleDateFormat df = (SimpleDateFormat) df0; if (hasLocale) { df = new SimpleDateFormat(df.toPattern(), format.getLocale()); } else { df = (SimpleDateFormat) df.clone(); } TimeZone newTz = format.getTimeZone(); boolean changeTZ = (newTz!= null) &&!newTz.equals(df.getTimeZone()); if (changeTZ) { df.setTimeZone(newTz); } return withFormat(Boolean.FALSE, df.clone()); }"
      ]
    },
    "JacksonDatabind_107_/src/main/java/com/fasterxml/jackson/databind/jsontype/impl/TypeDeserializerBase.java_165-166": {
      "loc": "165-166",
      "input": "<s> protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ <mask> } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType != null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; } </s> java",
      "function range": "146,5-199,5",
      "output": [
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return ctxt.getTypeFactory().constructSpecializedType(type.getRawClass(), type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.getTypeFactory().constructSpecializedType(actual, type.getRawClass()); } else { deser = ctxt.getTypeFactory().constructSpecializedType(actual, type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.getTypeFactory().constructSpecializedType(actual, type.getRawClass()); if (deser == null) { /* return null; */ } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } else { deser = ctxt.findDefaultImplDeserializer(ctxt); _deserializers.put(typeId, deser); } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return ctxt.getTypeFactory().constructSpecializedType(type.getRawClass(), type.getRawClass()); } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } return deser; } return deser; }",
        "protected final JsonDeserializer<Object> _findDeserializer(DeserializationContext ctxt, String typeId) throws IOException { JsonDeserializer<Object> deser = _deserializers.get(typeId); if (deser == null) { JavaType type = _idResolver.typeFromId(ctxt, typeId); if (type == null) { deser = _findDefaultImplDeserializer(ctxt); if (deser == null) { JavaType actual = _handleUnknownTypeId(ctxt, typeId); if (actual == null) { /* return null; */ return null; } deser = ctxt.findContextualValueDeserializer(actual, _property); } } else { if ((_baseType!= null) && _baseType.getClass() == type.getClass()) { if (!type.hasGenericTypes()) { type = ctxt.getTypeFactory().constructSpecializedType(_baseType, type.getRawClass()); } } deser = ctxt.findContextualValueDeserializer(type, _property); } _deserializers.put(typeId, deser); } else { deser = ctxt.findDefaultImplDeserializer(ctxt); if (deser == null) { deser = ctxt.findContextualValueDeserializer(type, _property); } } return deser; }"
      ]
    },
    "JacksonXml_5_/src/main/java/com/fasterxml/jackson/dataformat/xml/ser/XmlSerializerProvider.java_59-60": {
      "loc": "59-60",
      "input": "<s> protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ <mask> } </s> java",
      "function range": "55,5-60,5",
      "output": [
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ this._rootNameLookup = src._rootNameLookup; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _rootNameLookup = src._rootNameLookup; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _namespaceLookup = src._namespaceLookup; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ rootNameLookup = src._rootNameLookup; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _rootNameLookup = null; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _rootName = src._rootName; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _xmlSerializerProvider = src; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ _rootNameLookup = src.rootNameLookup; }",
        "protected XmlSerializerProvider(XmlSerializerProvider src) { super(src); /* _rootNameLookup = src._rootNameLookup; */ this._rootNameLookup = src.rootNameLookup; }"
      ]
    },
    "Jsoup_1_/src/main/java/org/jsoup/nodes/Document.java_125-127": {
      "loc": "125-127",
      "input": "<s> private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ <mask> } } </s> java",
      "function range": "113,5-128,5",
      "output": [
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ element.removeChild(node); } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ } for (Node node: element.childNodes) { element.removeChild(node); } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ body().removeChild(node); } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ if (node instanceof TextNode) { element.removeChild(node); } } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ element.removeChild(node); element.removeChild(node); } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ element.removeChild(node); /* body().removeChild(node); */ } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ body().removeChild(node); element.removeChild(node); } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ body().removeChild(node); /* body().removeChild(node); */ } }",
        "private void normalise(Element element) { List<Node> toMove = new ArrayList<Node>(); for (Node node: element.childNodes) { if (node instanceof TextNode) { TextNode tn = (TextNode) node; if (!tn.isBlank()) toMove.add(tn); } } for (Node node: toMove) { element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); body().appendChild(node); */ element.removeChild(node); /* body().appendChild(new TextNode(\" \", \"\")); */ } }"
      ]
    },
    "Jsoup_15_/src/main/java/org/jsoup/parser/TreeBuilderState.java_283-284": {
      "loc": "283-284",
      "input": "<s> boolean process(Token t, TreeBuilder tb) { switch (t.type) { case Character: { Token.Character c = t.asCharacter(); if (c.getData().equals(nullString)) { tb.error(this); return false; } else if (isWhitespace(c)) { tb.reconstructFormattingElements(); tb.insert(c); } else { tb.reconstructFormattingElements(); tb.insert(c); tb.framesetOk(false); } break; } case Comment: { tb.insert(t.asComment()); break; } case Doctype: { tb.error(this); return false; } case StartTag: Token.StartTag startTag = t.asStartTag(); String name = startTag.name(); if (name.equals(\"html\")) { tb.error(this); Element html = tb.getStack().getFirst(); for (Attribute attribute : startTag.getAttributes()) { if (!html.hasAttr(attribute.getKey())) html.attributes().put(attribute); } /* } else if (StringUtil.in(name, \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"style\", \"title\")) { */ <mask> return tb.process(t, InHead); } else if (name.equals(\"body\")) { tb.error(this); LinkedList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) { return false; } else { tb.framesetOk(false); Element body = stack.get(1); for (Attribute attribute : startTag.getAttributes()) { if (!body.hasAttr(attribute.getKey())) body.attributes().put(attribute); } } } else if (name.equals(\"frameset\")) { tb.error(this); LinkedList<Element> stack = tb.getStack(); if (stack.size() == 1 || (stack.size() > 2 && !stack.get(1).nodeName().equals(\"body\"))) { return false; } else if (!tb.framesetOk()) { return false; } else { Element second = stack.get(1); if (second.parent() != null) second.remove(); while (stack.size() > 1) stack.removeLast(); tb.insert(startTag); tb.transition(InFrameset); } } else if (StringUtil.in(name, \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } if (StringUtil.in(tb.currentElement().nodeName(), \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) { tb.error(this); tb.pop(); } tb.insert(startTag); } else if (StringUtil.in(name, \"pre\", \"listing\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); tb.framesetOk(false); } else if (name.equals(\"form\")) { if (tb.getFormElement() != null) { tb.error(this); return false; } if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } Element form = tb.insert(startTag); tb.setFormElement(form); } else if (name.equals(\"li\")) { tb.framesetOk(false); LinkedList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (el.nodeName().equals(\"li\")) { tb.process(new Token.EndTag(\"li\")); break; } if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\")) break; } if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); } else if (StringUtil.in(name, \"dd\", \"dt\")) { tb.framesetOk(false); LinkedList<Element> stack = tb.getStack(); for (int i = stack.size() - 1; i > 0; i--) { Element el = stack.get(i); if (StringUtil.in(el.nodeName(), \"dd\", \"dt\")) { tb.process(new Token.EndTag(el.nodeName())); break; } if (tb.isSpecial(el) && !StringUtil.in(el.nodeName(), \"address\", \"div\", \"p\")) break; } if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); } else if (name.equals(\"plaintext\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); tb.tokeniser.transition(TokeniserState.PLAINTEXT); } else if (name.equals(\"button\")) { if (tb.inButtonScope(\"button\")) { tb.error(this); tb.process(new Token.EndTag(\"button\")); tb.process(startTag); } else { tb.reconstructFormattingElements(); tb.insert(startTag); tb.framesetOk(false); } } else if (name.equals(\"a\")) { if (tb.getActiveFormattingElement(\"a\") != null) { tb.error(this); tb.process(new Token.EndTag(\"a\")); Element remainingA = tb.getFromStack(\"a\"); if (remainingA != null) { tb.removeFromActiveFormattingElements(remainingA); tb.removeFromStack(remainingA); } } tb.reconstructFormattingElements(); Element a = tb.insert(startTag); tb.pushActiveFormattingElements(a); } else if (StringUtil.in(name, \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) { tb.reconstructFormattingElements(); Element el = tb.insert(startTag); tb.pushActiveFormattingElements(el); } else if (name.equals(\"nobr\")) { tb.reconstructFormattingElements(); if (tb.inScope(\"nobr\")) { tb.error(this); tb.process(new Token.EndTag(\"nobr\")); tb.reconstructFormattingElements(); } Element el = tb.insert(startTag); tb.pushActiveFormattingElements(el); } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.insertMarkerToFormattingElements(); tb.framesetOk(false); } else if (name.equals(\"table\")) { if (tb.getDocument().quirksMode() != Document.QuirksMode.quirks && tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insert(startTag); tb.framesetOk(false); tb.transition(InTable); } else if (StringUtil.in(name, \"area\", \"br\", \"embed\", \"img\", \"keygen\", \"wbr\")) { tb.reconstructFormattingElements(); tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals(\"input\")) { tb.reconstructFormattingElements(); Element el = tb.insertEmpty(startTag); if (!el.attr(\"type\").equalsIgnoreCase(\"hidden\")) tb.framesetOk(false); } else if (StringUtil.in(name, \"param\", \"source\", \"track\")) { tb.insertEmpty(startTag); } else if (name.equals(\"hr\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.insertEmpty(startTag); tb.framesetOk(false); } else if (name.equals(\"image\")) { startTag.name(\"img\"); return tb.process(startTag); } else if (name.equals(\"isindex\")) { tb.error(this); if (tb.getFormElement() != null) return false; tb.tokeniser.acknowledgeSelfClosingFlag(); tb.process(new Token.StartTag(\"form\")); if (startTag.attributes.hasKey(\"action\")) { Element form = tb.getFormElement(); form.attr(\"action\", startTag.attributes.get(\"action\")); } tb.process(new Token.StartTag(\"hr\")); tb.process(new Token.StartTag(\"label\")); String prompt = startTag.attributes.hasKey(\"prompt\") ? startTag.attributes.get(\"prompt\") : \"This is a searchable index. Enter search keywords: \"; tb.process(new Token.Character(prompt)); Attributes inputAttribs = new Attributes(); for (Attribute attr : startTag.attributes) { if (!StringUtil.in(attr.getKey(), \"name\", \"action\", \"prompt\")) inputAttribs.put(attr); } inputAttribs.put(\"name\", \"isindex\"); tb.process(new Token.StartTag(\"input\", inputAttribs)); tb.process(new Token.EndTag(\"label\")); tb.process(new Token.StartTag(\"hr\")); tb.process(new Token.EndTag(\"form\")); } else if (name.equals(\"textarea\")) { tb.insert(startTag); tb.tokeniser.transition(TokeniserState.Rcdata); tb.markInsertionMode(); tb.framesetOk(false); tb.transition(Text); } else if (name.equals(\"xmp\")) { if (tb.inButtonScope(\"p\")) { tb.process(new Token.EndTag(\"p\")); } tb.reconstructFormattingElements(); tb.framesetOk(false); handleRawtext(startTag, tb); } else if (name.equals(\"iframe\")) { tb.framesetOk(false); handleRawtext(startTag, tb); } else if (name.equals(\"noembed\")) { handleRawtext(startTag, tb); } else if (name.equals(\"select\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.framesetOk(false); TreeBuilderState state = tb.state(); if (state.equals(InTable) || state.equals(InCaption) || state.equals(InTableBody) || state.equals(InRow) || state.equals(InCell)) tb.transition(InSelectInTable); else tb.transition(InSelect); } else if (StringUtil.in(\"optgroup\", \"option\")) { if (tb.currentElement().nodeName().equals(\"option\")) tb.process(new Token.EndTag(\"option\")); tb.reconstructFormattingElements(); tb.insert(startTag); } else if (StringUtil.in(\"rp\", \"rt\")) { if (tb.inScope(\"ruby\")) { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(\"ruby\")) { tb.error(this); tb.popStackToBefore(\"ruby\"); } tb.insert(startTag); } } else if (name.equals(\"math\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.tokeniser.acknowledgeSelfClosingFlag(); } else if (name.equals(\"svg\")) { tb.reconstructFormattingElements(); tb.insert(startTag); tb.tokeniser.acknowledgeSelfClosingFlag(); } else if (StringUtil.in(name, \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\")) { tb.error(this); return false; } else { tb.reconstructFormattingElements(); tb.insert(startTag); } break; case EndTag: Token.EndTag endTag = t.asEndTag(); name = endTag.name(); if (name.equals(\"body\")) { if (!tb.inScope(\"body\")) { tb.error(this); return false; } else { tb.transition(AfterBody); } } else if (name.equals(\"html\")) { boolean notIgnored = tb.process(new Token.EndTag(\"body\")); if (notIgnored) return tb.process(endTag); } else if (StringUtil.in(name, \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\")) { if (!tb.inScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (name.equals(\"form\")) { Element currentForm = tb.getFormElement(); tb.setFormElement(null); if (currentForm == null || !tb.inScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.removeFromStack(currentForm); } } else if (name.equals(\"p\")) { if (!tb.inButtonScope(name)) { tb.error(this); tb.process(new Token.StartTag(name)); return tb.process(endTag); } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (name.equals(\"li\")) { if (!tb.inListItemScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (StringUtil.in(name, \"dd\", \"dt\")) { if (!tb.inScope(name)) { tb.error(this); return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); } } else if (StringUtil.in(name, \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\")) { if (!tb.inScope(new String[]{\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"})) { tb.error(this); return false; } else { tb.generateImpliedEndTags(name); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\"); } } else if (name.equals(\"sarcasm\")) { return anyOtherEndTag(t, tb); } else if (StringUtil.in(name, \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\")) { OUTER: for (int i = 0; i < 8; i++) { Element formatEl = tb.getActiveFormattingElement(name); if (formatEl == null) return anyOtherEndTag(t, tb); else if (!tb.onStack(formatEl)) { tb.error(this); tb.removeFromActiveFormattingElements(formatEl); return true; } else if (!tb.inScope(formatEl.nodeName())) { tb.error(this); return false; } else if (tb.currentElement() != formatEl) tb.error(this); Element furthestBlock = null; Element commonAncestor = null; boolean seenFormattingElement = false; LinkedList<Element> stack = tb.getStack(); for (int si = 0; si < stack.size(); si++) { Element el = stack.get(si); if (el == formatEl) { commonAncestor = stack.get(si - 1); seenFormattingElement = true; } else if (seenFormattingElement && tb.isSpecial(el)) { furthestBlock = el; break; } } if (furthestBlock == null) { tb.popStackToClose(formatEl.nodeName()); tb.removeFromActiveFormattingElements(formatEl); return true; } Element node = furthestBlock; Element lastNode = furthestBlock; INNER: for (int j = 0; j < 3; j++) { if (tb.onStack(node)) node = tb.aboveOnStack(node); if (!tb.isInActiveFormattingElements(node)) { tb.removeFromStack(node); continue INNER; } else if (node == formatEl) break INNER; Element replacement = new Element(Tag.valueOf(node.nodeName()), tb.getBaseUri()); tb.replaceActiveFormattingElement(node, replacement); tb.replaceOnStack(node, replacement); node = replacement; if (lastNode == furthestBlock) { } if (lastNode.parent() != null) lastNode.remove(); node.appendChild(lastNode); lastNode = node; } if (StringUtil.in(commonAncestor.nodeName(), \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\")) { if (lastNode.parent() != null) lastNode.remove(); tb.insertInFosterParent(lastNode); } else { if (lastNode.parent() != null) lastNode.remove(); commonAncestor.appendChild(lastNode); } Element adopter = new Element(Tag.valueOf(name), tb.getBaseUri()); Node[] childNodes = furthestBlock.childNodes().toArray(new Node[furthestBlock.childNodes().size()]); for (Node childNode : childNodes) { adopter.appendChild(childNode); } furthestBlock.appendChild(adopter); tb.removeFromActiveFormattingElements(formatEl); tb.removeFromStack(formatEl); tb.insertOnStackAfter(furthestBlock, adopter); } } else if (StringUtil.in(name, \"applet\", \"marquee\", \"object\")) { if (!tb.inScope(\"name\")) { if (!tb.inScope(name)) { tb.error(this); return false; } tb.generateImpliedEndTags(); if (!tb.currentElement().nodeName().equals(name)) tb.error(this); tb.popStackToClose(name); tb.clearFormattingElementsToLastMarker(); } } else if (name.equals(\"br\")) { tb.error(this); tb.process(new Token.StartTag(\"br\")); return false; } else { return anyOtherEndTag(t, tb); } break; case EOF: break; } return true; } </s> java",
      "function range": "246,9-761,9"
    },
    "Jsoup_24_/src/main/java/org/jsoup/parser/TokeniserState.java_558-559": {
      "loc": "558-559",
      "input": "<s> void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ <mask> return; } if (t.isAppropriateEndTagToken() && !r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case ' ': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } } </s> java",
      "function range": "553,9-586,9",
      "output": [
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ } else { anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ } else { t.dataBuffer.append(r.consumeLetterSequence()); anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case'>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ } else { anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case'>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/'': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ } else { anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } } else { anythingElse(t, r); } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { anythingElse(t, r); } } }",
        "void read(Tokeniser t, CharacterReader r) { if (r.matchesLetter()) { String name = r.consumeLetterSequence(); t.tagPending.appendTagName(name.toLowerCase()); t.dataBuffer.append(name); /* r.advance(); */ } else { t.dataBuffer.append(r.consumeLetterSequence()); anythingElse(t, r); return; } if (t.isAppropriateEndTagToken() &&!r.isEmpty()) { char c = r.consume(); switch (c) { case '\\t': case '\\n': case '\\f': case'': t.transition(BeforeAttributeName); break; case '/': t.transition(SelfClosingStartTag); break; case '>': t.emitTagPending(); t.transition(Data); break; default: t.dataBuffer.append(c); anythingElse(t, r); break; } } else { somethingElse(t, r); } }"
      ]
    },
    "Jsoup_34_/src/main/java/org/jsoup/parser/CharacterReader.java_91-92": {
      "loc": "91-92",
      "input": "<s> int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar != input[offset]) while(++offset < length && startChar != input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ <mask> for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; } </s> java",
      "function range": "82,5-98,5",
      "output": [
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ for (int j = 1; j < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i)!= input[offset]) for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i) == input[offset]) for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i) == input[offset]); for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i)!= input[i]) for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ for (int j = 1; j < last && seq.charAt(j) == input[i]; i++, j++) if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++) if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i) == input[offset]); for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++)); if (i == last) return offset - pos; } } return -1; }",
        "int nextIndexOf(CharSequence seq) { char startChar = seq.charAt(0); for (int offset = pos; offset < length; offset++) { if (startChar!= input[offset]) while(++offset < length && startChar!= input[offset]); int i = offset + 1; int last = i + seq.length()-1; /* if (offset < length) { */ while (++offset < length && seq.charAt(i)!= input[offset]) for (int j = 1; i < last && seq.charAt(j) == input[i]; i++, j++)); if (i == last) return offset - pos; } } return -1; }"
      ]
    },
    "Jsoup_37_/src/main/java/org/jsoup/nodes/Element.java_1101-1102": {
      "loc": "1101-1102",
      "input": "<s> public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ <mask> } </s> java",
      "function range": "1098,5-1102,5",
      "output": [
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString().trim(); }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString(); }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString().toLowerCase(); }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString().trim(); }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return \"\"; }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum; }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString().trim() ; }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return accum.toString().trim(); } }",
        "public String html() { StringBuilder accum = new StringBuilder(); html(accum); /* return accum.toString().trim(); */ return null; }"
      ]
    },
    "Jsoup_40_/src/main/java/org/jsoup/nodes/DocumentType.java_22-23": {
      "loc": "22-23",
      "input": "<s> public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ <mask> attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); } </s> java",
      "function range": "19,5-26,5",
      "output": [
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ /* Validate.notEmpty(publicId); */ /* Validate.notEmpty(systemId); */ attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ Validate.notEmpty(publicId); Validate.notEmpty(systemId); Validate.notEmpty(baseUri); attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ this.name = name; this.publicId = publicId; this.systemId = systemId; attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ /* Validate.notEmpty(publicId); */ attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ // Validate.notEmpty(publicId); /* Validate.notEmpty(systemId); */ attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ // Validate.notEmpty(publicId); // Validate.notEmpty(systemId); attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ // Validate.notEmpty(publicId); // Validate.notEmpty(systemId); // Validate.notEmpty(baseUri); attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType(String name, String publicId, String systemId, String baseUri) { super(baseUri); /* Validate.notEmpty(name); */ attr(\"type\", \"document\"); attr(\"name\", name); attr(\"publicId\", publicId); attr(\"systemId\", systemId); }",
        "public DocumentType() { super(baseUri); /* Validate.notEmpty(name); */ }"
      ]
    },
    "Jsoup_41_/src/main/java/org/jsoup/nodes/Element.java_1175-1176": {
      "loc": "1175-1176",
      "input": "<s> @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ <mask> } </s> java",
      "function range": "1167,5-1176,5",
      "output": [
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ return super.equals(element); }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null ||!element.equals(this)) return false; return true; }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null) return false; return super.equals(element); }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null || getClass()!= o.getClass()) return false; return super.equals(element); }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (getClass()!= element.getClass()) return false; return super.equals(element); }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null ||!element.equals(this)) return false; return super.equals(element); }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null || getClass()!= o.getClass()) return false; return true; }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element == null) return false; return true; }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (element.getId()!= element.getId()) return false; return true; }",
        "@Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass()!= o.getClass()) return false; if (!super.equals(o)) return false; Element element = (Element) o; /* return this == o; */ if (getClass()!= element.getClass()) return false; return true; }"
      ]
    },
    "Jsoup_43_/src/main/java/org/jsoup/nodes/Element.java_574-575": {
      "loc": "574-575",
      "input": "<s> private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ <mask> return i; } return null; } </s> java",
      "function range": "568,5-578,5",
      "output": [
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(search)) return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(search)) { return i; } return null; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element!= null && element.equals(search)) return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(element)) return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (indexInList(element, elements)) return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(elements.get(i))) return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(search)) { return i; } return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(search)) { return i; } } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.equals(search)) { return i; } return null; }",
        "private static <E extends Element> Integer indexInList(Element search, List<E> elements) { Validate.notNull(search); Validate.notNull(elements); for (int i = 0; i < elements.size(); i++) { E element = elements.get(i); /* if (element.equals(search)) */ if (element.getName().equals(search.getName())) { return i; } return null; }"
      ]
    },
    "Jsoup_45_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_394-395": {
      "loc": "394-395",
      "input": "<s> void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) && !last)) { */ <mask> transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } } </s> java",
      "function range": "382,5-429,5",
      "output": [
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"td\".equals(name) || \"td\".equals(name) &&!last) { transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.BeforeCell); break; } else if (\"td\".equals(name) || \"td\".equals(name) &&!last) { transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.BeforeCell); break; } else if (\"td\".equals(name) || \"td\".equals(name) &&!last) { transition(HtmlTreeBuilderState.BeforeCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"td\".equals(name) || \"td\".equals(name) &&!last) { transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } } }",
        "void resetInsertionMode() { boolean last = false; for (int pos = stack.size() -1; pos >= 0; pos--) { Element node = stack.get(pos); if (pos == 0) { last = true; node = contextElement; } String name = node.nodeName(); if (\"select\".equals(name)) { transition(HtmlTreeBuilderState.InSelect); break; /* } else if ((\"td\".equals(name) || \"td\".equals(name) &&!last)) { */ transition(HtmlTreeBuilderState.InCell); break; } else if (\"tr\".equals(name)) { transition(HtmlTreeBuilderState.InRow); break; } else if (\"tbody\".equals(name) || \"thead\".equals(name) || \"tfoot\".equals(name)) { transition(HtmlTreeBuilderState.InTableBody); break; } else if (\"caption\".equals(name)) { transition(HtmlTreeBuilderState.InCaption); break; } else if (\"colgroup\".equals(name)) { transition(HtmlTreeBuilderState.InColumnGroup); break; } else if (\"table\".equals(name)) { transition(HtmlTreeBuilderState.InTable); break; } else if (\"head\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"body\".equals(name)) { transition(HtmlTreeBuilderState.InBody); break; } else if (\"frameset\".equals(name)) { transition(HtmlTreeBuilderState.InFrameset); break; } else if (\"html\".equals(name)) { transition(HtmlTreeBuilderState.BeforeHead); break; } else if (last) { transition(HtmlTreeBuilderState.InBody); break; } } } }",
        "void resetInsertionMode(); }"
      ]
    },
    "Jsoup_46_/src/main/java/org/jsoup/nodes/Entities.java_118-119": {
      "loc": "118-119",
      "input": "<s> static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ <mask> break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } </s> java",
      "function range": "79,5-154,5",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ accum.append(c); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'<': accum.append(\"&lt;\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'' : accum.append(c); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; default: accum.append(c); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'=': accum.append(\"&quot;\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'' : accum.append(\"&'\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'' : accum.append(\"&quot;\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ accum.append(c); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'<': accum.append(\"&lt;\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else /* accum.append(c); */ break; case'<': accum.append(\"&lt;\"); break; case '<': if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }"
      ]
    },
    "Jsoup_47_/src/main/java/org/jsoup/nodes/Entities.java_122-123": {
      "loc": "122-123",
      "input": "<s> static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite && !reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode != EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ <mask> accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } </s> java",
      "function range": "79,5-155,5",
      "output": [
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (escapeMode!= EscapeMode.xhtml) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (escapeMode == EscapeMode.xhtml) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (canEncode(coreCharset, c, encoder)) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (escapeMode!= EscapeMode.xhtml) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (escapeMode == EscapeMode.xhtml) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }",
        "static void escape(StringBuilder accum, String string, Document.OutputSettings out, boolean inAttribute, boolean normaliseWhite, boolean stripLeadingWhite) { boolean lastWasWhite = false; boolean reachedNonWhite = false; final EscapeMode escapeMode = out.escapeMode(); final CharsetEncoder encoder = out.encoder(); final CoreCharset coreCharset = CoreCharset.byName(encoder.charset().name()); final Map<Character, String> map = escapeMode.getMap(); final int length = string.length(); int codePoint; for (int offset = 0; offset < length; offset += Character.charCount(codePoint)) { codePoint = string.codePointAt(offset); if (normaliseWhite) { if (StringUtil.isWhitespace(codePoint)) { if ((stripLeadingWhite &&!reachedNonWhite) || lastWasWhite) continue; accum.append(' '); lastWasWhite = true; continue; } else { lastWasWhite = false; reachedNonWhite = true; } } if (codePoint < Character.MIN_SUPPLEMENTARY_CODE_POINT) { final char c = (char) codePoint; switch (c) { case '&': accum.append(\"&amp;\"); break; case 0xA0: if (escapeMode!= EscapeMode.xhtml) accum.append(\"&nbsp;\"); else accum.append(\"&#xa0;\"); break; case '<': /* if (!inAttribute) */ if (!inAttribute) accum.append(\"&lt;\"); else accum.append(c); break; case '>': if (!inAttribute) accum.append(\"&gt;\"); else accum.append(c); break; case '\"': if (inAttribute) accum.append(\"&quot;\"); else accum.append(c); break; default: if (canEncode(coreCharset, c, encoder)) accum.append(c); else if (map.containsKey(c)) accum.append('&').append(map.get(c)).append(';'); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } else { final String c = new String(Character.toChars(codePoint)); if (encoder.canEncode(c)) accum.append(c); else accum.append(\"&#x\").append(Integer.toHexString(codePoint)).append(';'); } } } }"
      ]
    },
    "Jsoup_51_/src/main/java/org/jsoup/parser/CharacterReader.java_300-301": {
      "loc": "300-301",
      "input": "<s> boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ <mask> } </s> java",
      "function range": "296,5-301,5",
      "output": [
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return (c >= 'A' && c <= 'Z'); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return true; }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return Character.isLetterOrDigit(c); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return (c >= '0' && c <= '9'); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return (c >= 'a' && c <= 'z'); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return Character. isLetterOrDigit(c); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return c == 'A' || c == 'Z'; }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ return (c == 'A' || c == 'Z'); }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ if (c == 'A') return true; return false; }",
        "boolean matchesLetter() { if (isEmpty()) return false; char c = input[pos]; /* return (c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'); */ if (c == 'a') return true; return false; }"
      ]
    },
    "Jsoup_57_/src/main/java/org/jsoup/nodes/Attributes.java_125-126": {
      "loc": "125-126",
      "input": "<s> public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ <mask> } } </s> java",
      "function range": "118,5-127,5",
      "output": [
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else { it.remove(); } } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else /* attributes.remove(attrKey); */ } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else it.remove(); } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else /* attributes.remove(key); */ } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else { attributes.remove(attrKey); } } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else return; } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else /* attributes.remove(attrKey.toLowerCase()); */ } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else if (attrKey.equalsIgnoreCase(key)) { it.remove(); } } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else if (attrKey.equalsIgnoreCaseIgnoreCase(key)) { it.remove(); } } }",
        "public void removeIgnoreCase(String key) { Validate.notEmpty(key); if (attributes == null) return; for (Iterator<String> it = attributes.keySet().iterator(); it.hasNext(); ) { String attrKey = it.next(); if (attrKey.equalsIgnoreCase(key)) /* attributes.remove(attrKey); */ else if (attrKey.equalsIgnoreCase(key + \"\")) it.remove(); } }"
      ]
    },
    "Jsoup_61_/src/main/java/org/jsoup/nodes/Element.java_1092-1093": {
      "loc": "1092-1093",
      "input": "<s> public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ <mask> final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; } </s> java",
      "function range": "1091,5-1132,5",
      "output": [
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (className == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ final String className = attributes.get(\"class\"); final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null) { return true; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ final String className = attributes.get(\"name\"); final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null || className == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen); } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen) } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null || className == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen) } return false; }",
        "public boolean hasClass(String className) { /* final String classAttr = attributes.get(\"class\"); */ if (classAttr == null || className == null) { return false; } final int len = classAttr.length(); final int wantLen = className.length(); if (len == 0 || len < wantLen) { return false; } if (len == wantLen) { return className.equalsIgnoreCase(classAttr); } boolean inClass = false; int start = 0; for (int i = 0; i < len; i++) { if (Character.isWhitespace(classAttr.charAt(i))) { if (inClass) { if (i - start == wantLen && classAttr.regionMatches(true, start, className, 0, wantLen)) { return true; } inClass = false; } } else { if (!inClass) { inClass = true; start = i; } } } if (inClass && len - start == wantLen) { return classAttr.regionMatches(true, start, className, 0, wantLen)); } return false; }"
      ]
    },
    "Jsoup_68_/src/main/java/org/jsoup/parser/HtmlTreeBuilder.java_468-472": {
      "loc": "468-472",
      "input": "<s> private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ <mask> final int top = bottom > MaxScopeSearchDepth ? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes != null && inSorted(elName, extraTypes)) return false; } return false; } </s> java",
      "function range": "466,5-486,5",
      "output": [
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ for (int i = 0; i < stack.size(); i++) { final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ final int MaxScopeSearchDepth = stack.size() - 1; final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ if (stack.get(bottom) == null) return false; final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ if (top > MaxScopeSearchDepth) { top = MaxScopeSearchDepth; } final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ final int bottom = stack.get(stack.size() - 1); final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ final int MaxScopeSearchDepth = stack.get(stack.size() - 1); final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ if (top > MaxScopeSearchDepth) { top = top - 1 ; } final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ for (int i = 0; i < stack.size(); i++) { final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } } return false; }",
        "private boolean inSpecificScope(String[] targetNames, String[] baseTypes, String[] extraTypes) { /* int bottom = stack.size() -1; if (bottom > MaxScopeSearchDepth) { bottom = MaxScopeSearchDepth; } */ for (int i = 0; i < stack.size(); i++) { final int top = bottom > MaxScopeSearchDepth? bottom - MaxScopeSearchDepth : 0; for (int pos = bottom; pos >= top; pos--) { final String elName = stack.get(pos).nodeName(); if (inSorted(elName, targetNames)) return true; if (inSorted(elName, baseTypes)) return false; if (extraTypes!= null && inSorted(elName, extraTypes)) return false; } return false; } }"
      ]
    },
    "Jsoup_75_/src/main/java/org/jsoup/nodes/Attributes.java_319-321": {
      "loc": "319-321",
      "input": "<s> final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ <mask> accum.append(\"=\\\"\"); Entities.escape(accum, val == null ? EmptyString : val, out, true, false, false); accum.append('\"'); } } } </s> java",
      "function range": "310,5-326,5",
      "output": [
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ accum.append(\"\\\"\"); accum.append(val); } else { accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ accum.append(\"\\\"\"); accum.append(key); accum.append(\"=\\\"\"); accum.append(val); accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ accum.append(\"\\\"\"); accum.append(val); accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } */ } }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"=\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } */ }",
        "final void html(final Appendable accum, final Document.OutputSettings out) throws IOException { final int sz = size; for (int i = 0; i < sz; i++) { final String key = keys[i]; final String val = vals[i]; accum.append(' ').append(key); /* if (!(out.syntax() == Document.OutputSettings.Syntax.html && (val == null || val.equals(key) && Attribute.isBooleanAttribute(key)))) { */ if (out.syntax() == Document.OutputSettings.Syntax.html) { accum.append(\"\\\"\"); Entities.escape(accum, val == null? EmptyString : val, out, true, false, false); accum.append('\"'); } } */ } }"
      ]
    },
    "Jsoup_77_/src/main/java/org/jsoup/parser/XmlTreeBuilder.java_117-118": {
      "loc": "117-118",
      "input": "<s> private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ <mask> Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } } </s> java",
      "function range": "116,5-136,5",
      "output": [
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.size() == 0) return; Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.isEmpty()) return; Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.size() == 0) { return; } Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (elName == null) return; Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ List < Element > stack = this.getStack(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ String elName = endTag.nodeName(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ List < Element > stack = endTag.getStack(); Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.size() == 0) return; Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; }",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.size() == 0) return; Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; } DEDENT",
        "private void popStackToClose(Token.EndTag endTag) { /* String elName = endTag.name(); */ if (stack.size() == 0) { return; } Element firstFound = null; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); if (next.nodeName().equals(elName)) { firstFound = next; break; } } if (firstFound == null) return; for (int pos = stack.size() -1; pos >= 0; pos--) { Element next = stack.get(pos); stack.remove(pos); if (next == firstFound) break; }"
      ]
    },
    "Jsoup_86_/src/main/java/org/jsoup/nodes/Comment.java_78-79": {
      "loc": "78-79",
      "input": "<s> public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ <mask> Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; } </s> java",
      "function range": "74,5-84,5",
      "output": [
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(doc.tagName()), data.startsWith(\"!\")); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(doc.node().tagName()), data.startsWith(\"!\")); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(doc.firstChild().tagName()), data.startsWith(\"!\")); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(doc.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(doc.attributes()); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } else { Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } else { decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(data), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } */ return decl; }",
        "public XmlDeclaration asXmlDeclaration() { String data = getData(); Document doc = Jsoup.parse(\"<\" + data.substring(1, data.length() -1) + \">\", baseUri(), Parser.xmlParser()); XmlDeclaration decl = null; /* if (doc.childNodeSize() > 0) { */ Element el = doc.child(0); decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(el.tagName()), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } else { decl = new XmlDeclaration(NodeUtils.parser(doc).settings().normalizeTag(data), data.startsWith(\"!\")); decl.attributes().addAll(el.attributes()); } */ return decl; }"
      ]
    },
    "Jsoup_88_/src/main/java/org/jsoup/nodes/Attribute.java_80-81": {
      "loc": "80-81",
      "input": "<s> public String getValue() { /* return val; */ <mask> } </s> java",
      "function range": "79,5-81,5",
      "output": [
        "public String getValue() { /* return val; */ return val ; }",
        "public String getValue() { /* return val; */ return val; }",
        "public String getValue() { /* return val; */ return this.val; }",
        "public String getValue() { /* return val; */ return value ; }",
        "public String getValue() { /* return val; */ return null ; }",
        "public String getValue() { /* return val; */ return this.value; }",
        "public String getValue() { /* return val; */ return this.val ; }",
        "public String getValue() { /* return val; */ return null; }",
        "public String getValue() { /* return val; */ return super. getValue(); }",
        "public String getValue() { /* return val; */ }"
      ]
    },
    "JxPath_5_/src/java/org/apache/commons/jxpath/ri/model/NodePointer.java_665-668": {
      "loc": "665-668",
      "input": "<s> private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0 ? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0 ? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1 != null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ <mask> } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r != 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } </s> java",
      "function range": "642,5-675,5",
      "output": [
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p1, p2); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p2, p1); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return 0; } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p2, p2); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p2.parent.compareChildNodePointers(p1, p2); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p2.parent.compareChildNodePointers(p1, p1); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p1, p2); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p2, p2); }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p1, p2); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return p1.parent.compareChildNodePointers(p2, p1); } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } }",
        "private int compareNodePointers( NodePointer p1, int depth1, NodePointer p2, int depth2) { if (depth1 < depth2) { int r = compareNodePointers(p1, depth1, p2.parent, depth2 - 1); return r == 0? -1 : r; } if (depth1 > depth2) { int r = compareNodePointers(p1.parent, depth1 - 1, p2, depth2); return r == 0? 1 : r; } if (p1 == null && p2 == null) { return 0; } if (p1!= null && p1.equals(p2)) { return 0; } if (depth1 == 1) { /* throw new JXPathException( \"Cannot compare pointers that do not belong to the same tree: '\" + p1 + \"' and '\" + p2 + \"'\"); */ } if (depth2 == 1) { return 0; } int r = compareNodePointers(p1.parent, depth1 - 1, p2.parent, depth2 - 1); if (r!= 0) { return r; } return p1.parent.compareChildNodePointers(p1, p2); } }"
      ]
    },
    "JxPath_10_/src/java/org/apache/commons/jxpath/ri/compiler/CoreOperationRelationalExpression.java_42-43": {
      "loc": "42-43",
      "input": "<s> public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ <mask> ? Boolean.TRUE : Boolean.FALSE; } </s> java",
      "function range": "41,5-44,5",
      "output": [
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args.length == 2? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return compute(args[2].computeValue(context), args[3].computeValue(context))? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[2].computeValue(context)? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[0].computeValue(context) == args[1].computeValue(context)? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[1].computeValue(context)? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args.length > 2? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[1].computeValue(context) == Boolean.FALSE? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[2].computeValue(context) == Boolean.FALSE? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[1].computeValue(context) == null? Boolean.TRUE : Boolean.FALSE; }",
        "public final Object computeValue(EvalContext context) { /* return compute(args[0].computeValue(context), args[1].computeValue(context)) */ return args[0] == null? Boolean.TRUE : Boolean.FALSE; }"
      ]
    },
    "JxPath_12_/src/java/org/apache/commons/jxpath/ri/model/dom/DOMNodePointer.java_108-109": {
      "loc": "108-109",
      "input": "<s> public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType() != Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName() .equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ <mask> } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; } </s> java",
      "function range": "87,5-136,5",
      "output": [
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, DOMNodePointer.getLocalName(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, nodeNS); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, namespaceURI); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, DOMNodePointer.getPrefix(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, nodeNameTest.getPrefix()); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ } return false; } if (test instanceof ElementTest) { if (node.getNodeType() == Node.ELEMENT_NODE) { return true; } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ } return false; } if (test instanceof ElementTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ } return false; } if (test instanceof ElementTest) { if (node.getNodeType() == Node.ELEMENT_NODE) { return testNode(node, test); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node.PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, DOMNodePointer.getLocalName(node)); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node. PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }",
        "public static boolean testNode(Node node, NodeTest test) { if (test == null) { return true; } if (test instanceof NodeNameTest) { if (node.getNodeType()!= Node.ELEMENT_NODE) { return false; } NodeNameTest nodeNameTest = (NodeNameTest) test; QName testName = nodeNameTest.getNodeName(); String namespaceURI = nodeNameTest.getNamespaceURI(); boolean wildcard = nodeNameTest.isWildcard(); String testPrefix = testName.getPrefix(); if (wildcard && testPrefix == null) { return true; } if (wildcard || testName.getName().equals(DOMNodePointer.getLocalName(node))) { String nodeNS = DOMNodePointer.getNamespaceURI(node); /* return equalStrings(namespaceURI, nodeNS); */ return equalStrings(testPrefix, nodeNS); } return false; } if (test instanceof NodeTypeTest) { int nodeType = node.getNodeType(); switch (((NodeTypeTest) test).getNodeType()) { case Compiler.NODE_TYPE_NODE : return nodeType == Node.ELEMENT_NODE || nodeType == Node.DOCUMENT_NODE; case Compiler.NODE_TYPE_TEXT : return nodeType == Node.CDATA_SECTION_NODE || nodeType == Node.TEXT_NODE; case Compiler.NODE_TYPE_COMMENT : return nodeType == Node.COMMENT_NODE; case Compiler.NODE_TYPE_PI : return nodeType == Node.PROCESSING_INSTRUCTION_NODE; } return false; } if (test instanceof ProcessingInstructionTest) { if (node.getNodeType() == Node. PROCESSING_INSTRUCTION_NODE) { String testPI = ((ProcessingInstructionTest) test).getTarget(); String nodePI = ((ProcessingInstruction) node).getTarget(); return testPI.equals(nodePI); } } return false; }"
      ]
    },
    "JxPath_21_/src/java/org/apache/commons/jxpath/ri/model/beans/PropertyPointer.java_152-153": {
      "loc": "152-153",
      "input": "<s> public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ <mask> } </s> java",
      "function range": "151,5-153,5",
      "output": [
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return ValueUtils.getLength(getValue()); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return super.getLength(); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return 0 ; }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return super. getLength(); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return ValueUtils.getLength(baseValue()); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return ValueUtils.getLength(getValue()); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return getValueLength(); }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return valueLength; }",
        "public int getLength() { /* return ValueUtils.getLength(getBaseValue()); */ return valueLength ; }"
      ]
    },
    "Lang_6_/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java_95-96": {
      "loc": "95-96",
      "input": "<s> public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ <mask> } } } </s> java",
      "function range": "75,5-98,5",
      "output": [
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pos)); } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pt)); } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pos)); } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos)); pos += Character.charCount(Character.codePointAt(input, pt)); */ } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pos + pt)); } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pt)); } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos) + pt)); pos += pt; } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pt)); pos += Character.charCount(Character.codePointAt(input, pt)); */ } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos)); pos += Character.charCount(Character.codePointAt(input, pos)); */ } } }",
        "public final void translate(CharSequence input, Writer out) throws IOException { if (out == null) { throw new IllegalArgumentException(\"The Writer must not be null\"); } if (input == null) { return; } int pos = 0; int len = input.length(); while (pos < len) { int consumed = translate(input, pos, out); if (consumed == 0) { char[] c = Character.toChars(Character.codePointAt(input, pos)); out.write(c); pos+= c.length; continue; } for (int pt = 0; pt < consumed; pt++) { /* pos += Character.charCount(Character.codePointAt(input, pos)); */ out.write(Character.toChars(Character.codePointAt(input, pos))); pos += Character.charCount(Character.codePointAt(input, pos + 1)); } } }"
      ]
    },
    "Lang_16_/src/main/java/org/apache/commons/lang3/math/NumberUtils.java_458-459": {
      "loc": "458-459",
      "input": "<s> public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { return null; } /* if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { */ <mask> return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos || expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { if (expPos > str.length()) { throw new NumberFormatException(str + \" is not a valid number.\"); } mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar) && lastChar != '.') { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null && (numeric.charAt(0) == '-' && isDigits(numeric.substring(1)) || isDigits(numeric))) { try { return createLong(numeric); } catch (NumberFormatException nfe) { } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { } case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { } default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { try { return createInteger(str); } catch (NumberFormatException nfe) { } try { return createLong(str); } catch (NumberFormatException nfe) { } return createBigInteger(str); } else { boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { } return createBigDecimal(str); } } } </s> java",
      "function range": "444,5-594,5"
    },
    "Lang_21_/src/main/java/org/apache/commons/lang3/time/DateUtils.java_265-266": {
      "loc": "265-266",
      "input": "<s> public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ <mask> cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); } </s> java",
      "function range": "258,5-270,5",
      "output": [
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_WEEK) == cal2.get(Calendar.DAY_OF_WEEK) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) && /* cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.HOUR_OF_DAY) == cal2.get(Calendar.HOUR_OF_DAY) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1.getClass() == cal2.getClass()) }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.DAY_OF_MONTH) == cal2.get(Calendar.DAY_OF_MONTH) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) && cal1. getClass() == cal2.getClass()); }",
        "public static boolean isSameLocalTime(Calendar cal1, Calendar cal2) { if (cal1 == null || cal2 == null) { throw new IllegalArgumentException(\"The date must not be null\"); } return (cal1.get(Calendar.MILLISECOND) == cal2.get(Calendar.MILLISECOND) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && /* cal1.get(Calendar.HOUR) == cal2.get(Calendar.HOUR) && */ cal1.get(Calendar.MINUTE) == cal2.get(Calendar.MINUTE) && cal1.get(Calendar.SECOND) == cal2.get(Calendar.SECOND) && cal1.get(Calendar.DAY_OF_YEAR) == cal2.get(Calendar.DAY_OF_YEAR) && cal1.get(Calendar.YEAR) == cal2.get(Calendar.YEAR) && cal1.get(Calendar.ERA) == cal2.get(Calendar.ERA) == cal2.getClass()); }"
      ]
    },
    "Lang_26_/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java_820-821": {
      "loc": "820-821",
      "input": "<s> public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ <mask> c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); } </s> java",
      "function range": "819,5-823,5",
      "output": [
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setDate(date); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimeInMillis(mTimeInMillis); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimeZone(mTimeZone); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimeInMillis(0); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimezone(mTimeZone); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setLenient(true); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setDate(date); c.setTime(date); return applyRules(c, new StringBuffer(mMinLengthEstimate)).toString(); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimeInMillis(date.getTimeInMillis()); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimates)); }",
        "public String format(Date date) { /* Calendar c = new GregorianCalendar(mTimeZone); */ c.setTimeInMillis(date.getTimeInMillis()); c.setTime(date); return applyRules(c, new StringBuffer(mMaxLengthEstimate)).toString();"
      ]
    },
    "Lang_29_/src/main/java/org/apache/commons/lang3/SystemUtils.java_1672-1673": {
      "loc": "1672-1673",
      "input": "<s> /* static float toJavaVersionInt(String version) { */ <mask> return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } </s> java",
      "function range": "1672,5-1674,5",
      "output": [
        "/* static float toJavaVersionInt(String version) { */ return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ if (version == null) return 0f; return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ if (version == null) return 0.0f; return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ if (version == null) { return 0f; } return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ if (version == null) { return 0.0f; } return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ if (version == null) return 1.0f; return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ System.out.println(version); return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ final int JAVA_VERSION_TRIM_SIZE = 8; return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); }",
        "/* static float toJavaVersionInt(String version) { */ return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE)); } */",
        "/* static float toJavaVersionInt(String version) { */ return toVersionInt(toJavaVersionIntArray(version, JAVA_VERSION_TRIM_SIZE); }"
      ]
    },
    "Lang_33_/src/main/java/org/apache/commons/lang3/ClassUtils.java_910-911": {
      "loc": "910-911",
      "input": "<s> public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ <mask> } return classes; } </s> java",
      "function range": "902,5-913,5",
      "output": [
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ } if (classes.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = ArrayUtils.toClass(array[i]); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = array[i].getClass(); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = array[i].getClass(); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = array[i].toString(); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = ArrayUtils.toClass(Arrays.asList(array[i])); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = array[i].getClass().getGenericSuperclass(); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = array[i].getClass().getClassLoader().loadClass(); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ classes[i] = ArrayUtils.toClass(Arrays.asList(array[i].getClass())); } return classes; }",
        "public static Class<?>[] toClass(Object[] array) { if (array == null) { return null; } else if (array.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } Class<?>[] classes = new Class[array.length]; for (int i = 0; i < array.length; i++) { /* classes[i] = array[i].getClass(); */ } if (classes.length == 0) { return ArrayUtils.EMPTY_CLASS_ARRAY; } else { return classes; } }"
      ]
    },
    "Lang_39_/src/java/org/apache/commons/lang3/StringUtils.java_3676-3677": {
      "loc": "3676-3677",
      "input": "<s> private static String replaceEach(String text, String[] searchList, String[] replacementList, boolean repeat, int timeToLive) { if (text == null || text.length() == 0 || searchList == null || searchList.length == 0 || replacementList == null || replacementList.length == 0) { return text; } if (timeToLive < 0) { throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text); } int searchLength = searchList.length; int replacementLength = replacementList.length; if (searchLength != replacementLength) { throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \" + searchLength + \" vs \" + replacementLength); } boolean[] noMoreMatchesForReplIndex = new boolean[searchLength]; int textIndex = -1; int replaceIndex = -1; int tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i]); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } if (textIndex == -1) { return text; } int start = 0; int increase = 0; for (int i = 0; i < searchList.length; i++) { /* int greater = replacementList[i].length() - searchList[i].length(); */ <mask> if (greater > 0) { increase += 3 * greater; } } increase = Math.min(increase, text.length() / 5); StringBuilder buf = new StringBuilder(text.length() + increase); while (textIndex != -1) { for (int i = start; i < textIndex; i++) { buf.append(text.charAt(i)); } buf.append(replacementList[replaceIndex]); start = textIndex + searchList[replaceIndex].length(); textIndex = -1; replaceIndex = -1; tempIndex = -1; for (int i = 0; i < searchLength; i++) { if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].length() == 0 || replacementList[i] == null) { continue; } tempIndex = text.indexOf(searchList[i], start); if (tempIndex == -1) { noMoreMatchesForReplIndex[i] = true; } else { if (textIndex == -1 || tempIndex < textIndex) { textIndex = tempIndex; replaceIndex = i; } } } } int textLength = text.length(); for (int i = start; i < textLength; i++) { buf.append(text.charAt(i)); } String result = buf.toString(); if (!repeat) { return result; } return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1); } </s> java",
      "function range": "3605,5-3731,5"
    },
    "Lang_40_/src/java/org/apache/commons/lang/StringUtils.java_1048-1049": {
      "loc": "1048-1049",
      "input": "<s> public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ <mask> } </s> java",
      "function range": "1044,5-1049,5",
      "output": [
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().contains(searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return contains(str.toLowerCase(), searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return true; }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().containsIgnoreCase(searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().equalsIgnoreCase(searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().equals(searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.equalsIgnoreCase(searchStr.toUpperCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().toLowerCase().contains(searchStr.toLowerCase()); }",
        "public static boolean containsIgnoreCase(String str, String searchStr) { if (str == null || searchStr == null) { return false; } /* return contains(str.toUpperCase(), searchStr.toUpperCase()); */ return str.toLowerCase().equalsIgnoreCase(); }"
      ]
    },
    "Lang_43_/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java_422-423": {
      "loc": "422-423",
      "input": "<s> private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null ? null : appendTo.append(QUOTE); */ <mask> } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null ? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); } </s> java",
      "function range": "417,5-444,5",
      "output": [
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ return appendTo == null? null : appendTo.append(c, start, pos.getIndex() - start); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ pos.setIndex(start + QUOTE.length()); return appendTo; } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ } if (c[start] == ESCAPED_QUOTE) { return appendTo == null? null : appendTo.append(ESCAPED_QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ pos.setIndex(start); return appendTo == null? null : appendTo.append(c, start, pos.getIndex() - start); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ pos.setIndex(start + ESCAPED_QUOTE.length()); return appendTo; } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ pos.setIndex(start); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ return appendTo; } if (c[start] == ESCAPED_QUOTE) { return appendTo; } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ pos.setIndex(start); return appendTo == null? null : appendTo.append(c, pos.getIndex() - pos.getIndex()); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException( \"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ } else if (c[start] == ESCAPED_QUOTE) { return appendTo == null? null : appendTo.append(ESCAPED_QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start); }",
        "private StringBuffer appendQuotedString(String pattern, ParsePosition pos, StringBuffer appendTo, boolean escapingOn) { int start = pos.getIndex(); char[] c = pattern.toCharArray(); if (escapingOn && c[start] == QUOTE) { /* return appendTo == null? null : appendTo.append(QUOTE); */ } if (c[start] == ESCAPED_QUOTE) { return appendTo == null? null : appendTo.append(ESCAPED_QUOTE); } int lastHold = start; for (int i = pos.getIndex(); i < pattern.length(); i++) { if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) { appendTo.append(c, lastHold, pos.getIndex() - lastHold).append( QUOTE); pos.setIndex(i + ESCAPED_QUOTE.length()); lastHold = pos.getIndex(); continue; } switch (c[pos.getIndex()]) { case QUOTE: next(pos); return appendTo == null? null : appendTo.append(c, lastHold, pos.getIndex() - lastHold); default: next(pos); } } throw new IllegalArgumentException(\"Unterminated quoted string at position \" + start); }"
      ]
    },
    "Lang_51_/src/java/org/apache/commons/lang/BooleanUtils.java_682-683": {
      "loc": "682-683",
      "input": "<s> public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) == 's' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) == 's'); } /* } */ <mask> case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; } </s> java",
      "function range": "649,5-700,5",
      "output": [
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ return false; } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ return false; case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ } return false; case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'R' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ case 5: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'e'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'e') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } return false; }",
        "public static boolean toBoolean(String str) { if (str == \"true\") { return true; } if (str == null) { return false; } switch (str.length()) { case 2: { char ch0 = str.charAt(0); char ch1 = str.charAt(1); return (ch0 == 'o' || ch0 == 'O') && (ch1 == 'n' || ch1 == 'N'); } case 3: { char ch = str.charAt(0); if (ch == 'y') { return (str.charAt(1) == 'e' || str.charAt(1) == 'E') && (str.charAt(2) =='s' || str.charAt(2) == 'S'); } if (ch == 'Y') { return (str.charAt(1) == 'E' || str.charAt(1) == 'e') && (str.charAt(2) == 'S' || str.charAt(2) =='s'); } /* } */ return false; } case 4: { char ch = str.charAt(0); if (ch == 't') { return (str.charAt(1) == 'r' || str.charAt(1) == 'R') && (str.charAt(2) == 'u' || str.charAt(2) == 'U') && (str.charAt(3) == 'e' || str.charAt(3) == 'E'); } if (ch == 'T') { return (str.charAt(1) == 'R' || str.charAt(1) == 'r') && (str.charAt(2) == 'U' || str.charAt(2) == 'u') && (str.charAt(3) == 'E' || str.charAt(3) == 'e'); } } } returning false; }"
      ]
    },
    "Lang_57_/src/java/org/apache/commons/lang/LocaleUtils.java_223-224": {
      "loc": "223-224",
      "input": "<s> public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ <mask> } </s> java",
      "function range": "222,5-224,5",
      "output": [
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.contains(locale); }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.contains(locale.toString()); }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return true; }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.contains(locale.toString()) ; }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.includes(locale); }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.indexOf(locale) >= 0 ; }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return!cAvailableLocaleSet.contains(locale); }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return locale!= null; }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return false; }",
        "public static boolean isAvailableLocale(Locale locale) { /* return cAvailableLocaleSet.contains(locale); */ return cAvailableLocaleSet.contains(Locale.getDefault()); }"
      ]
    },
    "Lang_58_/src/java/org/apache/commons/lang/math/NumberUtils.java_454-456": {
      "loc": "454-456",
      "input": "<s> public static Number createNumber(String str) throws NumberFormatException { if (str == null) { return null; } if (StringUtils.isBlank(str)) { throw new NumberFormatException(\"A blank string is not a valid number\"); } if (str.startsWith(\"--\")) { return null; } if (str.startsWith(\"0x\") || str.startsWith(\"-0x\")) { return createInteger(str); } char lastChar = str.charAt(str.length() - 1); String mant; String dec; String exp; int decPos = str.indexOf('.'); int expPos = str.indexOf('e') + str.indexOf('E') + 1; if (decPos > -1) { if (expPos > -1) { if (expPos < decPos) { throw new NumberFormatException(str + \" is not a valid number.\"); } dec = str.substring(decPos + 1, expPos); } else { dec = str.substring(decPos + 1); } mant = str.substring(0, decPos); } else { if (expPos > -1) { mant = str.substring(0, expPos); } else { mant = str; } dec = null; } if (!Character.isDigit(lastChar)) { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length() - 1); } else { exp = null; } String numeric = str.substring(0, str.length() - 1); boolean allZeros = isAllZeros(mant) && isAllZeros(exp); switch (lastChar) { case 'l' : case 'L' : if (dec == null && exp == null /* && isDigits(numeric.substring(1)) && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) { */ <mask> try { return createLong(numeric); } catch (NumberFormatException nfe) { } return createBigInteger(numeric); } throw new NumberFormatException(str + \" is not a valid number.\"); case 'f' : case 'F' : try { Float f = NumberUtils.createFloat(numeric); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { } case 'd' : case 'D' : try { Double d = NumberUtils.createDouble(numeric); if (!(d.isInfinite() || (d.floatValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { } try { return createBigDecimal(numeric); } catch (NumberFormatException e) { } default : throw new NumberFormatException(str + \" is not a valid number.\"); } } else { if (expPos > -1 && expPos < str.length() - 1) { exp = str.substring(expPos + 1, str.length()); } else { exp = null; } if (dec == null && exp == null) { try { return createInteger(str); } catch (NumberFormatException nfe) { } try { return createLong(str); } catch (NumberFormatException nfe) { } return createBigInteger(str); } else { boolean allZeros = isAllZeros(mant) && isAllZeros(exp); try { Float f = createFloat(str); if (!(f.isInfinite() || (f.floatValue() == 0.0F && !allZeros))) { return f; } } catch (NumberFormatException nfe) { } try { Double d = createDouble(str); if (!(d.isInfinite() || (d.doubleValue() == 0.0D && !allZeros))) { return d; } } catch (NumberFormatException nfe) { } return createBigDecimal(str); } } } </s> java",
      "function range": "397,5-545,5"
    },
    "Lang_59_/src/java/org/apache/commons/lang/text/StrBuilder.java_884-885": {
      "loc": "884-885",
      "input": "<s> public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null ? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ <mask> } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; } </s> java",
      "function range": "878,5-895,5",
      "output": [
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + strLen] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + width - strLen] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + width] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + strLen + width] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + strLen] = padChar; return this; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size] = padChar; size += width; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + strLen] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this ; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + width - strLen] = padChar; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this ; }",
        "public StrBuilder appendFixedWidthPadRight(Object obj, int width, char padChar) { if (width > 0) { ensureCapacity(size + width); String str = (obj == null? getNullText() : obj.toString()); int strLen = str.length(); if (strLen >= width) { /* str.getChars(0, strLen, buffer, size); */ buffer[size + strLen] = padChar; size += width; } else { int padLen = width - strLen; str.getChars(0, strLen, buffer, size); for (int i = 0; i < padLen; i++) { buffer[size + strLen + i] = padChar; } } size += width; } return this."
      ]
    },
    "Lang_61_/src/java/org/apache/commons/lang/text/StrBuilder.java_1776-1777": {
      "loc": "1776-1777",
      "input": "<s> public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0 ? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ <mask> outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j) != thisBuf[i + j]) { continue outer; } } return i; } return -1; } </s> java",
      "function range": "1760,5-1787,5",
      "output": [
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ if (len < 0) { return -1; } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ if (strLen < 0) { return -1; } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ if (strLen == 0) { return startIndex; } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ if (strLen == 0) { return -1; } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ for (int i = 0; i < len; i++) { if (str.charAt(i)!= thisBuf[i + i]) { continue; } } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ for (int i = 0; i < len; i++) { thisBuf[i] = str.charAt(i); } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ if (len == 0) { return startIndex; } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ for (int i = 0; i < len; i++) { if (str.charAt(i)!= thisBuf[i + i]) { continue; } } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str. charAt(j)!= thisBuf[i + j]) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ for (int i = 0; i < len; i++) { if (str.charAt(i)!= thisBuf[i + i]) { continue; } } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf[i + j])) { continue outer; } } return i; } return -1; }",
        "public int indexOf(String str, int startIndex) { startIndex = (startIndex < 0? 0 : startIndex); if (str == null || startIndex >= size) { return -1; } int strLen = str.length(); if (strLen == 1) { return indexOf(str.charAt(0), startIndex); } if (strLen == 0) { return startIndex; } if (strLen > size) { return -1; } char[] thisBuf = buffer; /* int len = thisBuf.length - strLen; */ for (int i = 0; i < len; i++) { if (str.charAt(i)!= thisBuf[i + i]) { continue; } } outer: for (int i = startIndex; i < len; i++) { for (int j = 0; j < strLen; j++) { if (str.charAt(j)!= thisBuf [i + j]) { continue outer; } } return i; } return -1; }"
      ]
    },
    "Math_2_/src/main/java/org/apache/commons/math3/distribution/HypergeometricDistribution.java_268-269": {
      "loc": "268-269",
      "input": "<s> public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ <mask> } </s> java",
      "function range": "267,5-269,5",
      "output": [
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (getSampleSize() * getNumberOfSuccesses()) / getPopulationSize(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (double) getPopulationSize() / getNumberOfSuccesses(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (double) getPopulationSize(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return getSampleSize() / getNumberOfSuccesses(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (double) getNumberOfSuccesses() / getPopulationSize(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return getPopulationSize() / getNumberOfSuccesses(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return getPopulationSize(); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (double) (getSampleSize() * getNumberOfSuccesses()); }",
        "public double getNumericalMean() { /* return (double) (getSampleSize() * getNumberOfSuccesses()) / (double) getPopulationSize(); */ return (double) getSampleSize() / getNumberOfSuccesses(); }"
      ]
    },
    "Math_5_/src/main/java/org/apache/commons/math3/complex/Complex.java_305-306": {
      "loc": "305-306",
      "input": "<s> public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ <mask> } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } } </s> java",
      "function range": "299,5-321,5",
      "output": [
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isNaN) { return NaN; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isNaN) { return ZERO; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isZero) { return ZERO; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ONE; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return POSITIVE_INFINITY; } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q); } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q) ; } }",
        "public Complex reciprocal() { if (isNaN) { return NaN; } if (real == 0.0 && imaginary == 0.0) { /* return NaN; */ } if (imaginary == 0.0) { /* return NaN; */ } if (isInfinite) { return ZERO; } if (FastMath.abs(real) < FastMath.abs(imaginary)) { double q = real / imaginary; double scale = 1. / (real * q + imaginary); return createComplex(scale * q, -scale); } else { double q = imaginary / real; double scale = 1. / (imaginary * q + real); return createComplex(scale, -scale * q) } }"
      ]
    },
    "Math_9_/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java_87-88": {
      "loc": "87-88",
      "input": "<s> public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ <mask> return reverted; } </s> java",
      "function range": "86,5-89,5",
      "output": [
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.setDirection(direction); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.direction = direction; return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.setDirection(direction); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.setDirection (direction); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.reverse(); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted = new Line(direction, direction.subtract(direction)); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.add(direction); return reverted; }",
        "public Line revert() { /* final Line reverted = new Line(zero, zero.subtract(direction)); */ reverted.setDirection (direction); return reverted; }",
        "; }"
      ]
    },
    "Math_11_/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java_183-184": {
      "loc": "183-184",
      "input": "<s> public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length != dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ <mask> FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); } </s> java",
      "function range": "177,5-186,5",
      "output": [
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ return FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ return FastMath.pow(covarianceMatrixDeterminant, -dim / 2) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ return FastMath.pow(covarianceMatrixDeterminant, 0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ final double covarianceMatrixDeterminant = covarianceMatrixDeterminant(vals); return FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ return FastMath.pow(varianceMatrixDeterminant, -0.5) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ return FastMath.pow(covarianceMatrixDeterminant, -dim) * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ * FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); return FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ + FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); return FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }",
        "public double density(final double[] vals) throws DimensionMismatchException { final int dim = getDimension(); if (vals.length!= dim) { throw new DimensionMismatchException(vals.length, dim); } /* return FastMath.pow(2 * FastMath.PI, -dim / 2) * */ + FastMath.pow(covarianceMatrixDeterminant, -0.5) * getExponentTerm(vals); }"
      ]
    },
    "Math_20_/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java_921-922": {
      "loc": "921-922",
      "input": "<s> public double[] repairAndDecode(final double[] x) { /* return */ <mask> decode(x); } </s> java",
      "function range": "920,9-923,9",
      "output": [
        "public double[] repairAndDecode(final double[] x) { /* return */ return decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return (double[]) decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return super. decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return this. decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return encode(x) + decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ decode(x); return decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return super. repairAndDecode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return super. repairAndDecode(x); / decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return super. repairAndDecode(x) + decode(x); }",
        "public double[] repairAndDecode(final double[] x) { /* return */ return repairAndDecode(x); }"
      ]
    },
    "Math_27_/src/main/java/org/apache/commons/math3/fraction/Fraction.java_597-598": {
      "loc": "597-598",
      "input": "<s> public double percentageValue() { /* return multiply(100).doubleValue(); */ <mask> } </s> java",
      "function range": "596,5-598,5",
      "output": [
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(100).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return divide(100).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(50).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(100).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return 100; }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(1000).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(100).intValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(100.0).doubleValue(); }",
        "public double percentageValue() { /* return multiply(100).doubleValue(); */ return multiply(100); }"
      ]
    },
    "Math_30_/src/main/java/org/apache/commons/math3/stat/inference/MannWhitneyUTest.java_173-174": {
      "loc": "173-174",
      "input": "<s> private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ <mask> final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); } </s> java",
      "function range": "168,5-184,5",
      "output": [
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n2n2prod = n2 * n2; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n2n2prod = n2 * n1; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n1n2prod = n1n2prod * n2; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n1n2prod = n2 * n1; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n2n1prod = n2 * n1; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ /* final int n2n2prod = n2 * n2; */ final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n2n2prod = n2 * n3; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n1n2prod = n1n2 * n2; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n2n1prod = n1n2prod * n2; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }",
        "private double calculateAsymptoticPValue(final double Umin, final int n1, final int n2) throws ConvergenceException, MaxCountExceededException { /* final int n1n2prod = n1 * n2; */ final int n1n2prod = n1n2prod / 2; final double EU = n1n2prod / 2.0; final double VarU = n1n2prod * (n1 + n2 + 1) / 12.0; final double z = (Umin - EU) / FastMath.sqrt(VarU); final NormalDistribution standardNormal = new NormalDistribution(0, 1); return 2 * standardNormal.cumulativeProbability(z); }"
      ]
    },
    "Math_32_/src/main/java/org/apache/commons/math3/geometry/euclidean/twod/PolygonsSet.java_136-137": {
      "loc": "136-137",
      "input": "<s> @Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ <mask> setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } } </s> java",
      "function range": "129,5-181,5",
      "output": [
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ if (v[0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else if ((Boolean) tree.getAttribute()) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else if (v[0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(Vector2D.NaN); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } } else if (v.length == 1) { setSize(0); setBarycenter(Vector2D.NaN); } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ if (v[0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } } else { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ if (v[0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } } else { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } } }",
        "@Override protected void computeGeometricalProperties() { final Vector2D[][] v = getVertices(); if (v.length == 0) { final BSPTree<Euclidean2D> tree = getTree(false); /* if ((Boolean) tree.getAttribute()) { */ if (v[0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(0); setBarycenter(new Vector2D(0, 0)); } } else if (v[0][0] == null) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { double sum = 0; double sumX = 0; double sumY = 0; for (Vector2D[] loop : v) { double x1 = loop[loop.length - 1].getX(); double y1 = loop[loop.length - 1].getY(); for (final Vector2D point : loop) { final double x0 = x1; final double y0 = y1; x1 = point.getX(); y1 = point.getY(); final double factor = x0 * y1 - y0 * x1; sum += factor; sumX += factor * (x0 + x1); sumY += factor * (y0 + y1); } } if (sum < 0) { setSize(Double.POSITIVE_INFINITY); setBarycenter(Vector2D.NaN); } else { setSize(sum / 2); setBarycenter(new Vector2D(sumX / (3 * sum), sumY / (3 * sum))); } } } }"
      ]
    },
    "Math_33_/src/main/java/org/apache/commons/math3/optimization/linear/SimplexTableau.java_338-339": {
      "loc": "338-339",
      "input": "<s> protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ <mask> columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } </s> java",
      "function range": "327,5-367,5",
      "output": [
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ columnsToDrop.add(i); } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ columnsToDrop.remove(i); } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ } else if (Precision.compareTo(entry, 0d, maxUlps) < 0) { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ columnsToDrop.add(i); } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0 }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ columnsToDrop.add(i); } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ } else if (Precision.compareTo(entry, 0d, maxUlps) < 0) { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0 }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ columnsToDrop.remove(i); } else { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } }",
        "protected void dropPhase1Objective() { if (getNumObjectiveFunctions() == 1) { return; } List<Integer> columnsToDrop = new ArrayList<Integer>(); columnsToDrop.add(0); for (int i = getNumObjectiveFunctions(); i < getArtificialVariableOffset(); i++) { final double entry = tableau.getEntry(0, i); /* if (Precision.compareTo(entry, 0d, maxUlps) > 0) { */ } else if (Precision.compareTo(entry, 0d, maxUlps) < 0) { columnsToDrop.add(i); } } for (int i = 0; i < getNumArtificialVariables(); i++) { int col = i + getArtificialVariableOffset(); if (getBasicRow(col) == null) { columnsToDrop.add(col); } } double[][] matrix = new double[getHeight() - 1][getWidth() - columnsToDrop.size()]; for (int i = 1; i < getHeight(); i++) { int col = 0; for (int j = 0; j < getWidth(); j++) { if (!columnsToDrop.contains(j)) { matrix[i - 1][col++] = tableau.getEntry(i, j); } } } for (int i = columnsToDrop.size() - 1; i >= 0; i--) { columnLabels.remove((int) columnsToDrop.get(i)); } this.tableau = new Array2DRowRealMatrix(matrix); this.numArtificialVariables = 0; } }"
      ]
    },
    "Math_34_/src/main/java/org/apache/commons/math3/genetics/ListPopulation.java_209-210": {
      "loc": "209-210",
      "input": "<s> public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ <mask> } </s> java",
      "function range": "208,5-210,5",
      "output": [
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.iterator(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.iterator(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomesIterator(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.iterator() ; }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes; }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes. iterator(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.reversed(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.values(); }",
        "public Iterator<Chromosome> iterator() { /* return chromosomes.iterator(); */ return chromosomes.iterator(); } }"
      ]
    },
    "Math_41_/src/main/java/org/apache/commons/math/stat/descriptive/moment/Variance.java_520-521": {
      "loc": "520-521",
      "input": "<s> public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ <mask> sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; } </s> java",
      "function range": "501,5-532,5",
      "output": [
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ accum += weights[i]; sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ accum += weights[i]; accum2 += weights[i]; sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; } for (int i = begin; i < begin + length; i++) { sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i] * weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; sumWts += weights[i]; sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; } sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; } /* for (int i = 0; i < weights.length; i++) { sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } } return var; }",
        "public double evaluate(final double[] values, final double[] weights, final double mean, final int begin, final int length) { double var = Double.NaN; if (test(values, weights, begin, length)) { if (length == 1) { var = 0.0; } else if (length > 1) { double accum = 0.0; double dev = 0.0; double accum2 = 0.0; for (int i = begin; i < begin + length; i++) { dev = values[i] - mean; accum += weights[i] * (dev * dev); accum2 += weights[i] * dev; } double sumWts = 0; /* for (int i = 0; i < weights.length; i++) { */ sumWts += weights[i]; sumWts += weights[i]; sumWts += weights[i]; } if (isBiasCorrected) { var = (accum - (accum2 * accum2 / sumWts)) / (sumWts - 1.0); } else { var = (accum - (accum2 * accum2 / sumWts)) / sumWts; } } else { var = 0.0; } } return var; }"
      ]
    },
    "Math_48_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_189-190": {
      "loc": "189-190",
      "input": "<s> protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ <mask> default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } } </s> java",
      "function range": "129,5-251,5",
      "output": [
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 + fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 + fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 - fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 + fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 - fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 - fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / fx; break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / fx; break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return (f1 >= 0)? x1 : x0; default: throw new MathInternalError(); } } }",
        "protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted =!inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* break; */ f0 *= f1 / (f1 + fx); break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted? x1 : x0; case RIGHT_SIDE: return inverted? x0 : x1; case BELOW_SIDE: return (f1 <= 0)? x1 : x0; case ABOVE_SIDE: return inverted? x1 : x0; default: throw new MathInternalError(); } } } }"
      ]
    },
    "Math_50_/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java_187-191": {
      "loc": "187-191",
      "input": "<s> protected final double doSolve() { double x0 = getMin(); double x1 = getMax(); double f0 = computeObjectiveValue(x0); double f1 = computeObjectiveValue(x1); if (f0 == 0.0) { return x0; } if (f1 == 0.0) { return x1; } verifyBracketing(x0, x1); final double ftol = getFunctionValueAccuracy(); final double atol = getAbsoluteAccuracy(); final double rtol = getRelativeAccuracy(); boolean inverted = false; while (true) { final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0)); final double fx = computeObjectiveValue(x); if (fx == 0.0) { return x; } if (f1 * fx < 0) { x0 = x1; f0 = f1; inverted = !inverted; } else { switch (method) { case ILLINOIS: f0 *= 0.5; break; case PEGASUS: f0 *= f1 / (f1 + fx); break; case REGULA_FALSI: /* if (x == x1) { x0 = 0.5 * (x0 + x1 - FastMath.max(rtol * FastMath.abs(x1), atol)); f0 = computeObjectiveValue(x0); } */ <mask> break; default: throw new MathInternalError(); } } x1 = x; f1 = fx; if (FastMath.abs(f1) <= ftol) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: if (inverted) { return x1; } break; case RIGHT_SIDE: if (!inverted) { return x1; } break; case BELOW_SIDE: if (f1 <= 0) { return x1; } break; case ABOVE_SIDE: if (f1 >= 0) { return x1; } break; default: throw new MathInternalError(); } } if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1), atol)) { switch (allowed) { case ANY_SIDE: return x1; case LEFT_SIDE: return inverted ? x1 : x0; case RIGHT_SIDE: return inverted ? x0 : x1; case BELOW_SIDE: return (f1 <= 0) ? x1 : x0; case ABOVE_SIDE: return (f1 >= 0) ? x1 : x0; default: throw new MathInternalError(); } } } } </s> java",
      "function range": "128,5-253,5"
    },
    "Math_53_/src/main/java/org/apache/commons/math/complex/Complex.java_153-154": {
      "loc": "153-154",
      "input": "<s> public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ <mask> imaginary + rhs.getImaginary()); } </s> java",
      "function range": "150,5-155,5",
      "output": [
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ real + rhs.getReal()); */ return createComplex(imaginary + rhs.getImaginary(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ + imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ real + rhs.getReal());*/ return createComplex(imaginary + rhs.getImaginary(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ real + rhs.getReal()); /* return createComplex(imaginary + rhs.getImaginary(), */ imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ imaginary + rhs.getImaginary()); */ return createComplex(real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ + real + rhs.getReal()); */ return createComplex(imaginary + rhs.getImaginary(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ + real + rhs.getReal(), imaginary + rhs.getImaginary()); }",
        "public Complex add(Complex rhs) throws NullArgumentException { MathUtils.checkNotNull(rhs); /* return createComplex(real + rhs.getReal(), */ + real + rhs.getReal());*/ return createComplex(imaginary + rhs.getImaginary(), imaginary + rhs.getImaginary()); }"
      ]
    },
    "Math_56_/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java_237-244": {
      "loc": "237-244",
      "input": "<s> public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ <mask> return indices; } </s> java",
      "function range": "216,5-246,5",
      "output": [
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ indices[index] = count; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ indices[last] = count; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ indices[last] = index; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ indices[dimension] = count; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ final int offset = uniCounterOffset[index]; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ final int offset = uniCounterOffset[index]; indices[index] = offset; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ final int offset = uniCounterOffset[index]; indices[last] = offset; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ final int offset = uniCounterOffset[index]; indices[index] = count; return indices; }",
        "public int[] getCounts(int index) { if (index < 0 || index >= totalSize) { throw new OutOfRangeException(index, 0, totalSize); } final int[] indices = new int[dimension]; int count = 0; for (int i = 0; i < last; i++) { int idx = 0; final int offset = uniCounterOffset[i]; while (count <= index) { count += offset; ++idx; } --idx; count -= offset; indices[i] = idx; } /* int idx = 1; while (count < index) { count += idx; ++idx; } --idx; indices[last] = idx; */ final int offset = uniCounterOffset[index]; indices[last] += offset; return indices; }"
      ]
    },
    "Math_57_/src/main/java/org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java_175-176": {
      "loc": "175-176",
      "input": "<s> private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ <mask> for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; } </s> java",
      "function range": "161,5-198,5",
      "output": [
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ final double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ final double d = random.nextDouble(); for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r ) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } else { resultSet.add(new Cluster<T>(p)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } else { resultSet.add(new Cluster<T>(firstPoint)); break; } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } else { resultSet.add(new Cluster<T>(p)); } } } return resultSet; }",
        "private static <T extends Clusterable<T>> List<Cluster<T>> chooseInitialCenters(final Collection<T> points, final int k, final Random random) { final List<T> pointSet = new ArrayList<T>(points); final List<Cluster<T>> resultSet = new ArrayList<Cluster<T>>(); final T firstPoint = pointSet.remove(random.nextInt(pointSet.size())); resultSet.add(new Cluster<T>(firstPoint)); final double[] dx2 = new double[pointSet.size()]; while (resultSet.size() < k) { /* int sum = 0; */ final double sum = 0; for (int i = 0; i < pointSet.size(); i++) { final T p = pointSet.get(i); final Cluster<T> nearest = getNearestCluster(resultSet, p); final double d = p.distanceFrom(nearest.getCenter()); sum += d * d; dx2[i] = sum; } final double r = random.nextDouble() * sum; for (int i = 0 ; i < dx2.length; i++) { if (dx2[i] >= r) { final T p = pointSet.remove(i); resultSet.add(new Cluster<T>(p)); break; } } DEDENT return resultSet; }"
      ]
    },
    "Math_58_/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java_121-122": {
      "loc": "121-122",
      "input": "<s> public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ <mask> } </s> java",
      "function range": "119,5-122,5",
      "output": [
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return guess; }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return null; }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return fit(new Gaussian.Parametric(), guess); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return fit(new Gaussian.Gaussian(), guess); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return (new Gaussian.Parametric()).fit(); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return fit(new Gaussian.Parametric(), guess); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return (new Gaussian.Parametric(), guess); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return fit(new Gaussian.Parameteretric(), guess); }",
        "public double[] fit() { final double[] guess = (new ParameterGuesser(getObservations())).guess(); /* return fit(new Gaussian.Parametric(), guess); */ return (new ParameterGuesser(getObservations()).fit(); }"
      ]
    },
    "Math_59_/src/main/java/org/apache/commons/math/util/FastMath.java_3482-3483": {
      "loc": "3482-3483",
      "input": "<s> public static float max(final float a, final float b) { /* return (a <= b) ? b : (Float.isNaN(a + b) ? Float.NaN : b); */ <mask> } </s> java",
      "function range": "3481,5-3483,5",
      "output": [
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return a + b; }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return Float.max(a, b); }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return a - b; }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return Math.max(a, b); }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return a > b? a : b; }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return (float) Math.max(a, b); }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return a > b? a : Float.NaN; }",
        "public static float max(final float a, final float b) { /* return (a <= b)? b : (Float.isNaN(a + b)? Float.NaN : b); */ return a > b? a : Float.NaN ; }",
        "; }"
      ]
    },
    "Math_63_/src/main/java/org/apache/commons/math/util/MathUtils.java_417-418": {
      "loc": "417-418",
      "input": "<s> public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ <mask> } </s> java",
      "function range": "416,5-418,5",
      "output": [
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return x == y; }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return x!= y; }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return Double.equals(x, y); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return Double.compare(x, y); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return x.equals(y); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return true; }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return (x == y); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return Double.compare (x, y); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ return Double.isNaN(x); }",
        "public static boolean equals(double x, double y) { /* return (Double.isNaN(x) && Double.isNaN(y)) || x == y; */ }"
      ]
    },
    "Math_69_/src/main/java/org/apache/commons/math/stat/correlation/PearsonsCorrelation.java_171-172": {
      "loc": "171-172",
      "input": "<s> public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ <mask> } } } return new BlockRealMatrix(out); } </s> java",
      "function range": "160,5-176,5",
      "output": [
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = 1d; } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = tDistribution.cumulativeProbability(t); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = tDistribution.probability(t); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] += tDistribution.cumulativeProbability(t); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = 2 * tDistribution.cumulativeProbability(t); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = Math.abs(tDistribution.cumulativeProbability(t)); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = Math.sqrt((nObs - 2)/(1 - tDistribution.cumulativeProbability(t))); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = Math.sqrt((nObs - 2)/(1 - tDistribution.cumulativeProbability(t)); } } } return new BlockRealMatrix(out); }",
        "public RealMatrix getCorrelationPValues() throws MathException { TDistribution tDistribution = new TDistributionImpl(nObs - 2); int nVars = correlationMatrix.getColumnDimension(); double[][] out = new double[nVars][nVars]; for (int i = 0; i < nVars; i++) { for (int j = 0; j < nVars; j++) { if (i == j) { out[i][j] = 0d; } else { double r = correlationMatrix.getEntry(i, j); double t = Math.abs(r * Math.sqrt((nObs - 2)/(1 - r * r))); /* out[i][j] = 2 * (1 - tDistribution.cumulativeProbability(t)); */ out[i][j] = Math.sqrt((nObs - 2)/(1 - r * r))); } } } return new BlockRealMatrix(out); }"
      ]
    },
    "Math_70_/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java_72-73": {
      "loc": "72-73",
      "input": "<s> public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ <mask> } </s> java",
      "function range": "70,5-73,5",
      "output": [
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f(min, max, initial); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return solve(min, max, initial); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ throw new MaxIterationsExceededException(); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return solve(initial, f); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f(min, max); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f.solve(min, max); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f.solve(initial); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ throw new MaxIterationsExceededException(initial); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f.solve(min, initial); }",
        "public double solve(final UnivariateRealFunction f, double min, double max, double initial) throws MaxIterationsExceededException, FunctionEvaluationException { /* return solve(min, max); */ return f(min, max, initial) ; }"
      ]
    },
    "Math_73_/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java_136-137": {
      "loc": "136-137",
      "input": "<s> public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ <mask> return solve(f, min, yMin, max, yMax, initial, yInitial); } </s> java",
      "function range": "98,5-140,5",
      "output": [
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(min, 0); return result; } return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(max, 0); return result; } return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ final double yMin = f.value(min); final double yMax = f.value(max); return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ if (yInitial * yMax < 0) { return solve(f, min, yMin, max, yMax, initial, yInitial); } return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ return solve(f, min, yMin, initial, yInitial, min, yMin); } /* */ return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ double yMin = f.value(min); double yMax = f.value(max); return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ if (yInitial * yMax < 0) { return solve(f, min, yMin, max, yMax, initial, yInitial); }",
        "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial) throws MaxIterationsExceededException, FunctionEvaluationException { clearResult(); verifySequence(min, initial, max); double yInitial = f.value(initial); if (Math.abs(yInitial) <= functionValueAccuracy) { setResult(initial, 0); return result; } double yMin = f.value(min); if (Math.abs(yMin) <= functionValueAccuracy) { setResult(yMin, 0); return result; } if (yInitial * yMin < 0) { return solve(f, min, yMin, initial, yInitial, min, yMin); } double yMax = f.value(max); if (Math.abs(yMax) <= functionValueAccuracy) { setResult(yMax, 0); return result; } if (yInitial * yMax < 0) { return solve(f, initial, yInitial, max, yMax, initial, yInitial); } /* */ return solve(f, min, yMin, max, yMax, initial, yInitial); }"
      ]
    },
    "Math_75_/src/main/java/org/apache/commons/math/stat/Frequency.java_303-304": {
      "loc": "303-304",
      "input": "<s> @Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ <mask> } </s> java",
      "function range": "301,5-304,5",
      "output": [
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct((Double) v); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct(v.getClass()); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct((Object) v); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct((double) v); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct(v); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct((Comparable<?>) v); }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ } @Deprecated public double getCumPct(Comparable<?> v) { return 0.0; }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ } @Deprecated public double getCumPct(Comparable<?> v) { return 1.0; }",
        "@Deprecated public double getPct(Object v) { /* return getCumPct((Comparable<?>) v); */ return getCumPct(v.getClass()); } }"
      ]
    },
    "Math_80_/src/main/java/org/apache/commons/math/linear/EigenDecompositionImpl.java_1135-1136": {
      "loc": "1135-1136",
      "input": "<s> private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ <mask> for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; } </s> java",
      "function range": "1132,5-1147,5",
      "output": [
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int j = 0; j < n; j += 4) { for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int j = 0; j < 4; j += 4) { for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 1; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int j = 0; j < n - 1; j += 4) { for (int i = 0; i < j; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < n; i += 4) { for (int j = 0; j < 4; j += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < j - 4; i += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < j; i += 4) { for (int j = 0; j < 4; j += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < n; i += 4) { for (int j = 0; j < n; j += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }",
        "private boolean flipIfWarranted(final int n, final int step) { if (1.5 * work[pingPong] < work[4 * (n - 1) + pingPong]) { /* int j = 4 * n - 1; */ for (int i = 0; i < n; i += 4) { for (int j = 0; j < n - 1; j += 4) { for (int k = 0; k < 4; k += step) { final double tmp = work[i + k]; work[i + k] = work[j - k]; work[j - k] = tmp; } j -= 4; } return true; } return false; }"
      ]
    },
    "Math_82_/src/main/java/org/apache/commons/math/optimization/linear/SimplexSolver.java_82-83": {
      "loc": "82-83",
      "input": "<s> private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ <mask> final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; } </s> java",
      "function range": "76,5-91,5",
      "output": [
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.abs(rhs - entry) < epsilon) { minRatio = rhs; minRatioPos = i; } } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ } else if (MathUtils.compareTo(entry, rhs, epsilon) <= 0) { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.abs(entry - rhs) < epsilon) { minRatio = rhs; minRatioPos = i; } } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.abs(rhs - entry) < epsilon) { minRatio = rhs; minRatioPos = i; } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ } else { /* if (MathUtils.compareTo(entry, rhs, epsilon) >= 0) { */ } */ final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.equals(entry, rhs, epsilon)) { minRatio = rhs; minRatioPos = i; } } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.abs(entry - rhs) < epsilon) { minRatio = rhs; minRatioPos = i; } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.compareTo(entry, rhs, epsilon) < 0) { minRatio = rhs; minRatioPos = i; } else { final double ratio = rhs / entry; if (ratio < minRatio) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }",
        "private Integer getPivotRow(final int col, final SimplexTableau tableau) { double minRatio = Double.MAX_VALUE; Integer minRatioPos = null; for (int i = tableau.getNumObjectiveFunctions(); i < tableau.getHeight(); i++) { final double rhs = tableau.getEntry(i, tableau.getWidth() - 1); final double entry = tableau.getEntry(i, col); /* if (MathUtils.compareTo(entry, 0, epsilon) >= 0) { */ if (MathUtils.abs(rhs - entry) < epsilon) { minRatio = rhs; minRatioPos = i; } } else { final double ratio = rhs / entry; if (ratio < minRatio ) { minRatio = ratio; minRatioPos = i; } } } return minRatioPos; }"
      ]
    },
    "Math_85_/src/java/org/apache/commons/math/analysis/solvers/UnivariateRealSolverUtils.java_198-199": {
      "loc": "198-199",
      "input": "<s> public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ <mask> throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; } </s> java",
      "function range": "165,5-208,5",
      "output": [
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ if (numIterations >= maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ if (numIterations == maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ if (numIterations > maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if (numIterations > maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if (numIterations >= maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); } if (numIterations > maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if (numIterations == maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if (numIterations < maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if ( numIterations > maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound, a, b, fa, fb); } return new double[]{a, b}; }",
        "public static double[] bracket(UnivariateRealFunction function, double initial, double lowerBound, double upperBound, int maximumIterations) throws ConvergenceException, FunctionEvaluationException { if (function == null) { throw MathRuntimeException.createIllegalArgumentException(\"function is null\"); } if (maximumIterations <= 0) { throw MathRuntimeException.createIllegalArgumentException( \"bad value for maximum iterations number: {0}\", maximumIterations); } if (initial < lowerBound || initial > upperBound || lowerBound >= upperBound) { throw MathRuntimeException.createIllegalArgumentException( \"invalid bracketing parameters: lower bound={0}, initial={1}, upper bound={2}\", lowerBound, initial, upperBound); } double a = initial; double b = initial; double fa; double fb; int numIterations = 0 ; do { a = Math.max(a - 1.0, lowerBound); b = Math.min(b + 1.0, upperBound); fa = function.value(a); fb = function.value(b); numIterations++ ; } while ((fa * fb > 0.0) && (numIterations < maximumIterations) && ((a > lowerBound) || (b < upperBound))); /* if (fa * fb >= 0.0 ) { */ fa = function.value(a); fb = function.value(b); numIterations++ ; } if (numIterations == maximumIterations) { throw new ConvergenceException( \"number of iterations={0}, maximum iterations={1}, \" + \"initial={2}, lower bound={3}, upper bound={4}, final a value={5}, \" + \"final b value={6}, f(a)={7}, f(b)={8}\", numIterations, maximumIterations, initial, lowerBound, upperBound); } return new double[]{a, b}; }"
      ]
    },
    "Math_91_/src/java/org/apache/commons/math/fraction/Fraction.java_259-261": {
      "loc": "259-261",
      "input": "<s> public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ <mask> return (nOd < dOn) ? -1 : ((nOd > dOn) ? +1 : 0); } </s> java",
      "function range": "258,5-262,5",
      "output": [
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) { return 0 ; } return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) return 0 ; return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) return 0 ; else return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ return nOd - dOn; } public int hashCode() { return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ double oOn = doubleValue(); return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) { return 0; } return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) { return 0 ; } return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0) }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ if (nOd == dOn) { return 0 ; } return (nOd < dOn)? -1 :((nOd > dOn)? +1 : 0); }",
        "public int compareTo(Fraction object) { /* double nOd = doubleValue(); double dOn = object.doubleValue(); */ return nOd - dOn; } public int hashCode() { return (nOd < dOn)? -1 : ((nOd > dOn)? +1 : 0) }"
      ]
    },
    "Math_94_/src/java/org/apache/commons/math/util/MathUtils.java_412-413": {
      "loc": "412-413",
      "input": "<s> public static int gcd(int u, int v) { /* if (u * v == 0) { */ <mask> return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1) ? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t != 0); return -u * (1 << k); } </s> java",
      "function range": "411,5-460,5",
      "output": [
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return 0; } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) - Math.abs(v)); } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v) / 2); } if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) - Math.abs(v)); } if (u * v == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v) / 2); } if (v * u == 0) { return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0) return -u * (1 << k); }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k) ; }",
        "public static int gcd(int u, int v) { /* if (u * v == 0) { */ return (Math.abs(u) - Math.abs(v)); } /* if (u * v == 0) { */ return (Math.abs(u) + Math.abs(v)); } if (u > 0) { u = -u; } if (v > 0) { v = -v; } int k = 0; while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { u /= 2; v /= 2; k++; } if (k == 31) { throw new ArithmeticException(\"overflow: gcd is 2^31\"); } int t = ((u & 1) == 1)? v : -(u / 2); do { while ((t & 1) == 0) { t /= 2; } if (t > 0) { u = -t; } else { v = t; } t = (v - u) / 2; } while (t!= 0); return -u * (1 << k) ; }"
      ]
    },
    "Math_96_/src/java/org/apache/commons/math/complex/Complex.java_258-259": {
      "loc": "258-259",
      "input": "<s> public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ <mask> } } catch (ClassCastException ex) { ret = false; } } return ret; } </s> java",
      "function range": "245,5-267,5",
      "output": [
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = this.equals(rhs); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()); ret = Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())); ret = (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) && Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = Double.compare(Double.doubleToRawLongBits(real), Double.doubleToRawLongBits(rhs.getReal())); ret = Double.compare(Double.doubleToRawLongBits(imaginary), Double.doubleToRawLongBits(rhs.getImaginary())); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) && Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary()); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = Double.compare(real, rhs.getReal()); ret = Double.compare(imaginary, rhs.getImaginary()); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = Double.compare(Double.doubleToRawLongBits(real), Double.doubleToRawLongBits(imaginary)); } } catch (ClassCastException ex) { ret = false; } } return ret; }",
        "public boolean equals(Object other) { boolean ret; if (this == other) { ret = true; } else if (other == null) { ret = false; } else { try { Complex rhs = (Complex)other; if (rhs.isNaN()) { ret = this.isNaN(); } else { /* ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal())) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ ret = (Double.doubleToRawLongBits(real) == Double.doubleToRawLongBits(rhs.getReal()) && (Double.doubleToRawLongBits(imaginary) == Double.doubleToRawLongBits(rhs.getImaginary())); */ } } catch (ClassCastException ex) { ret = false; } } return ret; }"
      ]
    },
    "Math_101_/src/java/org/apache/commons/math/complex/ComplexFormat.java_377-378": {
      "loc": "377-378",
      "input": "<s> public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ <mask> source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter()) != 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } </s> java",
      "function range": "320,5-389,5",
      "output": [
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0 ) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(initialIndex); pos.setErrorIndex(endIndex); return null; } return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return null; } pos.setErrorIndex(startIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } return null; }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } pos.setErrorIndex(startIndex); return null; }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } pos.setErrorIndex(endIndex); return null; }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } pos.setIndex(initialIndex); return null; }",
        "public Complex parse(String source, ParsePosition pos) { int initialIndex = pos.getIndex(); parseAndIgnoreWhitespace(source, pos); Number re = parseNumber(source, getRealFormat(), pos); if (re == null) { pos.setIndex(initialIndex); return null; } int startIndex = pos.getIndex(); char c = parseNextCharacter(source, pos); int sign = 0; switch (c) { case 0 : return new Complex(re.doubleValue(), 0.0); case '-' : sign = -1; break; case '+' : sign = 1; break; default : pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } parseAndIgnoreWhitespace(source, pos); Number im = parseNumber(source, getRealFormat(), pos); if (im == null) { pos.setIndex(initialIndex); return null; } int n = getImaginaryCharacter().length(); startIndex = pos.getIndex(); int endIndex = startIndex + n; /* if ( */ if ( source.substring(startIndex, endIndex).compareTo( getImaginaryCharacter())!= 0) { pos.setIndex(initialIndex); pos.setErrorIndex(startIndex); return null; } else { pos.setIndex(endIndex); return null; } pos.setErrorIndex(startIndex); return new Complex(re.doubleValue(), im.doubleValue() * sign); } return null; }"
      ]
    },
    "Math_105_/src/java/org/apache/commons/math/stat/regression/SimpleRegression.java_264-265": {
      "loc": "264-265",
      "input": "<s> public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ <mask> } </s> java",
      "function range": "263,5-265,5",
      "output": [
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumYY - sumXY * sumXY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumYY + sumXY * sumXY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumYY * sumXY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumXX - sumYY * sumYY / sumYY; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumXY * sumXY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumXX - sumXY * sumXY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumXX - sumYY * sumYY / sumXY; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumXX - sumYY * sumYY / sumXX; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ return sumYY / sumXY; }",
        "public double getSumSquaredErrors() { /* return sumYY - sumXY * sumXY / sumXX; */ }"
      ]
    },
    "Mockito_1_/src/org/mockito/internal/invocation/InvocationMatcher.java_123-124": {
      "loc": "123-124",
      "input": "<s> public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ <mask> } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } } </s> java",
      "function range": "120,5-150,5",
      "output": [
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg)); } } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); m.captureFrom(invocation.getArgumentAt(indexOfVararg, Object.class)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg, Object.class)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); m.captureFrom(invocation.getArgumentAt(indexOfVararg)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ System.out.println(invocation.getArgumentAt(indexOfVararg, Object.class)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ System.out.println(invocation.getRawArguments()[indexOfVararg]); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg)); } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } } else { } }",
        "public void captureArgumentsFrom(Invocation invocation) { if (invocation.getMethod().isVarArgs()) { int indexOfVararg = invocation.getRawArguments().length - 1; /* throw new UnsupportedOperationException(); */ Matcher m = matchers.get(indexOfVararg); if (m instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(indexOfVararg)); } } else { for (int position = 0; position < matchers.size(); position++) { Matcher m = matchers.get(position); if (m instanceof CapturesArguments) { ((CapturesArguments ) m).captureFrom(invocation.getArgumentAt(position, Object.class)); } } } }"
      ]
    },
    "Mockito_5_/src/org/mockito/internal/verification/VerificationOverTimeImpl.java_91-92": {
      "loc": "91-92",
      "input": "<s> public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ <mask> error = handleVerifyException(e); } } if (error != null) { throw error; } } </s> java",
      "function range": "75,5-99,5",
      "output": [
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ } catch (MockitoAssertionError e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ error = handleVerifyException(e); } catch (MockitoAssertionError e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ if (returnOnSuccess) { return; } else { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ } catch (AssertionError e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ error = handleVerifyException(e); } catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ if (error == null) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ error = handleVerifyException(e); } catch (AssertionError e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ error = handleVerifyException(e); } catch (VerifyException e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ error = handleVerifyException(e); } catch (org.mockito.exceptions.verification.junit.VerifyException e) { error = handleVerifyException(e); } } if (error!= null) { throw error; } }",
        "public void verify(VerificationData data) { AssertionError error = null; timer.start(); while (timer.isCounting()) { try { delegate.verify(data); if (returnOnSuccess) { return; } else { error = null; } } catch (MockitoAssertionError e) { error = handleVerifyException(e); } /* catch (org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e) { */ if (returnOnSuccess) { return; } else { error = handleVerifyException(e); } } if (error!= null) { throw error; } } }"
      ]
    },
    "Mockito_7_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_379-380": {
      "loc": "379-380",
      "input": "<s> private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ <mask> } </s> java",
      "function range": "375,9-380,9",
      "output": [
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ registerTypeVariablesOn(getTypeArgumentFor(typeVariable)); }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ for (Type type : typeVariable.getBounds()) { } }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ for (Type type : typeVariable.getBounds()) { readTypeVariables(); } }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ registerTypeVariablesOn(typeVariable.getBounds()); }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ registerTypeVariablesOn(typeVariable.getType()); }",
        "private void readTypeVariables() { for (Type type : typeVariable.getBounds()) { registerTypeVariablesOn(type); } /* registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable)); */ registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable.getType())); }"
      ]
    },
    "Mockito_8_/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java_79-80": {
      "loc": "79-80",
      "input": "<s> protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ <mask> contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } } </s> java",
      "function range": "66,5-84,5",
      "output": [
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument)); } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf(actualTypeArgument)); } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf((TypeVariable) actualTypeArgument)); } else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } if (actualTypeArgument instanceof TypeVariable) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument)); /* } */ else { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf(actualTypeArgument)); } if (actualTypeArgument instanceof TypeVariable) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument)); } if (actualTypeArgument instanceof ParameterizedType) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }",
        "protected void registerTypeVariablesOn(Type classType) { if (!(classType instanceof ParameterizedType)) { return; } ParameterizedType parameterizedType = (ParameterizedType) classType; TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters(); Type[] actualTypeArguments = parameterizedType.getActualTypeArguments(); for (int i = 0; i < actualTypeArguments.length; i++) { TypeVariable typeParameter = typeParameters[i]; Type actualTypeArgument = actualTypeArguments[i]; if (actualTypeArgument instanceof WildcardType) { contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument)); /* } else { */ contextualActualTypeParameters.put(typeParameter, boundsOf((Class<?>) actualTypeArgument)); } if (actualTypeArgument instanceof TypeVariable) { contextualActualTypeParameters.put(typeParameter, actualTypeArgument); } } }"
      ]
    },
    "Mockito_22_/src/org/mockito/internal/matchers/Equality.java_13-14": {
      "loc": "13-14",
      "input": "<s> public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ <mask> return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } } </s> java",
      "function range": "12,5-20,5",
      "output": [
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return false; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return true; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return false; } else if (isObject(o2)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return true; } else if (isObject(o2)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return false ; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return false; } else if (isNull(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return o1!= null && o2!= null; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return false; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2) } else { return o1.equals(o2); } }",
        "public static boolean areEqual(Object o1, Object o2) { /* if (o1 == null || o2 == null) { */ return o1!= null && o2!= null; } else if (isObject(o1)) { return o1 == null && o2 == null; } else if (isArray(o1)) { return isArray(o2) && areArraysEqual(o1, o2); } else { return o1.equals(o2) } }"
      ]
    },
    "Mockito_24_/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java_76-77": {
      "loc": "76-77",
      "input": "<s> public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ <mask> } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); } </s> java",
      "function range": "63,5-81,5",
      "output": [
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else { /* return 0; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else { return invocation.getMethod().getReturnType(); } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else { /* return 2; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else if (methodsGuru.isEqualsToMethod(invocation.getMethod())) { /* return 0; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ return invocation.getMethod().getReturnType(); } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else { return invocation.getMethod(); } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 0; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else if (methodsGuru.isEqualsToMethod(invocation.getMethod())) { /* return 2; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else if (methodsGuru.isCompareToReturnType(invocation.getMethod())) { /* return 2; */ } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }",
        "public Object answer(InvocationOnMock invocation) { if (methodsGuru.isToString(invocation.getMethod())) { Object mock = invocation.getMock(); MockName name = mockUtil.getMockName(mock); if (name.isDefault()) { return \"Mock for \" + mockUtil.getMockSettings(mock).getTypeToMock().getSimpleName() + \", hashCode: \" + mock.hashCode(); } else { return name.toString(); } } else if (methodsGuru.isCompareToMethod(invocation.getMethod())) { /* return 1; */ } else if (methodsGuru.isEqualsToMethod(invocation.getMethod())) { return invocation.getMethod().getReturnType(); } Class<?> returnType = invocation.getMethod().getReturnType(); return returnValueFor(returnType); }"
      ]
    },
    "Mockito_27_/src/org/mockito/internal/util/MockUtil.java_64-66": {
      "loc": "64-66",
      "input": "<s> public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ <mask> ((Factory) mock).setCallback(0, newFilter); } </s> java",
      "function range": "62,5-67,5",
      "output": [
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(0, newFilter); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(1, newFilter); ((Factory) mock).setCallback(2, newFilter); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(0, oldMockHandler); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(1, newFilter); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(newFilter); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ if (mock instanceof Factory) ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(newMockHandler); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(0, null); ((Factory) mock).setCallback(0, newFilter); }",
        "public <T> void resetMock(T mock) { MockHandlerInterface<T> oldMockHandler = getMockHandler(mock); /* MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler); MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS)); */ ((Factory) mock).setCallback(0, newFilter); ((Factory) mock).setCallback(0, newFilter); ((Factory) mock).setCallback(0, newFilter); }"
      ]
    },
    "Mockito_28_/src/org/mockito/internal/configuration/DefaultInjectionEngine.java_93-94": {
      "loc": "93-94",
      "input": "<s> private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ <mask> } } </s> java",
      "function range": "91,5-95,5",
      "output": [
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ mocks.add(fieldInstance); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ injectMockCandidate(awaitingInjectionClazz, mocks, fieldInstance); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ mocks.add(field); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ mockCandidateFilter.filterCandidate(mocks, fieldInstance, fieldInstance).thenInject(); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ if(mocks.contains(fieldInstance)) { mocks.add(fieldInstance); } } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ mockCandidateFilter.filterCandidate(mocks, fieldInstance).thenInject(); } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ if(mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject()) { return; } } }",
        "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) { for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) { /* mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject(); */ if (mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject()) { return; } } }"
      ]
    },
    "Mockito_29_/src/org/mockito/internal/matchers/Same.java_29-30": {
      "loc": "29-30",
      "input": "<s> public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ <mask> appendQuoting(description); description.appendText(\")\"); } </s> java",
      "function range": "26,5-32,5",
      "output": [
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"(\"); appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ } public void describeTo(Description description) { appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\" (\"); appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"('\"); appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\")\"); appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"('); appendQuoting(description); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"(\"); appendQuoting(description); description.appendText(\")\"); description.appendText(\")\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"(\"); appendQuoting(description); description.appendText(\")\"); description.appendText(\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ description.appendText(\"(\"); appendQuoting(description); description.appendText(\")\"); description.appendText(\"(\"); }",
        "public void describeTo(Description description) { description.appendText(\"same(\"); appendQuoting(description); /* description.appendText(wanted.toString()); */ } public void describeTo(Description description) { appendQuoting(description); description.appendText(\"(\"); }"
      ]
    },
    "Mockito_34_/src/org/mockito/internal/invocation/InvocationMatcher.java_106-107": {
      "loc": "106-107",
      "input": "<s> public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ <mask> ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } } </s> java",
      "function range": "103,5-111,5",
      "output": [
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k] instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]!= null) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()!= null) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } */ } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } */ }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]!= null) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } } }",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k] instanceof CapturesArguments) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } */",
        "public void captureArgumentsFrom(Invocation i) { int k = 0; for (Matcher m : matchers) { /* if (m instanceof CapturesArguments) { */ if (i.getArguments()[k]!= null) { ((CapturesArguments) m).captureFrom(i.getArguments()[k]); } k++; } */ }"
      ]
    },
    "Mockito_38_/src/org/mockito/internal/verification/argumentmatching/ArgumentMatchingTool.java_48-49": {
      "loc": "48-49",
      "input": "<s> private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ <mask> } </s> java",
      "function range": "47,5-49,5",
      "output": [
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return true; }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return false; }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return super.toStringEquals(m, arg); }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m.matches(arg); }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m.toString() == arg.toString(); }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m instanceof StringDescription; }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m.group(1) == arg.group(1) ; }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m instanceof StringDescription && arg instanceof StringDescription; }",
        "private boolean toStringEquals(Matcher m, Object arg) { /* return StringDescription.toString(m).equals(arg.toString()); */ return m.group(1) == arg.group(1); }"
      ]
    },
    "Time_4_/src/main/java/org/joda/time/Partial.java_464-465": {
      "loc": "464-465",
      "input": "<s> public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ <mask> iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); } </s> java",
      "function range": "426,5-474,5",
      "output": [
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ iChronology.validate(newPartial, newTypes); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ newPartial = new Partial(iChronology, newTypes, newValues); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ System.arraycopy(iChronology, i, newPartial, i + 1, newTypes.length - i - 1); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ System.arraycopy(iChronology, iChronology, newTypes, i + 1, newTypes.length - i - 1); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ System.arraycopy(newTypes, i, newValues, i + 1, newTypes.length - i - 1); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).get(this, index, newValues, value); return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ iChronology.validate(newPartial, newTypes); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); newTypes[index] = fieldType; newValues[index] = value; return new Partial(this, newValues); }",
        "public Partial with(DateTimeFieldType fieldType, int value) { if (fieldType == null) { throw new IllegalArgumentException(\"The field type must not be null\"); } int index = indexOf(fieldType); if (index == -1) { DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1]; int[] newValues = new int[newTypes.length]; int i = 0; DurationField unitField = fieldType.getDurationType().getField(iChronology); if (unitField.isSupported()) { for (; i < iTypes.length; i++) { DateTimeFieldType loopType = iTypes[i]; DurationField loopUnitField = loopType.getDurationType().getField(iChronology); if (loopUnitField.isSupported()) { int compare = unitField.compareTo(loopUnitField); if (compare > 0) { break; } else if (compare == 0) { DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology); DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology); if (rangeField.compareTo(loopRangeField) > 0) { break; } } } } } System.arraycopy(iTypes, 0, newTypes, 0, i); System.arraycopy(iValues, 0, newValues, 0, i); newTypes[i] = fieldType; newValues[i] = value; System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1); System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1); /* Partial newPartial = new Partial(iChronology, newTypes, newValues); */ iChronology.validate(newPartial, newTypes); iChronology.validate(newPartial, newValues); return newPartial; } if (value == getValue(index)) { return this; } int[] newValues = getValues(); newValues = getField(index).set(this, index, newValues, value); return new Partial(this, newValues);"
      ]
    },
    "Time_15_/src/main/java/org/joda/time/field/FieldUtils.java_138-139": {
      "loc": "138-139",
      "input": "<s> public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ <mask> case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2 != val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; } </s> java",
      "function range": "135,5-149,5",
      "output": [
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: /* return val1; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: /* return val2; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: return val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: return val2; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 0: /* return val2; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 0: /* return val1; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ return val1; case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: /* return val1; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total ; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 1: /* return val2; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total ; }",
        "public static long safeMultiply(long val1, int val2) { switch (val2) { case -1: /* return -val1; */ case 0: /* return val2; */ case 0: return 0L; case 1: return val1; } long total = val1 * val2; if (total / val2!= val1) { throw new ArithmeticException(\"Multiplication overflows a long: \" + val1 + \" * \" + val2); } return total ; }"
      ]
    },
    "Time_16_/src/main/java/org/joda/time/format/DateTimeFormatter.java_709-710": {
      "loc": "709-710",
      "input": "<s> public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ <mask> int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger() != null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone() != null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone != null) { instant.setZone(iZone); } return newPos; } </s> java",
      "function range": "697,5-724,5",
      "output": [
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ if (iZone!= null) { chrono = chrono.withZone(iZone); } int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ if (iLocale!= null) { chrono = chrono.withLocale(iLocale); } int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ int iOffsetParsed = bucket.getOffsetInteger(); DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ boolean iOffsetParsed = bucket.getOffsetParsed(); DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ if (iLocale!= null) { bucket.setLocale(iLocale); } int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ int iOffsetParsed = bucket.getOffsetInteger()!= null; DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ boolean iOffsetParsed = bucket.getOffsetInteger()!= null; DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ if (iZone!= null) { chrono = chrono.withZone(iZone); } int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos ; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ int iOffsetParsed = bucket.getOffsetInteger()!= null; DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos ; }",
        "public int parseInto(ReadWritableInstant instant, String text, int position) { DateTimeParser parser = requireParser(); if (instant == null) { throw new IllegalArgumentException(\"Instant must not be null\"); } long instantMillis = instant.getMillis(); Chronology chrono = instant.getChronology(); long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis); chrono = selectChronology(chrono); DateTimeParserBucket bucket = new DateTimeParserBucket( /* instantLocal, chrono, iLocale, iPivotYear, iDefaultYear); */ boolean iOffsetParsed = bucket.getOffsetInteger()!= null; DateTimeZone iZone = bucket.getZone(); int newPos = parser.parseInto(bucket, text, position); instant.setMillis(bucket.computeMillis(false, text)); if (iOffsetParsed && bucket.getOffsetInteger()!= null) { int parsedOffset = bucket.getOffsetInteger(); DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset); chrono = chrono.withZone(parsedZone); } else if (bucket.getZone()!= null) { chrono = chrono.withZone(bucket.getZone()); } instant.setChronology(chrono); if (iZone!= null) { instant.setZone(iZone); } return newPos ; }"
      ]
    },
    "Time_19_/src/main/java/org/joda/time/DateTimeZone.java_900-901": {
      "loc": "900-901",
      "input": "<s> public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal != offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal != nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ <mask> long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } </s> java",
      "function range": "880,5-911,5",
      "output": [
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long prev = previousTransition(instantAdjusted); long prevAdjusted = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long nextLocal = previousTransition(instantAdjusted); long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long previousLocal = previousTransition(instantAdjusted); long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long previousLocal = previousTransition(instantAdjusted); long previousAdjusted = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ return offsetLocal; } else if (offsetLocal < instantAdjusted) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ return offsetLocal; } if (offsetLocal < instantAdjusted) { long prev = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long prev = previousTransition(instantAdjusted); long prevAdjusted = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted; } return offsetAdjusted; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long previousLocal = previousTransition(instantAdjusted); long previousAdjusted = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } } return offsetAdjusted ; }",
        "public int getOffsetFromLocal(long instantLocal) { final int offsetLocal = getOffset(instantLocal); final long instantAdjusted = instantLocal - offsetLocal; final int offsetAdjusted = getOffset(instantAdjusted); if (offsetLocal!= offsetAdjusted) { if ((offsetLocal - offsetAdjusted) < 0) { long nextLocal = nextTransition(instantAdjusted); long nextAdjusted = nextTransition(instantLocal - offsetAdjusted); if (nextLocal!= nextAdjusted) { return offsetLocal; } } /* } else if (offsetLocal > 0) { */ long prev = previousTransition(instantAdjusted); long prevAdjusted = previousTransition(instantAdjusted); if (prev < instantAdjusted) { int offsetPrev = getOffset(prev); int diff = offsetPrev - offsetLocal; if (instantAdjusted - prev <= diff) { return offsetPrev; } } else { return offsetLocal; } } return offsetLocal; }"
      ]
    }
  },
  "model": "plbart-base"
}